{
  "version": 3,
  "file": "/Users/eli/projects/draw/build/javascript/main.min.js",
  "sources": [
    "../../node_modules/grunt-requirejs/node_modules/almond/almond.js",
    "vendor/promise-0.1.1.js",
    "event.js",
    "globals.js",
    "helpers.js",
    "class.js",
    "section.js",
    "tapHandler.js",
    "gauth.js",
    "sections/login.js",
    "platform.js",
    "sequentialHelper.js",
    "bezierCurve.js",
    "components/drawCanvas.js",
    "components/manipulateCanvas.js",
    "components/thumbnail.js",
    "dataLayer/file.js",
    "vendor/db.js",
    "dataLayer/indexedDBBacking.js",
    "dataLayer/webSQLBacking.js",
    "dataLayer/driveBacking.js",
    "dataLayer/data.js",
    "online.js",
    "sections/statusIndicator.js",
    "templates/fileList.js",
    "sections/fileList.js",
    "sections/draw.js",
    "managers/files.js",
    "sections/main.js",
    "managers/login.js",
    "main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvwBA,ADwwBA;ACvwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA,AD2DA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtRA,ADuRA;ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA,ADoBA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA,ADkGA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1oBA,AD2oBA;AC1oBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjkBA,ADkkBA;ACjkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClUA,ADmUA;AClUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA,ADqBA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/OA,ADgPA;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACttBA,ADutBA;ACttBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxEA,ADyEA;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA,ADgEA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\n/**\n * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n",
    "\n(function() {\nvar define, requireModule, require, requirejs;\n\n(function() {\n  var registry = {}, seen = {};\n\n  define = function(name, deps, callback) {\n    registry[name] = { deps: deps, callback: callback };\n  };\n\n  requirejs = require = requireModule = function(name) {\n  requirejs._eak_seen = registry;\n\n    if (seen[name]) { return seen[name]; }\n    seen[name] = {};\n\n    if (!registry[name]) {\n      throw new Error(\"Could not find module \" + name);\n    }\n\n    var mod = registry[name],\n        deps = mod.deps,\n        callback = mod.callback,\n        reified = [],\n        exports;\n\n    for (var i=0, l=deps.length; i<l; i++) {\n      if (deps[i] === 'exports') {\n        reified.push(exports = {});\n      } else {\n        reified.push(requireModule(resolve(deps[i])));\n      }\n    }\n\n    var value = callback.apply(this, reified);\n    return seen[name] = exports || value;\n\n    function resolve(child) {\n      if (child.charAt(0) !== '.') { return child; }\n      var parts = child.split(\"/\");\n      var parentBase = name.split(\"/\").slice(0, -1);\n\n      for (var i=0, l=parts.length; i<l; i++) {\n        var part = parts[i];\n\n        if (part === '..') { parentBase.pop(); }\n        else if (part === '.') { continue; }\n        else { parentBase.push(part); }\n      }\n\n      return parentBase.join(\"/\");\n    }\n  };\n})();\n\ndefine(\"promise/all\", \n  [\"./utils\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    /* global toString */\n\n    var isArray = __dependency1__.isArray;\n    var isFunction = __dependency1__.isFunction;\n\n    /**\n      Returns a promise that is fulfilled when all the given promises have been\n      fulfilled, or rejected if any of them become rejected. The return promise\n      is fulfilled with an array that gives all the values in the order they were\n      passed in the `promises` array argument.\n\n      Example:\n\n      ```javascript\n      var promise1 = RSVP.resolve(1);\n      var promise2 = RSVP.resolve(2);\n      var promise3 = RSVP.resolve(3);\n      var promises = [ promise1, promise2, promise3 ];\n\n      RSVP.all(promises).then(function(array){\n        // The array here would be [ 1, 2, 3 ];\n      });\n      ```\n\n      If any of the `promises` given to `RSVP.all` are rejected, the first promise\n      that is rejected will be given as an argument to the returned promises's\n      rejection handler. For example:\n\n      Example:\n\n      ```javascript\n      var promise1 = RSVP.resolve(1);\n      var promise2 = RSVP.reject(new Error(\"2\"));\n      var promise3 = RSVP.reject(new Error(\"3\"));\n      var promises = [ promise1, promise2, promise3 ];\n\n      RSVP.all(promises).then(function(array){\n        // Code here never runs because there are rejected promises!\n      }, function(error) {\n        // error.message === \"2\"\n      });\n      ```\n\n      @method all\n      @for RSVP\n      @param {Array} promises\n      @param {String} label\n      @return {Promise} promise that is fulfilled when all `promises` have been\n      fulfilled, or rejected if any of them become rejected.\n    */\n    function all(promises) {\n      /*jshint validthis:true */\n      var Promise = this;\n\n      if (!isArray(promises)) {\n        throw new TypeError('You must pass an array to all.');\n      }\n\n      return new Promise(function(resolve, reject) {\n        var results = [], remaining = promises.length,\n        promise;\n\n        if (remaining === 0) {\n          resolve([]);\n        }\n\n        function resolver(index) {\n          return function(value) {\n            resolveAll(index, value);\n          };\n        }\n\n        function resolveAll(index, value) {\n          results[index] = value;\n          if (--remaining === 0) {\n            resolve(results);\n          }\n        }\n\n        for (var i = 0; i < promises.length; i++) {\n          promise = promises[i];\n\n          if (promise && isFunction(promise.then)) {\n            promise.then(resolver(i), reject);\n          } else {\n            resolveAll(i, promise);\n          }\n        }\n      });\n    }\n\n    __exports__.all = all;\n  });\ndefine(\"promise/asap\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var browserGlobal = (typeof window !== 'undefined') ? window : {};\n    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n    var local = (typeof global !== 'undefined') ? global : this;\n\n    // node\n    function useNextTick() {\n      return function() {\n        process.nextTick(flush);\n      };\n    }\n\n    function useMutationObserver() {\n      var iterations = 0;\n      var observer = new BrowserMutationObserver(flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    function useSetTimeout() {\n      return function() {\n        local.setTimeout(flush, 1);\n      };\n    }\n\n    var queue = [];\n    function flush() {\n      for (var i = 0; i < queue.length; i++) {\n        var tuple = queue[i];\n        var callback = tuple[0], arg = tuple[1];\n        callback(arg);\n      }\n      queue = [];\n    }\n\n    var scheduleFlush;\n\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n      scheduleFlush = useNextTick();\n    } else if (BrowserMutationObserver) {\n      scheduleFlush = useMutationObserver();\n    } else {\n      scheduleFlush = useSetTimeout();\n    }\n\n    function asap(callback, arg) {\n      var length = queue.push([callback, arg]);\n      if (length === 1) {\n        // If length is 1, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        scheduleFlush();\n      }\n    }\n\n    __exports__.asap = asap;\n  });\ndefine(\"promise/cast\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    /**\n      `RSVP.Promise.cast` returns the same promise if that promise shares a constructor\n      with the promise being casted.\n\n      Example:\n\n      ```javascript\n      var promise = RSVP.resolve(1);\n      var casted = RSVP.Promise.cast(promise);\n\n      console.log(promise === casted); // true\n      ```\n\n      In the case of a promise whose constructor does not match, it is assimilated.\n      The resulting promise will fulfill or reject based on the outcome of the\n      promise being casted.\n\n      In the case of a non-promise, a promise which will fulfill with that value is\n      returned.\n\n      Example:\n\n      ```javascript\n      var value = 1; // could be a number, boolean, string, undefined...\n      var casted = RSVP.Promise.cast(value);\n\n      console.log(value === casted); // false\n      console.log(casted instanceof RSVP.Promise) // true\n\n      casted.then(function(val) {\n        val === value // => true\n      });\n      ```\n\n      `RSVP.Promise.cast` is similar to `RSVP.resolve`, but `RSVP.Promise.cast` differs in the\n      following ways:\n      * `RSVP.Promise.cast` serves as a memory-efficient way of getting a promise, when you\n      have something that could either be a promise or a value. RSVP.resolve\n      will have the same effect but will create a new promise wrapper if the\n      argument is a promise.\n      * `RSVP.Promise.cast` is a way of casting incoming thenables or promise subclasses to\n      promises of the exact class specified, so that the resulting object's `then` is\n      ensured to have the behavior of the constructor you are calling cast on (i.e., RSVP.Promise).\n\n      @method cast\n      @for RSVP\n      @param {Object} object to be casted\n      @return {Promise} promise that is fulfilled when all properties of `promises`\n      have been fulfilled, or rejected if any of them become rejected.\n    */\n\n\n    function cast(object) {\n      /*jshint validthis:true */\n      if (object && typeof object === 'object' && object.constructor === this) {\n        return object;\n      }\n\n      var Promise = this;\n\n      return new Promise(function(resolve) {\n        resolve(object);\n      });\n    }\n\n    __exports__.cast = cast;\n  });\ndefine(\"promise/config\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    var config = {\n      instrument: false\n    };\n\n    function configure(name, value) {\n      if (arguments.length === 2) {\n        config[name] = value;\n      } else {\n        return config[name];\n      }\n    }\n\n    __exports__.config = config;\n    __exports__.configure = configure;\n  });\ndefine(\"promise/polyfill\", \n  [\"./promise\",\"./utils\",\"exports\"],\n  function(__dependency1__, __dependency2__, __exports__) {\n    \"use strict\";\n    var RSVPPromise = __dependency1__.Promise;\n    var isFunction = __dependency2__.isFunction;\n\n    function polyfill() {\n      var es6PromiseSupport = \n        \"Promise\" in window &&\n        // Some of these methods are missing from\n        // Firefox/Chrome experimental implementations\n        \"cast\" in window.Promise &&\n        \"resolve\" in window.Promise &&\n        \"reject\" in window.Promise &&\n        \"all\" in window.Promise &&\n        \"race\" in window.Promise &&\n        // Older version of the spec had a resolver object\n        // as the arg rather than a function\n        (function() {\n          var resolve;\n          new window.Promise(function(r) { resolve = r; });\n          return isFunction(resolve);\n        }());\n\n      if (!es6PromiseSupport) {\n        window.Promise = RSVPPromise;\n      }\n    }\n\n    __exports__.polyfill = polyfill;\n  });\ndefine(\"promise/promise\", \n  [\"./config\",\"./utils\",\"./cast\",\"./all\",\"./race\",\"./resolve\",\"./reject\",\"./asap\",\"exports\"],\n  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __exports__) {\n    \"use strict\";\n    var config = __dependency1__.config;\n    var configure = __dependency1__.configure;\n    var objectOrFunction = __dependency2__.objectOrFunction;\n    var isFunction = __dependency2__.isFunction;\n    var now = __dependency2__.now;\n    var cast = __dependency3__.cast;\n    var all = __dependency4__.all;\n    var race = __dependency5__.race;\n    var staticResolve = __dependency6__.resolve;\n    var staticReject = __dependency7__.reject;\n    var asap = __dependency8__.asap;\n\n    var counter = 0;\n\n    config.async = asap; // default async is asap;\n\n    function Promise(resolver) {\n      if (!isFunction(resolver)) {\n        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n      }\n\n      if (!(this instanceof Promise)) {\n        throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n      }\n\n      this._subscribers = [];\n\n      invokeResolver(resolver, this);\n    }\n\n    function invokeResolver(resolver, promise) {\n      function resolvePromise(value) {\n        resolve(promise, value);\n      }\n\n      function rejectPromise(reason) {\n        reject(promise, reason);\n      }\n\n      try {\n        resolver(resolvePromise, rejectPromise);\n      } catch(e) {\n        rejectPromise(e);\n      }\n    }\n\n    function invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        try {\n          value = callback(detail);\n          succeeded = true;\n        } catch(e) {\n          failed = true;\n          error = e;\n        }\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (handleThenable(promise, value)) {\n        return;\n      } else if (hasCallback && succeeded) {\n        resolve(promise, value);\n      } else if (failed) {\n        reject(promise, error);\n      } else if (settled === FULFILLED) {\n        resolve(promise, value);\n      } else if (settled === REJECTED) {\n        reject(promise, value);\n      }\n    }\n\n    var PENDING   = void 0;\n    var SEALED    = 0;\n    var FULFILLED = 1;\n    var REJECTED  = 2;\n\n    function subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      subscribers[length] = child;\n      subscribers[length + FULFILLED] = onFulfillment;\n      subscribers[length + REJECTED]  = onRejection;\n    }\n\n    function publish(promise, settled) {\n      var child, callback, subscribers = promise._subscribers, detail = promise._detail;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        invokeCallback(settled, child, callback, detail);\n      }\n\n      promise._subscribers = null;\n    }\n\n    Promise.prototype = {\n      constructor: Promise,\n\n      _state: undefined,\n      _detail: undefined,\n      _subscribers: undefined,\n\n      then: function(onFulfillment, onRejection) {\n        var promise = this;\n\n        var thenPromise = new this.constructor(function() {});\n\n        if (this._state) {\n          var callbacks = arguments;\n          config.async(function invokePromiseCallback() {\n            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);\n          });\n        } else {\n          subscribe(this, thenPromise, onFulfillment, onRejection);\n        }\n\n        return thenPromise;\n      },\n\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n\n    Promise.all = all;\n    Promise.cast = cast;\n    Promise.race = race;\n    Promise.resolve = staticResolve;\n    Promise.reject = staticReject;\n\n    function handleThenable(promise, value) {\n      var then = null,\n      resolved;\n\n      try {\n        if (promise === value) {\n          throw new TypeError(\"A promises callback cannot return that same promise.\");\n        }\n\n        if (objectOrFunction(value)) {\n          then = value.then;\n\n          if (isFunction(then)) {\n            then.call(value, function(val) {\n              if (resolved) { return true; }\n              resolved = true;\n\n              if (value !== val) {\n                resolve(promise, val);\n              } else {\n                fulfill(promise, val);\n              }\n            }, function(val) {\n              if (resolved) { return true; }\n              resolved = true;\n\n              reject(promise, val);\n            });\n\n            return true;\n          }\n        }\n      } catch (error) {\n        if (resolved) { return true; }\n        reject(promise, error);\n        return true;\n      }\n\n      return false;\n    }\n\n    function resolve(promise, value) {\n      if (promise === value) {\n        fulfill(promise, value);\n      } else if (!handleThenable(promise, value)) {\n        fulfill(promise, value);\n      }\n    }\n\n    function fulfill(promise, value) {\n      if (promise._state !== PENDING) { return; }\n      promise._state = SEALED;\n      promise._detail = value;\n\n      config.async(publishFulfillment, promise);\n    }\n\n    function reject(promise, reason) {\n      if (promise._state !== PENDING) { return; }\n      promise._state = SEALED;\n      promise._detail = reason;\n\n      config.async(publishRejection, promise);\n    }\n\n    function publishFulfillment(promise) {\n      publish(promise, promise._state = FULFILLED);\n    }\n\n    function publishRejection(promise) {\n      publish(promise, promise._state = REJECTED);\n    }\n\n    __exports__.Promise = Promise;\n  });\ndefine(\"promise/race\", \n  [\"./utils\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    /* global toString */\n    var isArray = __dependency1__.isArray;\n\n    /**\n      `RSVP.race` allows you to watch a series of promises and act as soon as the\n      first promise given to the `promises` argument fulfills or rejects.\n\n      Example:\n\n      ```javascript\n      var promise1 = new RSVP.Promise(function(resolve, reject){\n        setTimeout(function(){\n          resolve(\"promise 1\");\n        }, 200);\n      });\n\n      var promise2 = new RSVP.Promise(function(resolve, reject){\n        setTimeout(function(){\n          resolve(\"promise 2\");\n        }, 100);\n      });\n\n      RSVP.race([promise1, promise2]).then(function(result){\n        // result === \"promise 2\" because it was resolved before promise1\n        // was resolved.\n      });\n      ```\n\n      `RSVP.race` is deterministic in that only the state of the first completed\n      promise matters. For example, even if other promises given to the `promises`\n      array argument are resolved, but the first completed promise has become\n      rejected before the other promises became fulfilled, the returned promise\n      will become rejected:\n\n      ```javascript\n      var promise1 = new RSVP.Promise(function(resolve, reject){\n        setTimeout(function(){\n          resolve(\"promise 1\");\n        }, 200);\n      });\n\n      var promise2 = new RSVP.Promise(function(resolve, reject){\n        setTimeout(function(){\n          reject(new Error(\"promise 2\"));\n        }, 100);\n      });\n\n      RSVP.race([promise1, promise2]).then(function(result){\n        // Code here never runs because there are rejected promises!\n      }, function(reason){\n        // reason.message === \"promise2\" because promise 2 became rejected before\n        // promise 1 became fulfilled\n      });\n      ```\n\n      @method race\n      @for RSVP\n      @param {Array} promises array of promises to observe\n      @param {String} label optional string for describing the promise returned.\n      Useful for tooling.\n      @return {Promise} a promise that becomes fulfilled with the value the first\n      completed promises is resolved with if the first completed promise was\n      fulfilled, or rejected with the reason that the first completed promise\n      was rejected with.\n    */\n    function race(promises) {\n      /*jshint validthis:true */\n      var Promise = this;\n\n      if (!isArray(promises)) {\n        throw new TypeError('You must pass an array to race.');\n      }\n      return new Promise(function(resolve, reject) {\n        var results = [], promise;\n\n        for (var i = 0; i < promises.length; i++) {\n          promise = promises[i];\n\n          if (promise && typeof promise.then === 'function') {\n            promise.then(resolve, reject);\n          } else {\n            resolve(promise);\n          }\n        }\n      });\n    }\n\n    __exports__.race = race;\n  });\ndefine(\"promise/reject\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    /**\n      `RSVP.reject` returns a promise that will become rejected with the passed\n      `reason`. `RSVP.reject` is essentially shorthand for the following:\n\n      ```javascript\n      var promise = new RSVP.Promise(function(resolve, reject){\n        reject(new Error('WHOOPS'));\n      });\n\n      promise.then(function(value){\n        // Code here doesn't run because the promise is rejected!\n      }, function(reason){\n        // reason.message === 'WHOOPS'\n      });\n      ```\n\n      Instead of writing the above, your code now simply becomes the following:\n\n      ```javascript\n      var promise = RSVP.reject(new Error('WHOOPS'));\n\n      promise.then(function(value){\n        // Code here doesn't run because the promise is rejected!\n      }, function(reason){\n        // reason.message === 'WHOOPS'\n      });\n      ```\n\n      @method reject\n      @for RSVP\n      @param {Any} reason value that the returned promise will be rejected with.\n      @param {String} label optional string for identifying the returned promise.\n      Useful for tooling.\n      @return {Promise} a promise that will become rejected with the given\n      `reason`.\n    */\n    function reject(reason) {\n      /*jshint validthis:true */\n      var Promise = this;\n\n      return new Promise(function (resolve, reject) {\n        reject(reason);\n      });\n    }\n\n    __exports__.reject = reject;\n  });\ndefine(\"promise/resolve\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    /**\n      `RSVP.resolve` returns a promise that will become fulfilled with the passed\n      `value`. `RSVP.resolve` is essentially shorthand for the following:\n\n      ```javascript\n      var promise = new RSVP.Promise(function(resolve, reject){\n        resolve(1);\n      });\n\n      promise.then(function(value){\n        // value === 1\n      });\n      ```\n\n      Instead of writing the above, your code now simply becomes the following:\n\n      ```javascript\n      var promise = RSVP.resolve(1);\n\n      promise.then(function(value){\n        // value === 1\n      });\n      ```\n\n      @method resolve\n      @for RSVP\n      @param {Any} value value that the returned promise will be resolved with\n      @param {String} label optional string for identifying the returned promise.\n      Useful for tooling.\n      @return {Promise} a promise that will become fulfilled with the given\n      `value`\n    */\n    function resolve(value) {\n      /*jshint validthis:true */\n      var Promise = this;\n      return new Promise(function(resolve, reject) {\n        resolve(value);\n      });\n    }\n\n    __exports__.resolve = resolve;\n  });\ndefine(\"promise/utils\", \n  [\"exports\"],\n  function(__exports__) {\n    \"use strict\";\n    function objectOrFunction(x) {\n      return isFunction(x) || (typeof x === \"object\" && x !== null);\n    }\n\n    function isFunction(x) {\n      return typeof x === \"function\";\n    }\n\n    function isArray(x) {\n      return Object.prototype.toString.call(x) === \"[object Array]\";\n    }\n\n    // Date.now is not available in browsers < IE9\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility\n    var now = Date.now || function() { return new Date().getTime(); };\n\n\n    __exports__.objectOrFunction = objectOrFunction;\n    __exports__.isFunction = isFunction;\n    __exports__.isArray = isArray;\n    __exports__.now = now;\n  });\nrequireModule('promise/polyfill').polyfill();\n}());\ndefine(\"promise\", function(){});\n",
    "\ndefine('event',[], function() {\n\n  function Event() {\n    this.init();\n  }\n\n  Event.prototype = {\n    listeners: null,\n\n    init: function() {\n      this.listeners = [];\n    },\n\n    addListener: function(event, callback) {\n      if (!this.listeners[event]) {\n        this.listeners[event] = [];\n      }\n\n      this.listeners[event].push(callback);\n    },\n\n    removeListener: function(event, callback) {\n      if (!this.listeners[event]) {\n        return false;\n      }\n\n      var index = this.listeners[event].indexOf(callback);\n      if (index !== -1) {\n        delete this.listeners[event][index];\n        return true;\n      }\n\n      return false;\n    },\n\n    trigger: function(event, data) {\n      //console.log(\"Triggering\", event, data, this.listeners[event] ? this.listeners[event].length : 0, \"listeners\");\n\n      if (!this.listeners[event]) {\n        return false;\n      }\n\n      this.listeners[event].forEach(function(listener) {\n        listener(data);\n      });\n\n      return true;\n    }\n  }\n\n  return new Event(); \n\n});",
    "\ndefine('globals',[\"event\"], function(Event) {\n  var Globals = function Globals() {\n    this.init();\n  };\n\n  Globals.prototype = {\n    init: function() {\n    },\n\n    isiOS: function() {\n      return this.hasDeviceType(\"iOS\");\n    },\n\n    isPC: function() {\n      return this.hasDeviceType(\"PC\");\n    },\n\n    isMac: function() {\n      return this.hasDeviceType(\"Mac\");\n    },\n\n    isComputer: function() {\n      return this.hasDeviceType(\"computer\");\n    },\n\n    isPhone: function() {\n      return this.hasDeviceType(\"phone\");\n    },\n\n    hasDeviceType: function(type) {\n      return this.getDeviceType().indexOf(type) !== -1;\n    },\n\n    getDeviceType: function() {\n      if (localStorage.deviceType) {\n        //return JSON.parse(localStorage.deviceType);\n      }\n\n      var devices = [];\n      var userAgent = navigator.userAgent;\n\n      if (userAgent.match(/OS 7/g)) {\n        devices.push(\"iOS\");\n\n        if (userAgent.match(/iPad/g)) {\n          devices.push(\"iPad\");\n          devices.push(\"tablet\");\n        } else if (userAgent.match(/iPhone/g)) {\n          devices.push(\"iPhone\");\n          devices.push(\"phone\");\n        }\n      } else if (userAgent.match(/Mac/g)) {\n        devices.push(\"Mac\");\n        devices.push(\"computer\");\n      } else {\n        devices.push(\"PC\");\n        devices.push(\"computer\");\n      }\n\n      localStorage.deviceType = JSON.stringify(devices);\n\n      return devices;\n    },\n\n    setHTMLDevices: function() {\n      var devices = this.getDeviceType();\n\n      var body = document.body;\n      body.className = devices.join(\" \");\n    }\n  }\n\n  return new Globals();\n});",
    "\ndefine('helpers',[], function() {\n  return {\n    parentEleWithClassname: function(ele, className) {\n      if (ele == null || !ele.classList) {\n        return false;\n      }\n\n      if (ele.classList.contains(className)) {\n        return ele;\n      }\n\n      return this.parentEleWithClassname(ele.parentNode, className);\n    },\n\n\n    screenToWorld: function(settings, x, y) {\n      return {\n        x: (x - settings.offsetX) / settings.scale,\n        y: (y - settings.offsetY) / settings.scale\n      };\n    },\n\n    worldToScreen: function(settings, x, y) {\n      return {\n        x: (x) * settings.scale + settings.offsetX,\n        y: (y) * settings.scale + settings.offsetY\n      };\n    },\n\n    getGuid: function() {\n      return \"T^\" + Date.now() + \"\" + Math.round(Math.random() * 1000000);\n    },\n\n    isLocalGuid: function(id) {\n      return id.indexOf(\"T^\") === 0;\n    },\n\n    clone: function(obj) {\n      var newObj = {};\n      for (var prop in obj) {\n        newObj[prop] = obj[prop];\n      }\n\n      return newObj;\n    },\n\n    cloneArray: function(array) {\n      var arr = array.slice(0);\n      \n      for (var i = 0; i < array.length; i++) {\n        if (typeof(array[i]) == \"object\") {\n          //recursion\n          arr[i] = this.cloneArray(array[i]);\n        }\n      }\n      return arr;\n    },\n  };\n});",
    "\ndefine('class',[], function() {\n\t/* Simple Javascript inheritance by John Resig */\n\n\tvar initializing = false,\n\t\tfnTest = /xyz/.test(function() {\n\t\t\txyz;\n\t\t}) ? /\\b_super\\b/ : /.*/;\n\n\t// The base CClass implementation (does nothing)\n\tthis.Class = function() {};\n\n\t// Create a new CLass that inherits from this class\n\tClass.extend = function(prop) {\n\t\tvar _super = this.prototype;\n\n\t\t// Instantiate a base class (but only create the instance, don't run the consutrcutor)\n\t\tinitializing = true;\n\t\tvar prototype = new this();\n\t\tinitializing = false;\n\n\t\t// Copy the properties over onto the new prototype\n\t\tfor (var name in prop) {\n\t\t\t// Check if we're overwriting an existing function\n\t\t\tprototype[name] = typeof prop[name] == \"function\" && typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n\t\t\t\t(function(name, fn) {\n\t\t\t\treturn function() {\t\t\t\t\n\t\t\t\t\tvar tmp = this._super;\n\n\t\t\t\t\t// Add a new ._super() method that is the same method\n\t\t\t\t\t// but on the super-class\n\t\t\t\t\tthis._super = _super[name];\n\n\t\t\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t\t\t// remove it when we're done executing\n\n\t\t\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\t\t\tthis._super = tmp;\n\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\t\t\t})(name, prop[name]) : prop[name];\n\t\t}\n\n\t\t// The dummy class constructor\n\n\t\tfunction Class() {\n\t\t\t// All construction is actually done in the init method\n\t\t\tif (!initializing && this.init)\n\t\t\t\tthis.init.apply(this, arguments);\n\t\t}\n\n\t\t// Populate our constructed prototype object\n\t\tClass.prototype = prototype;\n\n\t\t// Enforce the constructor to be what we expect\n\t\tClass.prototype.constructor = Class;\n\n\t\t// And make this class extendable\n\t\tClass.extend = arguments.callee;\n\n\t\treturn Class;\n\n\t};\n\n\treturn this.Class;\n});",
    "\ndefine('section',[\"class\"], function(Class) {\n\n\tvar Section = Class.extend({\n\t\tid: null,\n\t\telement: null,\n\t\t_visible: null,\n\n\t\tinit: function() {\n\t\t\tthis.element = document.getElementById(this.id);\n\t\t\tthis._visible = false;\n\t\t},\n\n\t\tshow: null,\n\t\thide: null,\n\n\t\tafterShow: function() {\n\t\t\tthis.element.style.display = \"block\";\n\t\t\tthis._visible = true;\n\t\t},\n\n\t\tafterHide: function() {\n\t\t\tthis.element.style.display = \"\";\n\t\t\tthis._visible = false;\n\t\t}\n\n\t});\n\n\treturn Section;\n});",
    "\ndefine('tapHandler',[], function() {\n  function TapHandler(element, options) {\n    this.init(element, options);\n  }\n\n  TapHandler.prototype = {\n    _element: null,\n    _options: null,\n\n    _distCutoff: 20,\n    _timeCutoff: 500,\n\n    // touch or mouse\n    _startType: null,\n    _startTouchId: null,\n    _startTime: null,\n    _startX: null,\n    _startY: null,\n\n    _startScale: null,\n\n    _lastX: null,\n    _lastY: null,\n\n    _lastScale: null,\n\n    // Object with x and why of where the element is on the page\n    _offset: null,\n\n    _inTouch: false,\n    _inGesture: false,\n\n    _ignoreGestures: false,\n\n    init: function(element, options) {\n      this._element = element;\n      this._options = options;\n\n      // Replace with binded events\n      this._move = this._move.bind(this);\n      this._end = this._end.bind(this);\n      this._gestureChange = this._gestureChange.bind(this);\n      this._gestureEnd = this._gestureEnd.bind(this);\n\n      this._offset = {\n        x: element.offsetLeft,\n        y: element.offsetTop\n      };\n\n      this._element.addEventListener(\"mousedown\", this._start.bind(this));\n      this._element.addEventListener(\"touchstart\", this._start.bind(this));\n      this._element.addEventListener(\"gesturestart\", this._gestureStart.bind(this));\n    },\n\n    ignoreGestures: function(value) {\n      this._ignoreGestures = value;\n    },\n\n\n    _start: function(e) {\n      if (e.touches) {\n        // start touch is the last touch\n        this._startTouchId = e.touches[e.touches.length - 1].identifier;\n      }\n\n      this._processEvent(e);\n\n      // Ignore these if we are currently gesturing\n      if (this._inGesture) {\n        return;\n      }\n\n      this._startType = \"mouse\";\n      if (e.touches) {\n        this._startType = \"touch\";\n      }\n\n      this._inTouch = true;\n\n\n      this._startTime = e.timeStamp;\n\n      this._startX = this._lastX = e.x;\n      this._startY = this._lastY = e.y;\n\n      if (this._options.start) {\n        this._options.start(e);\n      }\n\n      if (this._startType == \"touch\") {\n        document.addEventListener(\"touchmove\", this._move);\n        document.addEventListener(\"touchend\", this._end);\n      } else if (this._startType == \"mouse\") {\n        document.addEventListener(\"mousemove\", this._move);\n        document.addEventListener(\"mouseup\", this._end);\n      }\n    },\n\n    _move: function(e) {\n      this._processEvent(e);\n\n      this._lastX = e.x;\n      this._lastY = e.y;\n\n      if (this._options.move) {\n        this._options.move(e);\n      }\n    },\n\n    _end: function(e) {\n      /*\n        if e isn't set, end the handlers, call tap if it is within limits, call end\n      */\n\n      if (!e) {\n        this._endTouchHandlers();\n        if (this._options.end) {\n          this._options.end();\n        }\n\n        return;\n      }\n\n      e.wasTap = false;\n\n      // The event still has our start touch, it hasn't ended\n      if (e.touches && this._indexOfTouch(e, this._startTouchId) !== -1) {\n        return;\n      }\n\n      this._endTouchHandlers();\n      this._processEvent(e);\n\n      var dist = Math.sqrt(((e.x - this._startX) * (e.x - this._startX)) + ((e.y - this._startY) * (e.y - this._startY)));\n\n      if (dist < this._distCutoff && (e.timeStamp - this._startTime < this._timeCutoff)) {\n        e.wasTap = true;\n        if (this._options.tap) {\n          this._options.tap(e);\n        }\n      }\n\n      // It wasn't a tap, just an up\n      if (this._options.end) {\n        this._options.end(e);\n      }\n\n      this._inTouch = false;\n\n      // Keep mouse events from being called\n      if (e) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n    },\n\n    _gestureStart: function(e) {\n      if (this._ignoreGestures) {\n        return;\n      }\n\n      this._inGesture = true;\n\n      // We need to end the touch\n      this._end();\n\n\n      this._processEvent(e);\n      this._processGesture(e);\n\n      this._startTime = e.timeStamp;\n\n      this._startX = this._lastX = e.x;\n      this._startY = this._lastY = e.y;\n\n      this._startScale = this._lastScale = e.scale;\n\n      if (this._options.gestureStart) {\n        this._options.gestureStart(e);\n      }\n\n      document.addEventListener(\"gesturechange\", this._gestureChange);\n      document.addEventListener(\"gestureend\", this._gestureEnd);\n    },\n\n    _gestureChange: function(e) {\n      this._processEvent(e);\n      this._processGesture(e);\n\n      this._lastX = e.x;\n      this._lastY = e.y;\n      this._lastScale = e.scale;\n\n      this._lastScale = e.scale;\n\n      if (this._options.gesture) {\n        this._options.gesture(e);\n      }\n    },\n\n    _gestureEnd: function(e) {\n      this._processEvent(e);\n      this._processGesture(e);\n\n      if (this._options.gestureEnd) {\n        this._options.gestureEnd(e);\n      }\n\n      document.removeEventListener(\"gesturechange\", this._gestureChange);\n      document.removeEventListener(\"gestureend\", this._gestureEnd);\n\n      this._inGesture = false;\n    },\n\n    // Unregister the regular touch handlers, used for when gestures start\n    _endTouchHandlers: function() {\n      if (this._startType == \"touch\") {\n        document.removeEventListener(\"touchmove\", this._move);\n        document.removeEventListener(\"touchend\", this._end);\n      } else if (this._startType == \"mouse\") {\n        document.removeEventListener(\"mousemove\", this._move);\n        document.removeEventListener(\"mouseup\", this._end);\n      }\n    },\n\n    // Given an e, add things like x and y regardless of touch or mouse\n    _processEvent: function(e) {\n      e.isTouch = e.touches ? true : false;\n\n      var index = -1;\n      // It's a touch\n      if (e.touches && e.touches.length > 0 && (index = this._indexOfTouch(e, this._startTouchId)) !== -1) {\n        // Use the last touch\n        e.x = e.touches[index].clientX;\n        e.y = e.touches[index].clientY;\n      } else if (e.clientX) {\n        // It's a click\n        e.x = e.clientX;\n        e.y = e.clientY;\n      } else if (e.pageX) {\n        // gesture events only get a layerx\n        e.x = e.pageX;\n        e.y = e.pageY;\n      } else {\n        // It's probably an end, there is no coords\n        e.x = this._lastX;\n        e.y = this._lastY;\n      }\n\n      e.distFromLeft = e.x - this._offset.x;\n      e.distFromTop = e.y - this._offset.y;\n\n      e.xFromLast = e.x - this._lastX;\n      e.yFromLast = e.y - this._lastY;\n    },\n\n    _processGesture: function(e) {\n      e.scaleFromLast = e.scale - this._lastScale;\n    },\n\n    _indexOfTouch: function(e, identifier) {\n      var index = -1;\n      if (e.touches && identifier) {\n        for (var i = 0; i < e.touches.length; i++) {\n          if (e.touches[i].identifier == identifier) {\n            index = i;\n            break;\n          }\n        }\n      }\n\n      return index;\n    }\n\n\n  };\n\n  return TapHandler;\n});",
    "\ndefine('gauth',[\"class\", \"event\"], function(Class, Event) {\n  var GAuth = Class.extend({\n    _clientId: '450627732299-2d7jlo96ious5jmdmsd9t7hpclstf7ub.apps.googleusercontent.com',\n    _user: null,\n\n    _startCallback: null,\n\n    INSTALL_SCOPE: 'https://www.googleapis.com/auth/drive.install',\n    FILE_SCOPE: 'https://www.googleapis.com/auth/drive.file',\n    OPENID_SCOPE: 'openid',\n\n    init: function() {},\n\n    start: function(callback) {\n      this._startCallback = callback;\n\n      gapi.load('auth:client,drive-realtime,drive-share', (function() {\n        this.authorize();\n      }).bind(this));\n    },\n\n    authorize: function() {\n      // Try with no popups first.\n      gapi.auth.authorize({\n        client_id: this._clientId,\n        scope: [\n          this.INSTALL_SCOPE,\n          this.FILE_SCOPE,\n          this.OPENID_SCOPE\n        ],\n        immediate: true\n      }, this._handleAuthResult.bind(this));\n    },\n\n    _handleAuthResult: function(token) {\n      if (token && !token.error) {\n        // logged in\n        Event.trigger(\"login\", token);\n        this._fetchUser();\n\n        if (this._startCallback) {\n          this._startCallback();\n        }\n\n        // Refresh the token 10 minutes before it expires\n        var expireMS = ((parseInt(token.expires_in) - 600) * 1000);\n\n        setTimeout((function() {\n          console.log(\"Refreshing GAuth token\");\n          this.authorize();\n        }).bind(this), expireMS);\n\n      } else {\n        Event.trigger(\"logout\");\n      }\n    },\n\n    authorizeWithPopup: function() {\n      gapi.auth.authorize({\n        client_id: this._clientId,\n        scope: [\n          this.INSTALL_SCOPE,\n          this.FILE_SCOPE,\n          this.OPENID_SCOPE\n        ],\n        immediate: false\n      }, this._handleAuthResult.bind(this));\n    },\n\n    _fetchUser: function() {\n      gapi.client.load('oauth2', 'v2', (function() {\n        gapi.client.oauth2.userinfo.get().execute((function(resp) {\n          if (resp.id) {\n            this._user = resp;\n          }\n        }).bind(this));\n      }).bind(this));\n    }\n  });\n\n  return new GAuth();\n});",
    "\ndefine('sections/login',[\"event\", \"section\", \"tapHandler\", \"gauth\"], function(Event, Section, TapHandler, GAuth) {\n\n  var Login = Section.extend({\n    id: \"login\",\n\n    init: function() {\n      this._super();\n      \n      var button = document.getElementById(\"loginbutton\");\n      new TapHandler(button, {tap: this._loginClicked.bind(this) });\n    },\n\n    _loginClicked: function() {\n      GAuth.authorizeWithPopup();\n    },\n  });\n\n  return Login;\n\n});",
    "\ndefine('platform',[\"class\"], function(Class) {\n  var Platform = Class.extend({\n    // shortcut to body\n    _b: null,\n\n    standalone: null,\n\n    transition: null,\n    transitionEnd: null,\n    animation: null,\n    transform: null,\n    transformOrigin: null,\n    mouseWheel: null,\n\n    init: function() {\n      this._b = document.body;\n\n      this.standalone = !! window.navigator.standalone;\n\n      this.transition = this.addPrefix('transition');\n      this.transitionEnd = this.addPrefix('transitionEnd');\n      this.animation = this.addPrefix('animation');\n      this.transform = this.addPrefix('transform');\n      this.transformOrigin = this.addPrefix('transformOrigin');\n\n      this.mouseWheel = typeof(window.onwheel) != \"undefined\" ? \"wheel\" : \"mousewheel\";\n\n      window.requestAnimationFrame = window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.msRequestAnimationFrame ||\n        window.oRequestAnimationFrame ||\n        function(callback) {\n          window.setTimeout(callback, 1000 / 60);\n      };\n\n      window.indexedDB = window.indexedDB ||\n        window.webkitIndexedDB ||\n        window.mozIndexedDB || \n        window.msIndexedDB ||\n        window.oIndexedDB;\n    },\n\n    addPrefix: function(p) {\n      var prefix = '';\n      var v = ['ms', 'webkit', 'mox', 'o'];\n      var s = this._b.style;\n\n      if (typeof s[p] == 'string') {\n        prefix = '';\n      } else {\n        for (var i = 0; i < v.length; i++) {\n          if (typeof s['-' + v[i] + '-' + p] == 'string') {\n            prefix = v[i];\n            break;\n          }\n        }\n      }\n\n      var styleString = (prefix.length > 0) ? p.charAt(0).toUpperCase() + p.slice(1) : p;\n\n      if (prefix) {\n        return prefix + styleString;\n      } else {\n        return styleString;\n      }\n    }\n  });\n\n  var platform = new Platform();\n  return platform;\n});",
    "\ndefine('sequentialHelper',[\"event\"], function(Event) {\n\n  function SequentialHelper() {\n    this.init();\n  }\n\n  SequentialHelper.prototype = {\n\n    _runningActions: null,\n    _openFiles: null,\n\n    init: function() {\n      // This will have an array for each file\n      this._runningActions = {};\n      this._openFiles = 0;\n\n      Event.addListener(\"fileIdChanged\", this._fileIdChanged.bind(this));\n    },\n\n    startLockedAction: function(fileId, ignoreGlobal) {\n      if (!this._runningActions[fileId]) {\n        this._runningActions[fileId] = [];\n        this._openFiles++;\n      }\n\n      var obj = {\n        promise: null,\n        resolve: null,\n        reject: null\n      }\n\n      var promise = new Promise(function(resolve, reject) {\n        obj.resolve = resolve;\n        obj.reject = reject;\n      });\n\n      obj.promise = promise;\n\n      // If we are global and the first\n      // or there is no global and we are the first\n      if ((fileId == \"global\" || !this._runningActions[\"global\"] || ignoreGlobal) && this._runningActions[fileId].length == 0) {\n        obj.resolve();\n      }\n\n      this._runningActions[fileId].push(obj);\n\n      return obj.promise;\n    },\n\n    endLockedAction: function(fileId) {\n      // Remove the first promise\n      this._runningActions[fileId].shift();\n\n      // If we have no more promises, delete the file array\n      if (this._runningActions[fileId].length == 0) {\n        delete this._runningActions[fileId];\n        this._openFiles--;\n\n        // If there is only one file left open, and it's a global, start the global action\n        if (this._openFiles == 1 && this._runningActions[\"global\"]) {\n          this._runningActions[\"global\"][0].resolve();\n        }\n\n        return;\n      }\n\n      // Resolve the next one\n      this._runningActions[fileId][0].resolve();\n    },\n\n    startGlobalAction: function() {\n      return this.startLockedAction(\"global\");\n    },\n\n    endGlobalAction: function() {\n      this.endLockedAction(\"global\");\n\n      // This was the last global action, start all of the open files\n      for (var file in this._runningActions) {\n        this._runningActions[file][0].resolve();\n      }\n    },\n\n    hasActions: function() {\n      return this._openFiles != 0;\n    },\n\n    _fileIdChanged: function(e) {\n      if (this._runningActions[e.oldId]) {\n        this._runningActions[e.newId] = this._runningActions[e.oldId];\n        delete this._runningActions[e.oldId];\n      }\n    },\n  }\n\n  return new SequentialHelper();\n\n});",
    "\ndefine('bezierCurve',[], function() {\n\n  function BezierCurve() {\n    this.init();\n  }\n\n  BezierCurve.prototype = {\n    _rhs: null,\n    _controlPoints: null,\n    _tmp: null,\n    _length: null,\n\n    init: function() {\n      this._length = 0;\n\n      this._rhs = [\n        [],\n        []\n      ];\n      this._controlPoints = [];\n      this._tmp = [];\n\n      // pre-allocate\n      for (var i = 0; i < 2000; i++) {\n        this._tmp[i] = 1.0;\n        this._rhs[0][i] = 1.0;\n        this._rhs[1][i] = 1.0;\n      }\n    },\n\n    getCurveControlPoints: function(knots) {      \n      var n = knots.length - 1;\n      this._length = n;\n      this._controlPoints.length = n;\n\n      if (n < 1) {\n        console.error(\"Must have at least two knots\");\n        return;\n      }\n\n      if (n == 1) {\n        // Special case: should be a line\n        var firstControlPoint = [\n          (2 * knots[0][0] + knots[1][0]) / 3, (2 * knots[0][1] + knots[1][1]) / 3\n        ];\n\n        var secondControlPoint = [\n          2 * firstControlPoint[0] - knots[0][0],\n          2 * firstControlPoint[1] - knots[0][1]\n        ];\n\n        return [[\n          firstControlPoint,\n          secondControlPoint\n        ]];\n      }\n\n      // Calculate first Bezier control points\n      // Right hand side vector\n\n      // Set right hand side X and Y values\n      this._rhs[0][0] = knots[0][0] + 2 * knots[1][0];\n      this._rhs[1][0] = knots[0][1] + 2 * knots[1][1];\n\n      for (var i = 1; i < n - 1; ++i) {\n        this._rhs[0][i] = 4 * knots[i][0] + 2 * knots[i + 1][0];\n        this._rhs[1][i] = 4 * knots[i][1] + 2 * knots[i + 1][1];\n      }\n\n      this._rhs[0][n - 1] = (8 * knots[n - 1][0] + knots[n][0]) / 2;\n      this._rhs[1][n - 1] = (8 * knots[n - 1][1] + knots[n][1]) / 2;\n\n      // Get first control points x-values\n      this.getFirstControlPoints(this._rhs);\n\n      for (var i = 0; i < n; ++i) {\n        if (typeof(this._controlPoints[i]) == \"undefined\") {\n          this._controlPoints[i] = [\n            new Array(2),\n            new Array(2),\n          ];\n        }\n\n        // First control point\n        this._controlPoints[i][0][0] = this._rhs[0][i];\n        this._controlPoints[i][0][1] = this._rhs[1][i];\n\n        // Second control point\n        if (i < n - 1) {\n          this._controlPoints[i][1][0] = 2 * knots[i + 1][0] - this._rhs[0][i + 1];\n          this._controlPoints[i][1][1] = 2 * knots[i + 1][1] - this._rhs[1][i + 1];\n        } else {\n          this._controlPoints[i][1][0] = (knots[n][0] + this._rhs[0][n - 1]) / 2;\n          this._controlPoints[i][1][1] = (knots[n][1] + this._rhs[1][n - 1]) / 2;\n        }\n      }\n\n      return this._controlPoints;\n    },\n\n    getFirstControlPoints: function() {\n      var n = this._length;\n      var b = 2.0;\n\n      this._rhs[0][0] /= b;\n      this._rhs[1][0] /= b;\n\n      for (var i = 1; i < n; i++) { // Decomposition and forward substitution\n        this._tmp[i] = 1 / b;\n\n        if (i < n - 1) {\n          b = 4 - this._tmp[i];\n        } else {\n          b = 3.5 - this._tmp[i];\n        }\n\n        this._rhs[0][i] -= this._rhs[0][i - 1];\n        this._rhs[0][i] /= b;\n\n        this._rhs[1][i] -= this._rhs[1][i - 1];\n        this._rhs[1][i] /= b;\n      }\n\n      for (var i = n - 1; i >= 0; i--) {\n        this._rhs[0][i - 1] -= this._tmp[i] * this._rhs[0][i];\n        this._rhs[1][i - 1] -= this._tmp[i] * this._rhs[1][i];\n      }\n    },\n  }\n\n  return new BezierCurve();\n});",
    "\ndefine('components/drawCanvas',[\"class\", \"helpers\", \"bezierCurve\"], function(Class, Helpers, BezierCurve) {\n  var DrawCanvas = Class.extend({\n    _canvas: null,\n    _ctx: null,\n    _settings: null,\n\n    // Holds at most one action\n    _tempCanvas: null,\n    _tempCtx: null,\n\n    _useCurves: null,\n\n    init: function(canvas, settings) {\n      this._canvas = canvas;\n      this._ctx = canvas.getContext(\"2d\");\n      this._settings = settings;\n\n      this._useCurves = true;\n\n      this._backCanvas = document.createElement(\"canvas\");\n      this._backCtx = this._backCanvas.getContext(\"2d\");\n      //this._backCtx.lineJoin = \"round\";\n      //this._backCtx.lineCap = \"round\";\n\n      this._tempCanvas = document.createElement(\"canvas\");\n      this._tempCtx = this._tempCanvas.getContext(\"2d\");\n      //this._tempCtx.lineJoin = \"round\";\n      //this._tempCtx.lineCap = \"round\";\n    },\n\n    useCurves: function(value) {\n      this._useCurves = value;\n    },\n\n    // Creates a back canvas and draws all the actions to it and renders it on the main canvas\n    doAll: function(actions) {\n      this._backCanvas.width = this._canvas.width;\n      this._backCanvas.height = this._canvas.height;\n\n      this._clearCanvas(this._backCanvas, this._backCtx);\n\n      // Also clear the temp canvas\n      this._clearCanvas(this._tempCanvas, this._tempCtx);\n\n      for (var i = 0; i < actions.length; i++) {\n        var action = actions[i];\n\n        this._doAction(this._backCtx, action);\n      }\n    },\n\n    // The action is done to a temporary canvas\n    doTemporaryAction: function(action) {\n      this._tempCanvas.width = this._canvas.width;\n      this._tempCanvas.height = this._canvas.height;\n\n      this._clearCanvas(this._tempCanvas, this._tempCtx);\n\n      this._doAction(this._tempCtx, action);\n    },\n\n    addAction: function(action) {\n      this._doAction(this._backCtx, action);\n\n      // Clears the temp canvas when you add something to the back\n      this._clearCanvas(this._tempCanvas, this._tempCtx);\n    },\n\n    // Clears the main screen\n    clear: function() {\n      this._clearCanvas(this._canvas, this._ctx);\n    },\n\n    _clearCanvas: function(canvas, ctx) {\n      ctx.setTransform(this._settings.scale, 0, 0, this._settings.scale, this._settings.offsetX, this._settings.offsetY);\n\n      var topLeft = Helpers.screenToWorld(this._settings, 0, 0);\n      var bottomRight = Helpers.screenToWorld(this._settings, canvas.width, canvas.height);\n\n      ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n    },\n\n    render: function() {\n      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n      this._ctx.drawImage(this._backCanvas, 0, 0, this._backCanvas.width, this._backCanvas.height);\n      this._ctx.drawImage(this._tempCanvas, 0, 0, this._tempCanvas.width, this._tempCanvas.height);\n    },\n\n    _doAction: function(ctx, action) {\n      if (action.type == \"stroke\") {\n\n        this._drawStroke(ctx, action.value);\n      }\n    },\n\n    updateSettings: function(settings) {\n      this._settings = settings;\n    },\n\n    _drawStroke: function(ctx, stroke) {\n      if (stroke.points.length < 2) {\n        return;\n      }\n\n      var controlPoints = stroke.controlPoints;\n      var points = stroke.points;\n\n      var point = points[0];\n\n      var lineWidth = stroke.width;\n      if (stroke.lockWidth) { // the width stays the same regardless of zoom\n        lineWidth /= this._settings.scale;\n      }\n\n      ctx.lineJoin = \"round\";\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = stroke.color;\n      ctx.lineCap = \"round\";\n\n      ctx.beginPath();\n      ctx.moveTo(point.x, point.y);\n\n      for (var i = 1; i < points.length; i++) {\n        point = points[i];\n\n        // Curve the first one, even if we are using lines\n        if (this._useCurves || i == 1) {\n          var cp1 = controlPoints[i - 1][0];\n          var cp2 = controlPoints[i - 1][1];\n          ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], point[0], point[1]);\n        }\n        else\n        {\n          ctx.lineTo(point[0], point[1]);\n        }\n      }\n\n      ctx.stroke();\n    },\n  });\n\n  return DrawCanvas;\n\n  /*\n  drawAll(actions) // Draw all actions to a back canvas\n  drawTemporary(action) // draw action on front canvas\n  addAction(action) // add action to back canvas\n  */\n\n});",
    "\ndefine('components/manipulateCanvas',[\"components/drawCanvas\", \"helpers\"], function(DrawCanvas, Helpers) {\n\n  var ManipulateCanvas = DrawCanvas.extend({\n    zoom: function(x, y, dScale) {\n      // Can't zoom that far!\n      if (this._settings.scale + dScale < .001 || this._settings.scale + dScale > 20000) {\n        return false;\n      }\n\n      var world = Helpers.screenToWorld(this._settings, x, y);\n      this._settings.scale += dScale;\n      var scr = Helpers.worldToScreen(this._settings, world.x, world.y);\n\n      var diffScr = {\n        x: x - scr.x,\n        y: y - scr.y\n      };\n\n      this._settings.offsetX += diffScr.x; // * this._settings.scale;\n      this._settings.offsetY += diffScr.y; // * this._settings.scale;\n\n      return true;\n    },\n\n    pan: function(dx, dy) {\n      this._settings.offsetX += dx;\n      this._settings.offsetY += dy;\n\n      return true;\n    },\n\n    panTo: function(x, y) {\n      this._settings.offsetX = x;\n      this._settings.offsetY = y;\n    }\n  });\n\n  return ManipulateCanvas;\n});",
    "\ndefine('components/thumbnail',[\"class\", \"helpers\", \"components/manipulateCanvas\"], function(Class, Helpers, ManipulateCanvas) {\n\n  var Thumbnail = Class.extend({\n    _canvas: null,\n\n    init: function() {\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = 260;\n      canvas.height = 200;\n\n      this._canvas = canvas;\n    },\n\n    render: function(settings, actions) {\n\n      var manipulateCanvas = new ManipulateCanvas(this._canvas, settings);\n\n      // Find out what world point is in the middle\n      var centerScreen = {\n        x: window.innerWidth / 2,\n        y: window.innerHeight / 2\n      };\n      var centerWorld = Helpers.screenToWorld(settings, centerScreen.x, centerScreen.y);\n\n      var scale = Math.min(this._canvas.width / window.innerWidth, this._canvas.height / window.innerHeight);\n      var zoomDiff = (settings.scale * scale) - settings.scale;\n      manipulateCanvas.zoom(0, 0, zoomDiff);\n\n      // Now that we have zoomed, find the middle of the canvas\n      var centerScreenAfter = {\n        x: this._canvas.width / 2,\n        y: this._canvas.height / 2\n      };\n\n      // And where the middle point was from before\n      var centerScreenPointAfter = Helpers.worldToScreen(settings, centerWorld.x, centerWorld.y);\n\n      // pan the difference\n      var diffScreen = {\n        x: centerScreenAfter.x - centerScreenPointAfter.x,\n        y: centerScreenAfter.y - centerScreenPointAfter.y\n      };\n      manipulateCanvas.pan(diffScreen.x, diffScreen.y);\n\n      manipulateCanvas.doAll(actions);\n      manipulateCanvas.render();\n\n      return this._canvas.toDataURL(\"image/png\");\n    }\n  });\n\n  return new Thumbnail();\n});",
    "\ndefine('dataLayer/file',[\"class\", \"event\", \"helpers\", \"sequentialHelper\", \"bezierCurve\", \"components/thumbnail\"], function(Class, Event, Helpers, SequentialHelper, BezierCurve, Thumbnail) {\n  var File = Class.extend({\n    fileInfoPromise: null,\n\n    _cachedActions: null,\n\n    _backing: null,\n    _driveBacking: null,\n\n    _addedCallback: null,\n    _removedCallback: null,\n\n    _syncPromise: null,\n\n    init: function(backing) {\n      // Create our backing instance\n      this._backing = backing;\n    },\n\n    hasLocalActions: function(fileId) {\n      return this._backing.load(fileId)\n        .then((function(fileInfo) {\n          return this._backing.getActions()\n        }).bind(this))\n        .then((function(actions) {\n          return this._backing.close()\n            .then(function() {\n              return actions.local.length !== 0;\n            })\n        }).bind(this));\n    },\n\n    remoteActionsMatch: function(fileId, driveBacking) {\n      return Promise.all([this._backing.load(fileId), driveBacking.load(fileId)])\n        .then((function() {\n          var localActionsPromise = this._backing.getActions();\n          var remoteActionsPromise = driveBacking.getActions();\n\n          return Promise.all([localActionsPromise, remoteActionsPromise])\n            .then(function(results) {\n              var localActions = results[0];\n              var remoteActions = results[1];\n\n              // If the lengths don't match, they aren't equal\n              if (localActions.remote.length != remoteActions) {\n                return false;\n              }\n\n              for (var i = 0; i < localActions.remote.length; i++) {\n                if (localActions.remote[i].id != remoteActions[i]) {\n                  return false;\n                }\n              }\n\n              return true;\n            });\n        }).bind(this));\n    },\n\n    load: function(fileId) {\n      var fileInfoPromise = this._backing.load(fileId);\n\n      return fileInfoPromise\n        .then((function(fileInfo) {\n          return this._backing.getActions()\n        }).bind(this))\n        .then((function(actions) {\n          var actionsObj = {\n            remoteActions: [],\n            localActions: [],\n            redoStack: []\n          };\n\n          actionsObj.remoteActions = actions.remote;\n          actionsObj.localActions = actions.local;\n\n          this._cachedActions = actionsObj;\n\n          this.fileInfoPromise = fileInfoPromise;\n          return this;\n        }).bind(this));\n    },\n\n    create: function(file) {\n      return this._backing.create(file)\n        .then((function() {\n          return this.load(file.id);\n        }).bind(this))\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n      });\n    },\n\n    rename: function(newName) {\n\n      return this.fileInfoPromise.then((function(fileInfo) {\n        var newTime = Date.now();\n\n        fileInfo.name = newName;\n        fileInfo.localModifiedTime = newTime;\n        Event.trigger(\"fileRenamed\", fileInfo);\n        Event.trigger(\"fileModified\", fileInfo);\n\n        this.fileInfoPromise = Promise.resolve(fileInfo);\n\n\n\n        var promises = [];\n\n        promises.push(this.fileInfoPromise.then((function() {\n          return this._backing.updateLocalModifiedTime(newTime);\n        }).bind(this)));\n\n        promises.push(this._backing.rename(newName));\n\n        if (this._driveBacking) {\n          promises.push(SequentialHelper.startLockedAction(fileInfo.id)\n            .then((function() {\n              return this._driveBacking.rename(newName);\n            }).bind(this))\n            .catch(function(error) {\n              console.error(error);\n            })\n            .then((function() {\n              SequentialHelper.endLockedAction(fileInfo.id);\n            }).bind(this)))\n\n        }\n\n        return Promise.all(promises)\n      }).bind(this));\n    },\n\n    startDrive: function(driveBacking) {\n      // process things on drive for updates\n      driveBacking.listen(this._remoteActionsAdded.bind(this), this._remoteActionsRemoved.bind(this));\n\n\n      return this.fileInfoPromise\n        .then((function(fileInfo) {\n          console.log(\"Starting drive for file\", fileInfo.id);\n          return this.sync(driveBacking, true)\n        }).bind(this))\n        .then((function() {\n          this._driveBacking = driveBacking;\n        }).bind(this))\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n      })\n    },\n\n    sync: function(drive, syncActions) {\n      var driveBacking = this._driveBacking || drive;\n      if (!driveBacking) {\n        debugger;\n      }\n\n      // if this fileId exists on drive, great, it's a match\n      // if it doesn't, then it either has never been uploaded, or was deleted on the server\n      // regardless, it's open, so we should upload it to drive\n      this._syncPromise = Promise.all([this.fileInfoPromise, driveBacking._parent.getFiles()])\n        .then((function(results) {\n          var fileInfo = results[0];\n          var driveFiles = results[1];\n\n          console.log(\"Starting file sync\", fileInfo.id);\n\n          var promises = [];\n\n          var found = false;\n          for (var i in driveFiles) {\n            if (driveFiles[i].id == fileInfo.id) {\n              found = i;\n              break;\n            }\n          }\n\n\n          if (found !== false) {\n            console.log(\"Found file\", fileInfo.id, \"on drive\");\n            // the file was found on drive\n            // load it and sync actions\n            // sync actions\n\n            if (driveFiles[i].title != fileInfo.name) {\n\n              // It is newer on drive, rename locally\n              if (driveFiles[i].modifiedDate != fileInfo.driveModifiedTime) {\n                promises.push(this._driveBacking.rename(fileInfo.name));\n              } else {\n                // Update it locally\n                promises.push(this.rename(driveFiles[i].title));\n              }\n            }\n\n            if (syncActions) {\n              promises.push(this._syncRemoteActionsFromDrive(driveBacking));\n            }\n\n          } else {\n            console.log(\"File not found on drive\", fileInfo.id);\n            // this file was not found\n            // so we will create a new file on drive, \n            // and then copy everything over to it\n            var oldId = fileInfo.id;\n\n            promises.push(\n              SequentialHelper.startLockedAction(oldId, true)\n              .then(function() {\n                return driveBacking.create(fileInfo)\n              })\n              .then((function(newFile) {\n                // Google saved a file, redo the id of the file locally to match drive\n                return this._backing.replaceFileId(newFile.id)\n                  .then((function() {\n                    return this.load(newFile.id);\n                  }).bind(this))\n                  .then((function() {\n\n                    return this._moveSettings(oldId)\n                  }).bind(this))\n                  .then(function() {\n                    Event.trigger(\"fileIdChanged\", {\n                      oldId: oldId,\n                      newId: newFile.id\n                    });\n                  })\n                  .then((function() {\n                    return this._backing.getActions();\n                  }).bind(this))\n                  .then((function(localActions) {\n                    return this._sendAllActions(localActions.local, driveBacking)\n                  }).bind(this))\n                  .catch((function(error) {\n                    console.error(error);\n                  }).bind(this))\n                  .then(function() {\n                    SequentialHelper.endLockedAction(newFile.id);\n                  });\n\n              }).bind(this))\n            );\n          }\n\n          return Promise.all(promises)\n        }).bind(this))\n        .then((function() {\n          this._syncPromise = null;\n        }).bind(this))\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n      })\n        .then((function() {\n          return this.fileInfoPromise;\n        }).bind(this))\n        .then(function(fileInfo) {\n          console.log(\"Completed file sync\", fileInfo.id);\n        });\n\n      return this._syncPromise;\n    },\n\n    listen: function(addedCallback, removedCallback) {\n      this._addedCallback = addedCallback;\n      this._removedCallback = removedCallback;\n    },\n\n    stopListening: function() {\n      this._addedCallback = null;\n      this._removedCallback = null;\n    },\n\n    getActions: function() {\n      return this._cachedActions.remoteActions.concat(this._cachedActions.localActions);\n    },\n\n    localSettings: function(settings) {\n      return this.fileInfoPromise\n        .then((function(fileInfo) {\n\n          if (settings) {\n            localStorage[fileInfo.id] = JSON.stringify(settings);\n          }\n\n          if (!localStorage[fileInfo.id]) {\n            localStorage[fileInfo.id] = JSON.stringify({\n              offsetX: 0,\n              offsetY: 0,\n              scale: 1,\n              color: \"#000\",\n              tools: {\n                point: \"pencil\",\n                gesture: null,\n                scroll: \"pan\"\n              }\n            });\n          }\n\n          return JSON.parse(localStorage[fileInfo.id]);\n        }).bind(this));\n    },\n\n    _moveSettings: function(oldId) {\n      if (localStorage[oldId]) {\n        return this.fileInfoPromise\n          .then(function(fileInfo) {\n            localStorage[fileInfo.id] = localStorage[oldId];\n            delete localStorage[oldId];\n          });\n      }\n\n      return Promise.resolve();\n    },\n\n    undo: function() {\n      if (this._driveBacking) {\n        return this._driveBacking.undo();\n      }\n\n      if (this._cachedActions.localActions.length == 0) {\n        return Promise.resolve(false); // no actions to undo\n      } else {\n        var lastAction = this._cachedActions.localActions.pop();\n        this._cachedActions.redoStack.push(lastAction);\n\n        return this._backing.removeLocalAction(lastAction.id)\n          .then((function() {\n            return this.fileInfoPromise;\n          }).bind(this))\n          .then((function(fileInfo) {\n            fileInfo.localModifiedTime = Date.now();\n            this.fileInfoPromise = Promise.resolve(fileInfo);\n            Event.trigger(\"fileModified\", fileInfo);\n\n            return this._backing.updateLocalModifiedTime(fileInfo.localModifiedTime);\n          }).bind(this));\n      }\n    },\n\n    redo: function() {\n      if (this._driveBacking) {\n        return this._driveBacking.redo();\n      }\n\n      if (this._cachedActions.redoStack.length == 0) {\n        return Promise.resolve(false); // no actions to undo\n      } else {\n        var action = this._cachedActions.redoStack.pop();\n        return this._addAction(action);\n      }\n    },\n\n    addAction: function(action) {\n      this._cachedActions.redoStack.length = 0;\n      return this._addAction(action);\n    },\n\n    _addAction: function(action) {\n      this._cachedActions.localActions.push(action);\n\n      var promises = [];\n\n      promises.push(this.fileInfoPromise.then((function(fileInfo) {\n        fileInfo.localModifiedTime = Date.now();\n        this.fileInfoPromise = Promise.resolve(fileInfo);\n        Event.trigger(\"fileModified\", fileInfo);\n\n        return this._backing.updateLocalModifiedTime(fileInfo.localModifiedTime);\n      }).bind(this)));\n\n      promises.push(this._backing.addLocalAction(action));\n\n      if (this._driveBacking) {\n        var newAction = this._prepareForDrive(Helpers.clone(action));\n        promises.push(this._driveBacking.addAction(newAction));\n      }\n\n      return Promise.all(promises)\n        .then((function() {\n          return this.fileInfoPromise;\n        }).bind(this))\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n      });\n    },\n\n    delete: function() {\n      return this.close()\n        .then(this._backing.delete);\n    },\n\n    close: function() {\n      var prom = Promise.resolve();\n\n      // Only close after sync is done, if sync is running\n      if (this._syncPromise) {\n        prom = this._syncPromise;\n      }\n\n      // If we loaded a file\n      if (this.fileInfoPromise) {\n        return prom.then((function() {\n          this.fileInfoPromise.then((function(fileInfo) {\n            // Explicitly allow garbage collection\n            this._cachedActions.length = 0;\n\n            this.fileInfoPromise = Promise.reject(new Error(\"File has been closed\"));\n          }).bind(this));\n\n          var promises = [];\n\n          promises.push(this._backing.close());\n\n          if (this._driveBacking) {\n            this._driveBacking.stopListening();\n\n            promises.push(this._driveBacking.close());\n            this._driveBacking = null;\n          }\n\n          return Promise.all(promises);\n        }).bind(this))\n      } else {\n        return prom;\n      }\n\n    },\n\n    _syncRemoteActionsFromDrive: function(driveBacking) {\n\n      return this.fileInfoPromise.then((function(fileInfo) {\n\n        var driveActionsPromise = driveBacking.load(fileInfo.id)\n          .then((function() {\n            return driveBacking.getActions()\n          }).bind(this));\n\n\n        // TODO: THIS LINE SUCKS! the file is already closed, can't get the actions\n        var localActionsPromise = this._backing.getActions();\n\n        return Promise.all([fileInfo, driveActionsPromise, localActionsPromise]);\n      }).bind(this))\n        .then((function(results) {\n          var fileInfo = results[0]\n          var remoteActions = results[1];\n          var localActions = results[2];\n\n          var promises = [];\n\n\n          var shorter = remoteActions.length < localActions.remote.length ? remoteActions : localActions.remote;\n          var diverges = -1;\n\n          for (var j = 0; j < shorter.length; j++) {\n            if (remoteActions[j].id != localActions.remote[j].id) {\n              diverges = j;\n              break;\n            }\n          }\n\n          // Did we get new changes from drive that we should notify about\n          var sendUpdate = false;\n\n          // Only modify things if we need to\n          if (diverges !== -1 || remoteActions.length != localActions.remote.length) {\n            console.log(\"Differences between remote and local actions\", fileInfo.id);\n            sendUpdate = true;\n\n            if (diverges != -1) {\n              // get the remote actions after the diverge\n              var remoteActionsAfterDiverge = remoteActions.slice(diverges);\n\n              // we need to add indexes to these items\n              var items = this._indexify(remoteActionsAfterDiverge, diverges);\n              items = items.map(this._convertFromDrive);\n\n              // remove the actions in local after the diverge\n              promises.push(this._backing.removeRemoteActions(diverges, localActions.remote.length - diverges)\n                .then((function() {\n\n                  // insert the remote actions after diverge into local actions\n                  this._backing.addRemoteActions(diverges, items);\n                }).bind(this)));\n\n              // and fix our array\n              this._cachedActions.remoteActions.splice.apply(this._cachedActions.remoteActions, [diverges, this._cachedActions.remoteActions.length - diverges].concat(items));\n            } else if (shorter == remoteActions) {\n              // remove the actions after diverge from local\n              promises.push(this._backing.removeRemoteActions(remoteActions.length, localActions.remote.length - remoteActions.length));\n              this._cachedActions.remoteActions.splice(remoteActions.length, localActions.remote.length - remoteActions.length);\n            } else {\n              // shorter must be the local one\n              // add the remote actions after the local ones\n              var remoteActionsAfterLocal = remoteActions.slice(localActions.remote.length);\n\n              var items = this._indexify(remoteActionsAfterLocal, localActions.remote.length);\n              items = items.map(this._convertFromDrive);\n\n              promises.push(this._backing.addRemoteActions(localActions.remote.length, items));\n\n              this._cachedActions.remoteActions.splice.apply(this._cachedActions.remoteActions, [this._cachedActions.remoteActions.length, 0].concat(items));\n            }\n\n            if (!isEqual(this._cachedActions.remoteActions, remoteActions)) {\n              debugger;\n            }\n\n            function isEqual(arr1, arr2) {\n              if (arr1.length != arr2.length) {\n                return false;\n              }\n\n              for (var i = 0; i < arr1.length; i++) {\n                if (arr1[i].id != arr2[i].id) {\n                  return false;\n                }\n              }\n\n              return true;\n            }\n\n            // there was a difference, lets fix our cachedActions\n            //this._cachedActions.remoteActions = remoteActions;\n          }\n\n          promises.push(this._sendAllActions(localActions.local, driveBacking));\n\n          return Promise.all(promises)\n            .then((function() {\n              if (sendUpdate) {\n                return this.updateThumbnail();\n              }\n            }).bind(this));\n        }).bind(this));\n    },\n\n    _sendAllActions: function(actions, driveBacking) {\n      var promises = [];\n\n      for (var j = 0; j < actions.length; j++) {\n        var newAction = this._prepareForDrive(actions[j]);\n        promises.push(driveBacking.addAction(newAction));\n      }\n\n      return Promise.all(promises);\n    },\n\n    _remoteActionsAdded: function(data) {\n      if (!this.isConnected()) {\n        //debugger;\n      }\n\n      var promises = [];\n\n      if (data.isLocal) {\n        // go through each item to insert\n        for (var i = 0; i < data.values.length; i++) {\n          // delete them from local\n          for (var j = 0; j < this._cachedActions.localActions.length; j++) {\n            if (this._cachedActions.localActions[j].id == data.values[i].id) {\n              this._cachedActions.localActions.splice(j, 1);\n              break;\n            }\n          }\n\n          promises.push(this._backing.removeLocalAction(data.values[i].id));\n        }\n      }\n\n      // put the items into the remoteActions\n      this._cachedActions.remoteActions.splice.apply(this._cachedActions.remoteActions, [data.index, 0].concat(data.values));\n\n      var items = this._indexify(data.values, data.index);\n      items = items.map(this._convertFromDrive);\n\n      // insert them into storage\n      promises.push(this._backing.addRemoteActions(data.index, items));\n\n      if (this._addedCallback) {\n        this._addedCallback({\n          isLocal: data.isLocal,\n          items: items\n        });\n      }\n\n      promises.push(this.fileInfoPromise.then((function(fileInfo) {\n        if (data.isLocal) {\n          Event.trigger(\"fileModified\", fileInfo);\n        } else {\n          Event.trigger(\"fileModifiedRemotely\", fileInfo);\n        }\n\n        fileInfo.localModifiedTime = Date.now();\n        this.fileInfoPromise = Promise.resolve(fileInfo);\n\n        return this._backing.updateLocalModifiedTime(fileInfo.localModifiedTime);\n      }).bind(this)));\n\n      return Promise.all(promises).\n      catch (function(error) {\n\n      })\n        .then((function() {\n          return this.updateThumbnail();\n        }).bind(this));\n    },\n\n    _remoteActionsRemoved: function(data) {\n      if (!this.isConnected()) {\n        // We have since closed\n        //debugger;\n      }\n\n      // remove it from the remoteActions\n      this._cachedActions.remoteActions.splice(data.index, data.values.length);\n\n      var promises = [];\n      promises.push(this._backing.removeRemoteActions(data.index, data.values.length));\n\n      if (this._removedCallback) {\n        promises.push(this._removedCallback());\n      }\n\n      promises.push(this.fileInfoPromise.then(function(fileInfo) {\n        fileInfo.localModifiedTime = Date.now();\n        this.fileInfoPromise = Promise.resolve(fileInfo);\n        Event.trigger(\"fileModified\", fileInfo);\n\n        return this._backing.updateLocalModifiedTime(fileInfo.localModifiedTime);\n      }));\n\n      return Promise.all(promises).then((function() {\n        return this.updateThumbnail();\n      }).bind(this));\n    },\n\n    updateDriveModifiedTime: function(time) {\n      return this._backing.updateDriveModifiedTime(time);\n    },\n\n    updateThumbnail: function() {\n      return this.localSettings()\n        .then((function(settings) {\n          var dataURL = Thumbnail.render(settings, this.getActions());\n\n          return this.fileInfoPromise.then((function(fileInfo) {\n            fileInfo.thumbnail = dataURL;\n            Event.trigger(\"thumbnailUpdated\", fileInfo);\n            this.fileInfoPromise = Promise.resolve(fileInfo);\n\n            return this._backing.updateThumbnail(dataURL);\n          }).bind(this))\n        }).bind(this));\n    },\n\n    _indexify: function(actions, startIndex) {\n      var items = [];\n      // put indexes on the items\n      for (var i = 0; i < actions.length; i++) {\n        var item = Helpers.clone(actions[i]);\n        item.index = i + startIndex;\n        items.push(item);\n      }\n\n      return items;\n    },\n\n    _prepareForDrive: function(action) {\n      var newAction = Helpers.clone(action);\n      newAction.value = Helpers.clone(action.value);\n      delete newAction.value.controlPoints;\n\n      return newAction;\n    },\n\n    _convertFromDrive: function(action) {\n      var controlPoints = BezierCurve.getCurveControlPoints(action.value.points);\n      action.value.controlPoints = Helpers.cloneArray(controlPoints);\n\n      if (action.value.controlPoints == undefined) {\n        debugger;\n      }\n\n      return action;\n    },\n\n    isConnected: function() {\n      return !!this._driveBacking;\n    }\n  });\n\n  return File;\n});",
    "\ndefine('db',[], function() {\n    'use strict';\n    var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB,\n        IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange,\n        transactionModes = {\n            readonly: 'readonly',\n            readwrite: 'readwrite'\n        };\n        \n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    if ( !indexedDB ) {\n        return;\n    }\n\n    var defaultMapper = function (value) {\n        return value;\n    };\n\n    var CallbackList = function () {\n        var state,\n            list = [];\n\n        var exec = function ( context , args ) {\n            if ( list ) {\n                args = args || [];\n                state = state || [ context , args ];\n\n                for ( var i = 0 , il = list.length ; i < il ; i++ ) {\n                    list[ i ].apply( state[ 0 ] , state[ 1 ] );\n                }\n\n                list = [];\n            }\n        };\n\n        this.add = function () {\n            for ( var i = 0 , il = arguments.length ; i < il ; i ++ ) {\n                list.push( arguments[ i ] );\n            }\n\n            if ( state ) {\n                exec();\n            }\n\n            return this;\n        };\n\n        this.execute = function () {\n            exec( this , arguments );\n            return this;\n        };\n    };\n\n    var Deferred = function ( func ) {\n        var state = 'progress',\n            actions = [\n                [ 'resolve' , 'done' , new CallbackList() , 'resolved' ],\n                [ 'reject' , 'fail' , new CallbackList() , 'rejected' ],\n                [ 'notify' , 'progress' , new CallbackList() ],\n            ],\n            deferred = {},\n            promise = {\n                state: function () {\n                    return state;\n                },\n                then: function ( /* doneHandler , failedHandler , progressHandler */ ) {\n                    var handlers = arguments;\n\n                    return Deferred(function ( newDefer ) {\n                        actions.forEach(function ( action , i ) {\n                            var handler = handlers[ i ];\n\n                            deferred[ action[ 1 ] ]( typeof handler === 'function' ?\n                                function () {\n                                    var returned = handler.apply( this , arguments );\n\n                                    if ( returned && typeof returned.promise === 'function' ) {\n                                        returned.promise()\n                                            .done( newDefer.resolve )\n                                            .fail( newDefer.reject )\n                                            .progress( newDefer.notify );\n                                    }\n                                } : newDefer[ action[ 0 ] ]\n                            );\n                        });\n                    }).promise();\n                },\n                promise: function ( obj ) {\n                    if ( obj ) {\n                        Object.keys( promise )\n                            .forEach(function ( key ) {\n                                obj[ key ] = promise[ key ];\n                            });\n\n                        return obj;\n                    }\n                    return promise;\n                }\n            };\n\n        actions.forEach(function ( action , i ) {\n            var list = action[ 2 ],\n                actionState = action[ 3 ];\n\n            promise[ action[ 1 ] ] = list.add;\n\n            if ( actionState ) {\n                list.add(function () {\n                    state = actionState;\n                });\n            }\n\n            deferred[ action[ 0 ] ] = list.execute;\n        });\n\n        promise.promise( deferred );\n\n        if ( func ) {\n            func.call( deferred , deferred );\n        }\n\n        return deferred;\n    };\n\n    var Server = function ( db , name ) {\n        var that = this,\n            closed = false;\n\n        this.add = function( table ) {\n            if ( closed ) {\n                throw new Error('Database has been closed');\n            }\n\n            var records = [];\n            for (var i = 0; i < arguments.length - 1; i++) {\n                records[i] = arguments[i + 1];\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n            \n            records.forEach( function ( record ) {\n                var req;\n                if ( record.item && record.key ) {\n                    var key = record.key;\n                    record = record.item;\n                    req = store.add( record , key );\n                } else {\n                    req = store.add( record );\n                }\n\n                req.onsuccess = function ( e ) {\n                    var target = e.target;\n                    var keyPath = target.source.keyPath;\n                    if ( keyPath === null ) {\n                        keyPath = '__id__';\n                    }\n                    Object.defineProperty( record , keyPath , {\n                        value: target.result,\n                        enumerable: true\n                    });\n                    deferred.notify();\n                };\n            } );\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                //deferred.reject( records , e );\n                e.records = records;\n                deferred.reject( e );\n            };\n            transaction.onabort = function ( e ) {\n                //deferred.reject( records , e );\n                e.records = records;\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.update = function( table ) {\n            if ( closed ) {\n                throw new Error('Database has been closed');\n            }\n\n            var records = [];\n            for ( var i = 0 ; i < arguments.length - 1 ; i++ ) {\n                records[ i ] = arguments[ i + 1 ];\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                keyPath = store.keyPath,\n                deferred = Deferred();\n\n            records.forEach( function ( record ) {\n                var req;\n                if ( record.item && record.key ) {\n                    var key = record.key;\n                    record = record.item;\n                    req = store.put( record , key );\n                } else {\n                    req = store.put( record );\n                }\n\n                req.onsuccess = function ( e ) {\n                    deferred.notify();\n                };\n            } );\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                //deferred.reject( records , e );\n                e.records = records;\n                deferred.reject( e );\n            };\n            transaction.onabort = function ( e ) {\n                //deferred.reject( records , e );\n                e.records = records;\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n        \n        this.remove = function ( table , key ) {\n            if ( closed ) {\n                throw new Error('Database has been closed');\n            }\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n            \n            var req = store.delete( key );\n            transaction.oncomplete = function ( ) {\n                deferred.resolve( key );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.clear = function ( table ) {\n            if ( closed ) {\n                throw new Error('Database has been closed');\n            }\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var req = store.clear();\n            transaction.oncomplete = function ( ) {\n                deferred.resolve( );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n        \n        this.close = function ( ) {\n            if ( closed ) {\n                throw new Error('Database has been closed');\n            }\n            db.close();\n            closed = true;\n            delete dbCache[ name ];\n        };\n\n        this.get = function ( table , id ) {\n            if ( closed ) {\n                throw new Error('Database has been closed');\n            }\n            var transaction = db.transaction( table ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var req = store.get( id );\n            req.onsuccess = function ( e ) {\n                deferred.resolve( e.target.result );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.query = function ( table , index ) {\n            if ( closed ) {\n                throw new Error('Database has been closed');\n            }\n            return new IndexQuery( table , db , index );\n        };\n\n        for ( var i = 0 , il = db.objectStoreNames.length ; i < il ; i++ ) {\n            (function ( storeName ) {\n                that[ storeName ] = { };\n                for ( var i in that ) {\n                    if ( !hasOwn.call( that , i ) || i === 'close' ) {\n                        continue;\n                    }\n                    that[ storeName ][ i ] = (function ( i ) {\n                        return function () {\n                            var args = [ storeName ].concat( [].slice.call( arguments , 0 ) );\n                            return that[ i ].apply( that , args );\n                        };\n                    })( i );\n                }\n            })( db.objectStoreNames[ i ] );\n        }\n    };\n\n    var IndexQuery = function ( table , db , indexName ) {\n        var that = this;\n        var modifyObj = false;\n        var removeObj = false;\n\n        var runQuery = function ( type, args , cursorType , direction, limitRange, filters , mapper ) {\n            var transaction = db.transaction( table, modifyObj || removeObj ? transactionModes.readwrite : transactionModes.readonly ),\n                store = transaction.objectStore( table ),\n                index = indexName ? store.index( indexName ) : store,\n                keyRange = type ? IDBKeyRange[ type ].apply( null, args ) : null,\n                results = [],\n                deferred = Deferred(),\n                indexArgs = [ keyRange ],\n                limitRange = limitRange ? limitRange : null,\n                filters = filters ? filters : [],\n                counter = 0;\n\n            if ( cursorType !== 'count' ) {\n                indexArgs.push( direction || 'next' );\n            };\n\n            // create a function that will set in the modifyObj properties into\n            // the passed record.\n            var modifyKeys = modifyObj ? Object.keys(modifyObj) : false;\n            var modifyRecord = function(record) {\n                for(var i = 0; i < modifyKeys.length; i++) {\n                    var key = modifyKeys[i];\n                    var val = modifyObj[key];\n                    if(val instanceof Function) val = val(record);\n                    record[key] = val;\n                }\n                return record;\n            };\n\n            var removeFn = (removeObj instanceof Function) ? removeObj : false;\n            var removeRecord = function(record) {\n                return removeFn ? removeFn(record) : false;\n            };\n\n            index[cursorType].apply( index , indexArgs ).onsuccess = function ( e ) {\n                var cursor = e.target.result;\n                if ( typeof cursor === typeof 0 ) {\n                    results = cursor;\n                } else if ( cursor ) {\n                  if ( limitRange !== null && limitRange[0] > counter) {\n                      counter = limitRange[0];\n                      cursor.advance(limitRange[0]);\n                    } else if ( limitRange !== null && counter >= (limitRange[0] + limitRange[1]) ) {\n                        //out of limit range... skip\n                    } else {\n                        var matchFilter = true;\n                        var result = 'value' in cursor ? cursor.value : cursor.key;\n\n                        filters.forEach( function ( filter ) {\n                            if ( !filter || !filter.length ) {\n                                //Invalid filter do nothing\n                            } else if ( filter.length === 2 ) {\n                                matchFilter = (result[filter[0]] === filter[1])\n                            } else {\n                                matchFilter = filter[0].apply(undefined,[result]);\n                            }\n                        });\n\n                        if (matchFilter) {\n                            counter++;\n                            results.push( mapper(result) );\n                            // if we're doing a modify, run it now\n                            if(modifyObj) {\n                                result = modifyRecord(result);\n                                cursor.update(result);\n                            }\n\n                            if (removeObj) {\n                                if (removeFn(result)) {\n                                    cursor.delete(result);\n                                }\n                            }\n                        }\n                        cursor.continue();\n                    }\n                }\n            };\n\n            transaction.oncomplete = function () {\n                deferred.resolve( results );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        var Query = function ( type , args ) {\n            var direction = 'next',\n                cursorType = 'openCursor',\n                filters = [],\n                limitRange = null,\n                mapper = defaultMapper,\n                unique = false;\n\n            var execute = function () {\n                return runQuery( type , args , cursorType , unique ? direction + 'unique' : direction, limitRange, filters , mapper );\n            };\n\n            var limit = function () {\n                limitRange = Array.prototype.slice.call( arguments , 0 , 2 )\n                if (limitRange.length == 1) {\n                    limitRange.unshift(0)\n                }\n\n                return {\n                    execute: execute,\n                    modify: modify,\n                    remove: remove\n                };\n            };\n            var count = function () {\n                direction = null;\n                cursorType = 'count';\n\n                return {\n                    execute: execute\n                };\n            };\n            var keys = function () {\n                cursorType = 'openKeyCursor';\n\n                return {\n                    desc: desc,\n                    execute: execute,\n                    filter: filter,\n                    distinct: distinct,\n                    map: map\n                };\n            };\n            var filter = function ( ) {\n                filters.push( Array.prototype.slice.call( arguments , 0 , 2 ) );\n\n                return {\n                    keys: keys,\n                    execute: execute,\n                    filter: filter,\n                    desc: desc,\n                    distinct: distinct,\n                    modify: modify,\n                    remove: remove,\n                    limit: limit,\n                    map: map\n                };\n            };\n            var desc = function () {\n                direction = 'prev';\n\n                return {\n                    keys: keys,\n                    execute: execute,\n                    filter: filter,\n                    distinct: distinct,\n                    modify: modify,\n                    remove: remove,\n                    map: map\n                };\n            };\n            var distinct = function () {\n                unique = true;\n                return {\n                    keys: keys,\n                    count: count,\n                    execute: execute,\n                    filter: filter,\n                    desc: desc,\n                    modify: modify,\n                    remove: remove,\n                    map: map\n                };\n            };\n            var modify = function(update) {\n                modifyObj = update;\n                return {\n                    execute: execute\n                };\n            };\n            var remove = function(update) {\n                if (typeof(update) == \"undefined\") {\n                    removeObj = function(item) { return true; }\n                } else {\n                    removeObj = update;\n                }\n\n                return {\n                    execute: execute\n                };\n            };\n            var map = function (fn) {\n                mapper = fn;\n\n                return {\n                    execute: execute,\n                    count: count,\n                    keys: keys,\n                    filter: filter,\n                    desc: desc,\n                    distinct: distinct,\n                    modify: modify,\n                    remove: remove,\n                    limit: limit,\n                    map: map\n                };\n            };\n\n            return {\n                execute: execute,\n                count: count,\n                keys: keys,\n                filter: filter,\n                desc: desc,\n                distinct: distinct,\n                modify: modify,\n                remove: remove,\n                limit: limit,\n                map: map\n            };\n        };\n        \n        'only bound upperBound lowerBound'.split(' ').forEach(function (name) {\n            that[name] = function () {\n                return new Query( name , arguments );\n            };\n        });\n\n        this.filter = function () {\n            var query = new Query( null , null );\n            return query.filter.apply( query , arguments );\n        };\n\n        this.all = function () {\n            return this.filter();\n        };\n    };\n    \n    var createSchema = function ( e , schema , db ) {\n        if ( typeof schema === 'function' ) {\n            schema = schema();\n        }\n        \n        for ( var tableName in schema ) {\n            var table = schema[ tableName ];\n            var store;\n            if (!hasOwn.call(schema, tableName) || db.objectStoreNames.contains(tableName)) {\n                store = e.currentTarget.transaction.objectStore(tableName);\n            } else {\n                store = db.createObjectStore(tableName, table.key);\n            }\n\n            for ( var indexKey in table.indexes ) {\n                var index = table.indexes[ indexKey ];\n                store.createIndex( indexKey , index.key || indexKey , Object.keys(index).length ? index : { unique: false } );\n            }\n        }\n    };\n    \n    var open = function ( e , server , version , schema ) {\n        var db = e.target.result;\n        var s = new Server( db , server );\n        var upgrade;\n\n        var deferred = Deferred();\n        deferred.resolve( s );\n        dbCache[ server ] = db;\n\n        return deferred.promise();\n    };\n\n    var dbCache = {};\n\n    var db = {\n        version: '0.9.0',\n        open: function ( options ) {\n            var request;\n\n            var deferred = Deferred();\n\n            // Check if we already have it in cache\n            var serverCache = dbCache[options.server];\n\n            if (serverCache) {\n                // If it is already in cache, make sure that we also \n                // have all of the tables we are opening already\n\n                for (var table in options.schema) {\n                    if (!serverCache.objectStoreNames.contains(table)) {\n                        serverCache.close();\n                        delete dbCache[options.server];\n                    }\n                }\n            }\n             \n\n            if ( dbCache[ options.server ]) {\n                open( {\n                    target: {\n                        result: dbCache[ options.server ]\n                    }\n                } , options.server , options.version , options.schema )\n                .done(deferred.resolve)\n                .fail(deferred.reject)\n                .progress(deferred.notify);\n            } else {\n                request = indexedDB.open( options.server , options.version );\n                            \n                request.onsuccess = function ( e ) {\n                    open( e , options.server , options.version , options.schema )\n                        .done(deferred.resolve)\n                        .fail(deferred.reject)\n                        .progress(deferred.notify);\n                };\n            \n                request.onupgradeneeded = function ( e ) {\n                    createSchema( e , options.schema , e.target.result );\n                };\n                request.onerror = function ( e ) {\n                    deferred.reject( e );\n                };\n            }\n\n            return deferred.promise();\n        }\n    };\n\n    return db;\n});",
    "\ndefine('dataLayer/indexedDBBacking',[\"class\", \"helpers\", \"db\", \"event\"], function(Class, Helpers, db, Event) {\n  var instance = Class.extend({\n    _parent: null,\n\n    _fileInfoPromise: null,\n    _fileServerPromise: null,\n\n    init: function(parent) {\n      this._parent = parent;\n    },\n\n    load: function(fileId) {\n      this._fileServerPromise = Promise.cast(\n        db.open({\n          server: fileId,\n          version: 1,\n          schema: {\n            localActions: {\n              key: {\n                keyPath: 'id'\n              }\n            },\n            remoteActions: {\n              key: {\n                keyPath: 'id'\n              },\n              indexes: {\n                id: {\n                  unique: true\n                },\n                index: {\n                  unique: true\n                }\n              }\n            }\n          }\n        }));\n\n      this._fileInfoPromise = this._parent.getFileInfo(fileId);\n\n      return Promise.all([this._fileServerPromise, this._fileInfoPromise])\n        .then(function(results) {\n          return results[1]\n        });\n    },\n\n    create: function(file) {\n      return this._parent._addFile(file)\n        .then((function() {\n          return this.load(file.id);\n        }).bind(this));\n    },\n\n    getActions: function() {\n      return this._fileServerPromise.then((function(server) {\n\n        var localPromise = Promise.cast(\n          server.localActions.query()\n          .all()\n          .execute()\n        );\n\n        var remotePromise = Promise.cast(\n          server.remoteActions.query('index')\n          .all()\n          .execute()\n        );\n\n        return Promise.all([localPromise, remotePromise])\n          .then(function(results) {\n            return {\n              local: results[0],\n              remote: results[1],\n            };\n          });\n      }).bind(this));\n    },\n\n    rename: function(newName) {\n      return this._fileInfoPromise.then((function(fileInfo) {\n        return this._parent._renameFile(fileInfo.id, newName)\n          .then(function(newFile) {\n            this._fileInfoPromise = Promise.cast(newFile);\n          });\n      }).bind(this));\n    },\n\n    updateThumbnail: function(dataURL) {\n      return this._fileInfoPromise.then((function(fileInfo) {\n        return this._parent._updateThumbnail(fileInfo.id, dataURL);\n      }).bind(this));\n    },\n\n    addLocalAction: function(action) {\n      return this._fileServerPromise.then((function(server) {\n        return Promise.cast(server.localActions.add(action));\n      }).bind(this));\n    },\n\n    removeLocalAction: function(actionId) {\n      return this._fileServerPromise.then((function(server) {\n        return Promise.cast(server.localActions.remove(actionId));\n      }).bind(this));\n    },\n\n    addRemoteActions: function(index, actions) {\n      return this._fileServerPromise.then((function(server) {\n        return Promise.cast(server.remoteActions\n          .query('index')\n          .lowerBound(index)\n          .desc()\n          .modify({\n            index: function(action) {\n              return action.index + actions.length;\n            }\n          })\n          .execute()\n        )\n          .then(function() {\n            return Promise.cast(server.remoteActions.add.apply(server.remoteActions, actions))\n          })\n      }).bind(this));\n    },\n\n    removeRemoteActions: function(index, length) {\n\n      return this._fileServerPromise.then((function(server) {\n        return Promise.cast(server.remoteActions\n          .query('index')\n          .lowerBound(index)\n          .limit(length)\n          .remove()\n          .execute()\n        )\n          .then(function() {\n            return Promise.cast(server\n              .remoteActions\n              .query('index')\n              .lowerBound(index)\n              .modify({\n                index: function(action) {\n                  return action.index - length;\n                }\n              })\n              .execute())\n          });\n      }).bind(this));\n    },\n\n    replaceFileId: function(newId) {\n      return this._fileInfoPromise.then((function(fileInfo) {\n\n        var oldActionsPromise = this.getActions();\n\n        var oldId = fileInfo.id;\n        fileInfo.id = newId;\n        var newFile = fileInfo;\n\n        this._fileInfoPromise = Promise.cast(fileInfo);\n\n        return Promise.all([oldActionsPromise, this._fileInfoPromise])\n          .then((function(results) {\n            var oldActions = results[0];\n            var newInfo = results[1];\n\n            return this._parent._addFile(newInfo)\n              .then((function(newFile) {\n                return this.load(newFile[0].id);\n              }).bind(this))\n              .then((function() {\n                return this._copyAllActions(oldActions);\n              }).bind(this))\n              .then((function() {\n                return this._parent.deleteFile(oldId);\n              }).bind(this))\n              .then(function() {\n                return newInfo;\n              });\n          }).bind(this))\n      }).bind(this));\n    },\n\n    close: function() {\n      return this._fileServerPromise.then((function(server) {\n        this._fileServerPromise = Promise.reject(new Error(\"File Server has been closed\"));\n        this._fileInfoPromise = Promise.reject(new Error(\"File has been closed\"));\n        return server.close();\n      }).bind(this));\n    },\n\n    updateLocalModifiedTime: function(time) {\n      return this._fileInfoPromise\n        .then((function(fileInfo) {\n          fileInfo.localModifiedTime = time;\n          this._fileInfoPromise = Promise.resolve(fileInfo);\n          return this._parent._updateLocalModifiedTime(fileInfo.id, time);\n        }).bind(this));\n    },\n\n    updateDriveModifiedTime: function(time) {\n      return this._fileInfoPromise\n        .then((function(fileInfo) {\n          fileInfo.driveModifiedTime = time;\n          this._fileInfoPromise = Promise.resolve(fileInfo);\n          return this._parent._updateDriveModifiedTime(fileInfo.id, time);\n        }).bind(this));\n    },\n\n    _copyAllActions: function(oldActions) {\n      return this._fileServerPromise.then(function(server) {\n        return Promise.all(\n          [\n            Promise.cast(server.localActions.add.apply(server, oldActions.local)),\n            Promise.cast(server.remoteActions.add.apply(server, oldActions.remote)),\n          ])\n          .\n        catch (function(error) {\n          console.error(\"Failed copying actions\", error, error.stack, error.message);\n        });\n      });\n    },\n  });\n\n  var IndexedDBBacking = Class.extend({\n    readyPromise: null,\n\n    _serverName: null,\n\n    init: function(serverName) {\n      this._serverName = serverName ? serverName : \"draw\";\n\n      this.readyPromise = Promise.cast(db.open({\n        server: this._serverName,\n        version: 1,\n        schema: {\n          files: {\n            key: {\n              keyPath: 'id',\n            },\n            indexes: {\n              id: {\n                unique: true\n              },\n              localModifiedTime: {},\n            }\n          }\n        }\n      }));\n    },\n\n    getFiles: function() {\n      return this.readyPromise.then((function(server) {\n        return Promise.cast(server.files.query('localModifiedTime')\n          .all()\n          .filter(function(file) {\n            return !file.deleted;\n          })\n          .desc()\n          .execute()\n        )\n          .then((function(results) {\n            return results.map(this._cleanFields);\n          }).bind(this));\n      }).bind(this))\n    },\n\n    _addFile: function(file) {\n      return this.readyPromise.then(function(server) {\n        return Promise.cast(\n          server.files.add(file)\n        );\n      });\n    },\n\n    _renameFile: function(fileId, newName) {\n      return this.readyPromise.then((function(server) {\n\n        return Promise.cast(server.files.query('id')\n          .only(fileId)\n          .modify({\n            name: newName\n          })\n          .execute()\n        )\n          .then((function(results) {\n            return results;\n          }).bind(this));\n      }).bind(this));\n    },\n\n    _updateThumbnail: function(fileId, dataURL) {\n      return this.readyPromise.then((function(server) {\n        return Promise.cast(server.files.query('id')\n          .only(fileId)\n          .modify({\n            thumbnail: dataURL\n          })\n          .execute()\n        )\n          .then((function(results) {\n            return results;\n          }).bind(this));\n      }).bind(this));\n    },\n\n    getDeletedFiles: function() {\n      return this.readyPromise.then((function(server) {\n        return Promise.cast(server.files.query()\n          .filter(function(file) {\n            return file.deleted;\n          })\n          .execute()\n        )\n          .then((function(results) {\n            return results.map(this._cleanFields);\n          }).bind(this));\n      }).bind(this));\n    },\n\n    markFileAsDeleted: function(fileId) {\n      return this.readyPromise.then(function(server) {\n\n        return Promise.cast(server.files.query('id')\n          .only(fileId)\n          .modify({\n            deleted: true\n          })\n          .execute()\n        )\n      });\n    },\n\n    unmarkFileAsDeleted: function(fileId) {\n      return this.readyPromise.then(function(server) {\n        return Promise.cast(server.files.query('id')\n          .only(fileId)\n          .modify({\n            deleted: false\n          })\n          .execute()\n        )\n          .then(function(results) {\n\n            Event.trigger(\"fileAdded\", results[0]);\n            return results;\n          });\n      });\n    },\n\n    deleteFile: function(fileId) {\n      return this.readyPromise.then(function(server) {\n\n        return Promise.cast(server.files.query('id')\n          .only(fileId)\n          .remove()\n          .execute()\n        )\n          .then(function(results) {\n            var f = indexedDB.deleteDatabase(fileId);\n            delete localStorage[fileId];\n\n            return results;\n          });\n      });\n    },\n\n    getFileInfo: function(fileId) {\n      return this.readyPromise.then(function(server) {\n        return Promise.cast(server.files.query('id')\n          .only(fileId)\n          .execute()\n        ).then(function(results) {\n          if (results.length == 0) {\n            return undefined;\n          }\n          return results[0];\n        });\n      }).then((function(result) {\n        if (result) {\n          this._cleanFields(result)\n        }\n\n        return result;\n      }).bind(this));;\n    },\n\n    _updateLocalModifiedTime: function(fileId, time) {\n      return this.readyPromise.then(function(server) {\n        return Promise.cast(server.files.query('id')\n          .only(fileId)\n          .modify({\n            localModifiedTime: time\n          })\n          .execute()\n        );\n      });\n    },\n\n    _updateDriveModifiedTime: function(fileId, time) {\n      return this.readyPromise.then(function(server) {\n        return Promise.cast(server.files.query('id')\n          .only(fileId)\n          .modify({\n            driveModifiedTime: time\n          })\n          .execute()\n        );\n      });\n    },\n\n    clearAll: function() {\n      return this.getFiles().then((function(files) {\n        files.map((function(file) {\n          return this.deleteFile(file.id);\n        }).bind(this))\n\n        return Promise.all(files).then((function() {\n          indexedDB.deleteDatabase(this._serverName);\n        }).bind(this));\n      }).bind(this))\n    },\n\n    _cleanFields: function(fileInfo) {\n      if (fileInfo.deleted) {\n        delete fileInfo.deleted;\n      }\n\n      return fileInfo;\n    },\n\n    instance: instance,\n  });\n\n  return IndexedDBBacking;\n});",
    "\ndefine('dataLayer/webSQLBacking',[\"class\", \"helpers\", \"event\"], function(Class, Helpers, Event) {\n  var instance = Class.extend({\n    _parent: null,\n\n    _fileId: null,\n\n    init: function(parent) {\n      this._parent = parent;\n    },\n\n    load: function(fileId) {\n      this._fileId = fileId;\n\n      return this._parent.getFileInfo(fileId);\n    },\n\n    create: function(file) {\n      return this._parent._addFile(file)\n        .then((function() {\n          return this.load(file.id);\n        }).bind(this));\n    },\n\n    getActions: function() {\n      return this._parent.readyPromise.then((function(server) {\n        return new Promise((function(overallResolve, overallReject) {\n\n          server.readTransaction((function(tx) {\n            var promises = [];\n\n            promises.push(new Promise((function(resolve, reject) {\n              tx.executeSql('SELECT * FROM `F' + this._fileId + '-local`', [], (function(transaction, results) {\n                  var resultsObj = this._parent._convertResultToObject(results, [\"value\"]);\n                  resolve(resultsObj);\n                }).bind(this),\n                function(transaction, error) {\n                  reject(error);\n                });\n            }).bind(this)));\n\n            promises.push(new Promise((function(resolve, reject) {\n              tx.executeSql('SELECT * FROM `F' + this._fileId + '-remote` ORDER BY `index`', [], (function(transaction, results) {\n                  var resultsObj = this._parent._convertResultToObject(results, [\"value\"]);\n                  resolve(resultsObj);\n                }).bind(this),\n                function(transaction, error) {\n                  reject(error);\n                });\n            }).bind(this)));\n\n            Promise.all(promises).then(function(results) {\n              overallResolve({\n                local: results[0],\n                remote: results[1],\n              });\n            })\n              .\n            catch (function(error) {\n              overallReject(error);\n            });\n\n          }).bind(this));\n\n        }).bind(this));\n      }).bind(this));\n    },\n\n    rename: function(newName) {\n      return this._parent._renameFile(this._fileId, newName);\n    },\n\n    updateThumbnail: function(dataURL) {\n      return this._parent._updateThumbnail(this._fileId, dataURL);\n    },\n\n    addLocalAction: function(action) {\n      return this._parent.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('INSERT INTO `F' + this._fileId + '-local` (id, type, value) VALUES (?, ?, ?)', [action.id, action.type, JSON.stringify(action.value)], (function(transaction, results) {\n                var resultsObj = this._parent._convertResultToObject(results, [\"value\"]);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    removeLocalAction: function(actionId) {\n      return this._parent.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('DELETE FROM `F' + this._fileId + '-local` WHERE id = ?', [actionId], (function(transaction, results) {\n                var resultsObj = this._parent._convertResultToObject(results, [\"value\"]);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    addRemoteActions: function(index, actions) {\n      return this._parent.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('UPDATE `F' + this._fileId + '-remote` SET `index` = `index` + ? WHERE `index` >= ?', [actions.length, index], (function(transaction, results) {\n                var promises = [];\n\n                actions.forEach((function(action) {\n                  promises.push(new Promise((function(resolve, reject) {\n                    tx.executeSql('INSERT INTO `F' + this._fileId + '-remote` (id, `index`, type, value) VALUES (?, ?, ?, ?)', [action.id, action.index, action.type, JSON.stringify(action.value)],\n                      function(transaction, results) {\n                        resolve(results);\n                      },\n                      function(transaction, error) {\n                        reject(error);\n                      })\n                  }).bind(this)));\n                }).bind(this));\n\n                Promise.all(promises).then(function(results) {\n                  resolve(results);\n                })\n                  .\n                catch (function(error) {\n                  reject(error);\n                });\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    removeRemoteActions: function(index, length) {\n      return this._parent.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('DELETE FROM `F' + this._fileId + '-remote` WHERE `index` between ? and ?', [index, index + length - 1], (function(transaction, results) {\n                tx.executeSql('UPDATE `F' + this._fileId + '-remote` SET `index` = `index` - ? WHERE `index` >= ?', [length, index],\n                  function(transaction, results) {\n                    resolve(results);\n                  },\n                  function(transaction, error) {\n                    reject(error);\n                  });\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              }\n            );\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    replaceFileId: function(newId) {\n      return this._parent._replaceFileId(this._fileId, newId)\n        .then((function() {\n          this._fileId = newId;\n        }).bind(this)).\n      catch (function(error) {\n        console.error(\"Error replacing fileId\", error);\n        throw error;\n      });\n\n    },\n\n    close: function() {\n      this._fileInfo = null;\n    },\n\n    updateLocalModifiedTime: function(time) {\n      return this._parent._updateLocalModifiedTime(this._fileId, time);\n    },\n\n    updateDriveModifiedTime: function(time) {\n      return this._parent._updateDriveModifiedTime(this._fileId, time);\n    },\n  });\n\n  var WebSQLBacking = Class.extend({\n    FIELDS: \"id, name, localModifiedTime, driveModifiedTime, thumbnail\",\n\n    readyPromise: null,\n\n    _serverName: null,\n\n    init: function(serverName) {\n      this._serverName = serverName ? serverName : \"files\";\n      var server = openDatabase(\"draw\", \"1.0\", \"draw\", 4 * 1024 * 1024);\n\n      this.readyPromise = Promise.resolve(server)\n        .then((function(server) {\n          return new Promise((function(resolve, reject) {\n            server.transaction((function(tx) {\n              tx.executeSql('CREATE TABLE IF NOT EXISTS `' + this._serverName + '`' +\n                '(' +\n                'id VARCHAR(255) PRIMARY KEY,' +\n                'name VARCHAR(255),' +\n                'localModifiedTime INTEGER,' +\n                'driveModifiedTime VARCHAR(255),' +\n                'thumbnail TEXT,' +\n                'deleted BOOL' +\n                ')', [],\n                function() {\n                  resolve(server)\n                },\n                function(error) {\n                  reject(error);\n                });\n            }).bind(this));\n          }).bind(this));\n        }).bind(this))\n        .\n      catch (function(error) {\n        console.error(\"Error initializing database\", error);\n        throw error;\n      });\n    },\n\n\n    getFiles: function() {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n\n          server.readTransaction((function(tx) {\n            tx.executeSql(\"SELECT \"+this.FIELDS+\" FROM `\" + this._serverName + \"` WHERE `deleted`='false' ORDER BY localModifiedTime DESC\", [], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n\n\n    _addFile: function(file) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(overallResolve, overallReject) {\n\n          server.transaction((function(tx) {\n            var promises = [];\n            promises.push(new Promise((function(resolve, reject) {\n              tx.executeSql('INSERT INTO `' + this._serverName + '` VALUES (?, ?, ?, ?, ?, ?)', [file.id, file.name, file.localModifiedTime, file.driveModifiedTime, file.thumbnail, false],\n                function(transaction, results) {\n                  resolve(results);\n                },\n                function(transaction, error) {\n                  reject(error);\n                });\n            }).bind(this)));\n\n            promises.push(new Promise((function(resolve, reject) {\n              tx.executeSql('CREATE TABLE IF NOT EXISTS `F' + file.id + '-local` ' +\n                '(id VARCHAR(255) PRIMARY KEY, type VARCHAR(255), value TEXT)', [],\n                function(transaction, results) {\n                  resolve(results);\n                },\n                function(transaction, error) {\n                  reject(error);\n                });\n            }).bind(this)));\n\n            promises.push(new Promise((function(resolve, reject) {\n              tx.executeSql('CREATE TABLE IF NOT EXISTS `F' + file.id + '-remote` ' +\n                '(id VARCHAR(255) PRIMARY KEY, `index` INTEGER, type VARCHAR(255), value TEXT)', [],\n                function(transaction, results) {\n                  resolve(results);\n                },\n                function(transaction, error) {\n                  reject(error);\n                });\n            }).bind(this)));\n\n            Promise.all(promises)\n              .then(function(results) {\n                overallResolve();\n              })\n              .\n            catch (function(error) {\n              overallReject(error);\n            })\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _renameFile: function(fileId, newName) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('UPDATE `' + this._serverName + '` SET name = ? WHERE id = ?', [newName, fileId], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _updateThumbnail: function(fileId, dataURL) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('UPDATE `' + this._serverName + '` SET thumbnail = ? WHERE id = ?', [dataURL, fileId], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _replaceFileId: function(fileId, newId) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            var promises = [];\n            promises.push(new Promise((function(resolve, reject) {\n              tx.executeSql('UPDATE `' + this._serverName + '` SET id = ? WHERE id = ?', [newId, fileId], (function(transaction, results) {\n                  var resultsObj = this._convertResultToObject(results);\n                  resolve(resultsObj[0]);\n                }).bind(this),\n                function(transaction, error) {\n                  reject(error);\n                });\n            }).bind(this)));\n\n            promises.push(new Promise(function(resolve, reject) {\n              tx.executeSql('ALTER TABLE `F' + fileId + '-local` RENAME TO `F' + newId + '-local`', [],\n                function(transaction, results) {\n                  resolve(results);\n                },\n                function(transaction, error) {\n                  reject(error);\n                });\n            }));\n\n            promises.push(new Promise(function(resolve, reject) {\n              tx.executeSql('ALTER TABLE `F' + fileId + '-remote` RENAME TO `F' + newId + '-remote`', [],\n                function(transaction, results) {\n                  resolve(results);\n                },\n                function(transaction, error) {\n                  reject(error);\n                });\n            }));\n\n            Promise.all(promises)\n              .then(function(results) {\n                resolve(results[0]);\n              })\n              .\n            catch (function(error) {\n              reject(error);\n            })\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    getDeletedFiles: function(callback) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.readTransaction((function(tx) {\n            tx.executeSql(\"SELECT \"+this.FIELDS+\" FROM `\" + this._serverName + \"` WHERE `deleted`='true' ORDER BY localModifiedTime DESC\", [], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    markFileAsDeleted: function(fileId) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('UPDATE `' + this._serverName + '` SET deleted = ? WHERE id = ?', [true, fileId], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    unmarkFileAsDeleted: function(fileId) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('UPDATE `' + this._serverName + '` SET deleted = ? WHERE id = ?', [false, fileId], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    deleteFile: function(fileId) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            var promises = [];\n            promises.push(new Promise((function(resolve, reject) {\n              tx.executeSql('DELETE FROM `' + this._serverName + '` WHERE id = ?', [fileId], (function(transaction, results) {\n                  var resultsObj = this._convertResultToObject(results);\n                  resolve(resultsObj[0]);\n                }).bind(this),\n                function(transaction, error) {\n                  reject(error);\n                });\n            }).bind(this)));\n\n            promises.push(new Promise(function(resolve, reject) {\n              tx.executeSql('DROP TABLE IF EXISTS `F' + fileId + '-local`', [], (function(transaction, results) {\n                  resolve();\n                }).bind(this),\n                function(transaction, error) {\n                  reject(error);\n                });\n            }));\n\n            promises.push(new Promise(function(resolve, reject) {\n              tx.executeSql('DROP TABLE IF EXISTS `F' + fileId + '-remote`', [], (function(transaction, results) {\n                  resolve();\n                }).bind(this),\n                function(transaction, error) {\n                  reject(error);\n                });\n            }));\n\n            Promise.all(promises)\n              .then(function(results) {\n                resolve(results[0]);\n              })\n              .\n            catch (function(error) {\n              reject(error);\n            })\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    getFileInfo: function(fileId) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.readTransaction((function(tx) {\n            tx.executeSql('SELECT '+this.FIELDS+' FROM `' + this._serverName + '` WHERE id = ?', [fileId], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _updateLocalModifiedTime: function(fileId, time) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('UPDATE `' + this._serverName + '` SET localModifiedTime = ? WHERE id = ?', [time, fileId], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _updateDriveModifiedTime: function(fileId, time) {\n      return this.readyPromise.then((function(server) {\n        return new Promise((function(resolve, reject) {\n          server.transaction((function(tx) {\n            tx.executeSql('UPDATE `' + this._serverName + '` SET driveModifiedTime = ? WHERE id = ?', [time, fileId], (function(transaction, results) {\n                var resultsObj = this._convertResultToObject(results);\n                resolve(resultsObj[0]);\n              }).bind(this),\n              function(transaction, error) {\n                reject(error);\n              });\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    // JSON Decode should be an array of columns that have JSON that should be parsed\n    _convertResultToObject: function(results, JSONDecode) {\n      var rows = results.rows;\n      var objArray = new Array(rows.length);\n\n      for (var i = 0; i < rows.length; i++) {\n        var item = rows.item(i);\n        objArray[i] = Helpers.clone(item);\n\n        if (JSONDecode) {\n          for (var j = 0; j < JSONDecode.length; j++) {\n            // If this key exists on the object\n            var value = objArray[i][JSONDecode[j]];\n            if (value) {\n              // Replace it with a JSON Parsed version\n              var obj = JSON.parse(value);\n              objArray[i][JSONDecode[j]] = obj;\n            }\n          }\n        }\n\n      }\n\n      return objArray;\n    },\n\n    clearAll: function() {\n      return this.getFiles().then((function(files) {\n        files.map((function(file) {\n          return this.deleteFile(file.id);\n        }).bind(this))\n\n        return Promise.all(files).then((function() {\n          return this.readyPromise;\n        }).bind(this))\n          .then((function(server) {\n            return new Promise((function(resolve, reject) {\n              server.transaction((function(tx) {\n                tx.executeSql('DROP TABLE `' + this._serverName + '`', [], (function(transaction, results) {\n                    resolve();\n                  }).bind(this),\n                  function(transaction, error) {\n                    reject(error);\n                  });\n              }).bind(this));\n            }).bind(this));\n          }).bind(this));\n      }).bind(this))\n    },\n\n    instance: instance,\n  });\n\n  return WebSQLBacking;\n});",
    "\ndefine('dataLayer/driveBacking',[\"class\", \"helpers\", \"gauth\"], function(Class, Helpers, GAuth) {\n  var instance = Class.extend({\n    _parent: null,\n\n    _docPromise: null,\n\n    _addedCallback: null,\n    _removedCallback: null,\n\n    // Delay if we need to change the file modified time of a file\n    _updateFileTimeout: null,\n\n    init: function(parent) {\n      this._parent = parent;\n\n      this._actionsAdded = this._actionsAdded.bind(this);\n      this._actionsRemoved = this._actionsRemoved.bind(this);\n      this._saveStateChanged = this._saveStateChanged.bind(this);\n    },\n\n    listen: function(addedCallback, removedCallback) {\n      this._addedCallback = addedCallback;\n      this._removedCallback = removedCallback;\n    },\n\n    stopListening: function() {\n      this._addedCallback = null;\n      this._removedCallback = null;\n    },\n\n    load: function(fileId) {\n      return this._parent._open(fileId)\n        .then((function(fileInfo) {\n          return this._openForRealtime(fileInfo.id);\n        }).bind(this))\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n      });\n    },\n\n    create: function(file) {\n      return this._parent._add(file)\n        .then((function(fileInfo) {\n          return this._openForRealtime(fileInfo.id)\n            .then(function() {\n              return fileInfo;\n            })\n        }).bind(this))\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n      });\n    },\n\n    _openForRealtime: function(fileId) {\n      return new Promise((function(resolve, reject) {\n\n        gapi.drive.realtime.load(fileId, (function(doc) {\n            // file was loaded\n            this._docPromise = Promise.resolve(doc);\n\n            this._docPromise.then((function(doc) {\n              var actions = doc.getModel().getRoot().get('actions');\n              actions.addEventListener(gapi.drive.realtime.EventType.VALUES_ADDED, this._actionsAdded);\n              actions.addEventListener(gapi.drive.realtime.EventType.VALUES_REMOVED, this._actionsRemoved);\n\n              doc.addEventListener(gapi.drive.realtime.EventType.DOCUMENT_SAVE_STATE_CHANGED, this._saveStateChanged);\n\n              resolve(this._docPromise);\n            }).bind(this));\n          }).bind(this),\n          function(model) {\n            // file was created\n            var actions = model.createList();\n            var root = model.getRoot();\n            root.set('title', 'Untitled File');\n            root.set('actions', actions);\n            root.set('id', fileId);\n          },\n          function(error) {\n\n            if (error.type == gapi.drive.realtime.ErrorType.TOKEN_REFRESH_REQUIRED) {\n              console.warn(\"Token expired, reauthorizing\");\n              GAuth.authorize();\n              return;\n              //reject(error);\n            } else if (error.type == gapi.drive.realtime.ErrorType.CLIENT_ERROR) {\n              //reject(new Error(error));\n            } else if (error.type == gapi.drive.realtime.ErrorType.NOT_FOUND) {\n              //reject(new Error(error));\n              //alert(\"The file was not found. It does not exist or you do not have read access to the file.\");\n            }\n\n            reject(new Error(error));\n          }\n        );\n      }).bind(this));\n    },\n\n    _actionsAdded: function(e) {\n      if (this._addedCallback) {\n        this._addedCallback(e);\n      }\n    },\n\n    _actionsRemoved: function(e) {\n      if (this._removedCallback) {\n        this._removedCallback(e);\n      }\n    },\n\n    _saveStateChanged: function(e) {\n      if (this._updateFileTimeout) {\n\n        // Clear it and set a new one\n        clearTimeout(this._updateFileTimeout);\n      }\n\n      // one second delay\n      this._updateFileTimeout = setTimeout((function() {\n        this._docPromise.then((function(doc) {\n          this._parent.touchFile(doc.getModel().getRoot().get('id'))\n            .then(function(result) {\n              console.log(\"Touched file\", result);\n            })\n            .\n          catch (function(e) {\n            console.error(\"Error touching file\", e);\n          });\n        }).bind(this));\n      }).bind(this), 2000);\n    },\n\n    getActions: function() {\n      return this._docPromise.then(function(doc) {\n        return doc.getModel().getRoot().get('actions').asArray();\n      });\n    },\n\n    rename: function(newName) {\n      return this._docPromise.then((function(doc) {\n        doc.getModel().getRoot().set(\"title\", newName);\n        return this._parent._renameFile(doc.getModel().getRoot().get('id'), newName)\n      }).bind(this));\n    },\n\n    addAction: function(action) {\n      return this._docPromise.then(function(doc) {\n        var actions = doc.getModel().getRoot().get('actions');\n        actions.insert(actions.length, action);\n      });\n    },\n\n    removeAction: function(actionIndex) {\n      return this._docPromise.then(function(doc) {\n        var actions = doc.getModel().getRoot().get('actions');\n        actions.remove(actionIndex);\n      });\n    },\n\n    undo: function() {\n      return this._docPromise.then(function(doc) {\n        doc.getModel().undo();\n      });\n    },\n\n    redo: function() {\n      return this._docPromise.then(function(doc) {\n        doc.getModel().redo();\n      });\n    },\n\n    close: function() {\n      if (!this._docPromise) {\n        debugger;\n      }\n      \n      return this._docPromise.then(function(doc) {\n        doc.close();\n      });\n    },\n  });\n\n  var DriveBacking = Class.extend({\n    _driveFileName: \"Untitled File\",\n    _appId: 450627732299,\n    REALTIME_MIMETYPE: 'application/vnd.google-apps.drive-sdk',\n    _fields: 'id, title, modifiedDate',\n\n    init: function() {\n\n    },\n\n    getFiles: function() {\n      return new Promise((function(resolve, reject) {\n        gapi.client.load('drive', 'v2', (function() {\n          gapi.client.drive.files.list({\n            'q': \"trashed=false and mimeType='\" + this.REALTIME_MIMETYPE + '.' + this._appId + \"'\",\n            'fields': 'items('+this._fields+')',\n          }).execute(function(resp) {\n            if (!resp) {\n              resolve([]);\n              return;\n            }\n\n            if (resp.error) {\n              reject(new Error(resp));\n            } else {\n              resolve(resp.items);\n            }\n          });\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _open: function(fileId) {\n      return new Promise(function(resolve, reject) {\n        gapi.client.load('drive', 'v2', function() {\n          var request = gapi.client.drive.files.get({\n            'fileId': fileId,\n            'fields': this._fields,\n          }).execute(function(resp) {\n\n            if (resp.error) {\n              reject(new Error(resp));\n            } else {\n              resolve({\n                id: resp.id,\n              });\n            }\n          });\n        });\n      });\n    },\n\n    _add: function(file) {\n      return new Promise((function(resolve, reject) {\n        gapi.client.load('drive', 'v2', (function() {\n          gapi.client.drive.files.insert({\n            'resource': {\n              mimeType: this.REALTIME_MIMETYPE,\n              title: file.name,\n            },\n            'fields': this._fields\n          }).execute(function(resp) {\n            if (resp.error) {\n              reject(new Error(resp));\n            } else {\n              resolve({\n                id: resp.id,\n              });\n            }\n          });\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _renameFile: function(fileId, newName) {\n      return new Promise(function(resolve, reject) {\n\n        var body = {\n          'title': newName\n        };\n\n        gapi.client.load('drive', 'v2', function() {\n          var request = gapi.client.drive.files.patch({\n            'fileId': fileId,\n            'resource': body,\n            'fields': this._fields,\n          });\n          request.execute(function(resp) {\n            if (resp.error) {\n              reject(new Error(resp));\n            } else {\n              resolve(resp);\n            }\n          });\n        });\n\n      });\n    },\n\n    deleteFile: function(fileId) {\n      return new Promise(function(resolve, reject) {\n\n        gapi.client.load('drive', 'v2', function() {\n          var request = gapi.client.drive.files.delete({\n            'fileId': fileId,\n            'fields': this._fields,\n          }).execute(function(resp) {\n            if (resp.error) {\n              reject(new Error(resp));\n            } else {\n              resolve(resp);\n            }\n          });\n        });\n      });\n    },\n\n    touchFile: function(fileId) {\n      return new Promise(function(resolve, reject) {\n        gapi.client.load('drive', 'v2', function() {\n          var request = gapi.client.drive.files.touch({\n            'fileId': fileId,\n            'fields': this._fields,\n          }).execute(function(resp) {\n            if (resp.error) {\n              reject(new Error(resp));\n            } else {\n              resolve(resp);\n            }\n          });\n        });\n      });\n    },\n\n    instance: instance,\n  });\n\n  return DriveBacking;\n});",
    "\ndefine('dataLayer/data',[\"class\", \"helpers\", \"event\", \"sequentialHelper\", \"dataLayer/file\", \"dataLayer/indexedDBBacking\", \"dataLayer/webSQLBacking\", \"dataLayer/driveBacking\"], function(Class, Helpers, Event, SequentialHelper, File, IndexedDBBacking, WebSQLBacking, DriveBacking) {\n  var Data = Class.extend({\n    _backing: null,\n    _cachedFiles: null,\n    _fileReferences: null,\n\n    _driveBacking: null,\n\n    init: function(backing) {\n      this._cachedFiles = {};\n      this._fileReferences = {};\n\n      if (backing) {\n        this._backing = backing;\n      } else {\n        if (window.indexedDB) {\n          console.log(\"Using IndexedDB as data store\");\n          this._backing = new IndexedDBBacking();\n        } else {\n          console.log(\"Using WebSQL as data store\");\n          this._backing = new WebSQLBacking();\n        }\n      }\n\n      Event.addListener(\"fileIdChanged\", this._fileIdChanged.bind(this));\n    },\n\n    // FILE METHODS\n    getFiles: function() {\n      return this._backing.getFiles()\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n        throw error;\n      });\n    },\n\n    createFile: function() {\n      var newFile = {\n        id: Helpers.getGuid(),\n        name: \"Untitled File\",\n        localModifiedTime: Date.now(),\n        driveModifiedTime: \"\",\n        // I don't like this, but it is a 1px transparent png\n        thumbnail: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==\",\n      };\n\n      return this._createFile(newFile);\n    },\n\n    _createFile: function(fileInfo) {\n      var file = new File(new this._backing.instance(this._backing));\n\n      this._fileReferences[fileInfo.id] = 0;\n\n      this._cachedFiles[fileInfo.id] = file.create(fileInfo)\n        .then((function(fileInfo, file) {\n          Event.trigger(\"fileAdded\", fileInfo);\n          return file;\n        }).bind(this, fileInfo))\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n        throw error;\n      });\n\n      if (this._driveBacking) {\n        this._cachedFiles[fileInfo.id].then((function() {\n          file.startDrive(this._newDriveInstance());\n        }).bind(this));\n      }\n\n      return this._cachedFiles[fileInfo.id];\n    },\n\n    loadFile: function(fileId, waitForSync) {\n      if (this._cachedFiles[fileId]) {\n        this._fileReferences[fileId]++;\n        return this._cachedFiles[fileId];\n      }\n\n      // file was not found\n      var file = new File(new this._backing.instance(this._backing));\n\n      this._fileReferences[fileId] = 1;\n\n      this._cachedFiles[fileId] = file.load(fileId)\n        .then((function() {\n          return file;\n        }).bind(this));\n\n\n      if (this._driveBacking) {\n\n        // If we have drive, start drive outside of this promise\n        this._cachedFiles[fileId].then((function() {\n          var startingDrive = file.startDrive(this._newDriveInstance());\n\n          if (waitForSync) {\n            return startingDrive;\n          }\n        }).bind(this));\n      }\n\n      return this._cachedFiles[fileId];\n    },\n\n    deleteFile: function(fileId, updateDrive) {\n      var promises = [];\n\n      Event.trigger(\"fileRemoved\", fileId);\n\n      if (this._fileReferences[fileId]) {\n        delete this._fileReferences[fileId];\n      }\n\n      // If it is in the cached files, close the file and remove it\n      if (this._cachedFiles[fileId]) {\n        var filePromise = this._cachedFiles[fileId];\n        delete this._cachedFiles[fileId];\n\n        promises.push(filePromise\n          .then((function(file) {\n            return this._close(file);\n          }).bind(this)));\n      }\n\n      var markDeleted = this._backing.markFileAsDeleted(fileId);\n      promises.push(markDeleted);\n\n      if (updateDrive !== false) { // could be true or undefined\n        if (this._driveBacking) {\n          promises.push(this._driveBacking.deleteFile(fileId)\n            .then((function() {\n              return this._backing.deleteFile(fileId);\n            }).bind(this)));\n        }\n      } else {\n        // We don't want to update drive first, just delete it\n        promises.push(markDeleted.then((function() {\n          promises.push(this._backing.deleteFile(fileId));\n        }).bind(this)));\n      }\n\n      return Promise.all(promises);\n    },\n\n    close: function(file) {\n      return file.fileInfoPromise\n        .then((function(fileInfo) {\n          if (this._fileReferences[fileInfo.id]) {\n            this._fileReferences[fileInfo.id]--;\n          }\n\n          if (this._fileReferences[fileInfo.id] > 0) {\n            // Not actually closing\n            return Promise.resolve();\n          } else {\n            // it is equal to 0\n            delete this._fileReferences[fileInfo.id];\n            delete this._cachedFiles[fileInfo.id];\n\n            return file.close();\n\n          }\n        }).bind(this));\n    },\n\n    startDrive: function() {\n      console.log(\"Drive connected\");\n\n      var driveBacking = new DriveBacking();\n\n      var promises = [];\n\n      var self = this;\n      var sequence = Promise.resolve();\n\n      for (var i in this._cachedFiles) {\n\n        sequence = sequence.then((function(i) {\n          return this._cachedFiles[i];\n        }).bind(this, i))\n          .then(function(file) {\n            var driveInstance = new driveBacking.instance(driveBacking);\n            return file.startDrive(driveInstance);\n          });\n      }\n\n      promises.push(sequence);\n\n      return Promise.all(promises)\n        .then((function() {\n          this._driveBacking = driveBacking;\n        }).bind(this))\n        .\n      catch (function(e) {\n        console.error(e, e.stack, e.message);\n      });\n    },\n\n    isOnline: function() {\n      return !!this._backing;\n    },\n\n    _fileIdChanged: function(e) {\n      if (this._cachedFiles[e.oldId]) {\n        this._fileReferences[e.newId] = this._fileReferences[e.oldId];\n        delete this._fileReferences[e.oldId];\n\n        this._cachedFiles[e.newId] = this._cachedFiles[e.oldId];\n        delete this._cachedFiles[e.oldId];\n      }\n    },\n\n    _newDriveInstance: function(driveBacking) {\n      return new this._driveBacking.instance(this._driveBacking);\n    },\n\n\n    checkForUpdates: function() {\n      if (SequentialHelper.hasActions()) {\n        return Promise.reject(new Error(\"Actions currently running, can't sync\"));\n      }\n\n\n\n      function getFileId(file) {\n        return file.id;\n      }\n\n      function sortById(file1, file2) {\n        return file1.id < file2.id;\n      }\n\n      function fileIdsMatch(file1, file2) {\n        return file1.id == file2.id;\n      }\n\n      function intersectFiles(drive, local, compare) {\n        var intersection = [];\n\n        for (var i = 0; i < drive.length; i++) {\n          for (var j = 0; j < local.length; j++) {\n            if (match(drive[i], local[j], compare)) {\n              intersection.push({\n                drive: drive[i],\n                local: local[j]\n              });\n              break;\n            }\n          }\n        }\n\n        return intersection;\n      }\n\n      function onlyInLeft(array1, array2, compare) {\n        var result = [];\n\n        for (var i = 0; i < array1.length; i++) {\n          var found = false;\n\n          for (var j = 0; j < array2.length; j++) {\n            if (compare(array1[i], array2[j])) {\n              found = true;\n              break;\n            }\n          }\n\n          if (!found) {\n            result.push(array1[i]);\n          }\n        }\n\n        return result;\n      }\n\n      function match(item1, item2, compare) {\n        return compare(item1, item2);\n      }\n\n      return SequentialHelper.startGlobalAction()\n        .then((function() {\n\n          console.log(\"Checking for file updates on drive\");\n\n          var driveFilesPromise = this._driveBacking.getFiles();\n          var localFilesPromise = this._backing.getFiles();\n          var locallyDeletedFilesPromise = this._backing.getDeletedFiles();\n\n          return Promise.all([driveFilesPromise, localFilesPromise, locallyDeletedFilesPromise])\n            .then((function(results) {\n              var remoteFiles = results[0].sort(sortById);\n              var localFiles = results[1].sort(sortById);\n              var filesDeletedLocally = results[2].sort(sortById);\n\n              var localFileIds = localFiles.map(getFileId);\n              var remoteFileIds = remoteFiles.map(getFileId);\n\n              var fileIdsDeletedLocally = filesDeletedLocally.map(getFileId);\n              var fileIdsDeletedOnBoth = fileIdsDeletedLocally.filter(function(id) {\n                return remoteFileIds.indexOf(id) === -1;\n              });\n\n              var filesOnlyOnDrive = onlyInLeft(remoteFiles, localFiles, fileIdsMatch);\n              var filesOnlyOnLocal = onlyInLeft(localFiles, remoteFiles, fileIdsMatch);\n              var filesOnBoth = intersectFiles(remoteFiles, localFiles, fileIdsMatch);\n\n              var promises = [];\n              var sequence = Promise.resolve();\n\n              // Delete all the files that were deleted on both local and remote\n              fileIdsDeletedOnBoth.map((function(id) {\n                promises.push(this._backing.deleteFile(id));\n              }).bind(this));\n\n\n              sequence = filesOnlyOnDrive.reduce((function(sequence, driveFileInfo) {\n\n                return sequence.then((function(driveFileInfo) {\n                  var deletedLocally = fileIdsDeletedLocally.indexOf(driveFileInfo.id) !== -1;\n                  return this._fileNotFoundLocally(driveFileInfo, deletedLocally);\n                }).bind(this, driveFileInfo));\n\n              }).bind(this), sequence);\n\n\n              sequence = filesOnlyOnLocal.reduce((function(sequence, localFileInfo) {\n\n                return sequence.then((function(localFileInfo) {\n                  // we don't have it on remote, and we also marked it as deleted locally\n                  var deletedLocally = fileIdsDeletedLocally.indexOf(localFileInfo.id) !== -1;\n                  return this._fileNotFoundOnRemote(localFileInfo, deletedLocally);\n                }).bind(this, localFileInfo));\n\n              }).bind(this), sequence);\n\n\n              sequence = filesOnBoth.reduce((function(sequence, files) {\n\n                return sequence\n                  .then((function(files) {\n                    var driveFileInfo = files.drive;\n                    var localFileInfo = files.local;\n\n\n                    var tempFile = new File(new this._backing.instance(this._backing));\n                    var hasLocalActionsPromise = tempFile.hasLocalActions(localFileInfo.id);\n\n                    return hasLocalActionsPromise.then((function(hasLocalActions) {\n\n                      if (\n                        driveFileInfo.modifiedDate != localFileInfo.driveModifiedTime ||\n                        hasLocalActions ||\n                        driveFileInfo.title != localFileInfo.name) {\n\n                        // Let the file check to make sure it is named properly and has all the actions\n                        return this.loadFile(localFileInfo.id, true)\n                          .then((function(fileObj) {\n\n                            return fileObj.updateDriveModifiedTime(driveFileInfo.modifiedDate)\n                              .then((function() {\n                                return this.close(fileObj);\n                              }).bind(this));\n                          }).bind(this));\n                      } else {\n                        console.log(\"No local changes, skipping\", localFileInfo.id);\n                      }\n                    }).bind(this));\n\n                  }).bind(this, files));\n              }).bind(this), sequence);\n\n              promises.push(sequence);\n\n              return Promise.all(promises)\n            }).bind(this))\n            .\n          catch (function(error) {\n            console.error(error, error.stack, error.message);\n          })\n            .then((function() {\n              console.log(\"Completed checking for Drive updates\");\n            }).bind(this))\n            .\n          catch (function(error) {\n            console.error(error, error.stack, error.message);\n          });\n        }).bind(this))\n        .then(function() {\n          SequentialHelper.endGlobalAction();\n        });\n    },\n\n\n    _fileNotFoundLocally: function(fileInfo, deletedLocally) {\n      if (deletedLocally) {\n        console.log(fileInfo.id, \"was deleted\");\n        // we need to see if the file remote actions match to \n        // know whether we should actually delete it remotely.\n        var tempFile = new File(new this._backing.instance(this._backing));\n        return tempFile.remoteActionsMatch(fileInfo.id, this._newDriveInstance())\n          .then((function(actionsMatch) {\n            if (actionsMatch) {\n              console.log(\"Deleting\", fileInfo.id, \"on remote\");\n              // delete it on the remote\n              return this.deleteFile(fileInfo.id);\n            } else {\n              // unmark as deleted and load it so it will sync\n              console.log(\"Readding\", fileInfo.id, \"on remote\");\n              var loadClose = this.loadFile(fileInfo.id)\n                .then((function(file) {\n                  return this.close(file);\n                }).bind(this));\n\n              return Promise.all([this._backing.unmarkFileAsDeleted(fileInfo.id), loadClose]);\n            }\n          }).bind(this));\n      } else {\n        // File wasn't found locally, make a file with the same\n        // id and then it will sync\n        var newFile = {\n          id: fileInfo.id,\n          name: fileInfo.title,\n          localModifiedTime: Date.now(),\n          driveModifiedTime: fileInfo.modifiedDate,\n\n          // I don't like this, but it is a 1px transparent png\n          thumbnail: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==\",\n        };\n\n        console.log(\"Creating file on drive again\");\n        return this._createFile(newFile)\n          .then((function(file) {\n            return this.close(file);\n          }).bind(this));\n      }\n    },\n\n    _fileNotFoundOnRemote: function(fileInfo, deletedLocally) {\n      if (deletedLocally) {\n        return this.deleteFile(fileInfo.id, false);\n      }\n\n      // TODO: check if we deleted it remotely\n      var deletedRemotely = !Helpers.isLocalGuid(fileInfo.id);\n\n      if (deletedRemotely) {\n        return this.deleteFile(fileInfo.id, false);\n      }\n\n      // load it and let it sync\n      return this.loadFile(fileInfo.id, true)\n        .then((function(file) {\n          return this.close(file);\n        }).bind(this));\n    }\n  });\n\n  var data = new Data();\n  return data;\n});",
    "\ndefine('online',[\"event\", \"gauth\", \"dataLayer/data\"], function(Event, GAuth, Data) {\n  var Online = function Online() {\n    this.init();\n  };\n\n  Online.prototype = {\n    _online: null,\n\n    _script: null,\n\n    init: function() {\n      this._online = false;\n\n      this._script = document.getElementById(\"gapiScript\");\n\n      window.addEventListener(\"online\", this._onlineEvent.bind(this));\n      window.addEventListener(\"offline\", this._offlineEvent.bind(this));\n    },\n\n    gapiLoaded: function() {\n      GAuth.start((function() {\n        console.log(\"GAuth Loaded\");\n        Data.startDrive()\n          .catch(function(error) {\n            console.error(error);\n          })\n          .then((function() {\n            this._setStatus(true);\n          }).bind(this))\n      }).bind(this));\n    },\n\n    gapiLoadError: function() {\n      console.log(\"Failed to load gapi\");\n      this._setStatus(false);\n      // set a reconnect timer, but only if navigator.online\n      window.setTimeout(this._retryScript.bind(this), 10);\n    },\n\n    isOnline: function() {\n      return this._online;\n    },\n\n    _retryScript: function() {\n      if (navigator.onLine) {\n        console.log(\"retrying to load the script\");\n        // We are connected to wifi but might not have a connection, \n        // try to reload the script\n        this._reloadScript();\n      }\n      else\n      {\n        // we aren't connected, don't retry\n      } \n    },\n\n    _reloadScript: function() {\n      var parent = this._script.parentElement;\n      parent.removeChild(this._script);\n      parent.insertBefore(this._script, parent.children[0]);\n    },\n\n    _onlineEvent: function() {\n      console.log(\"online event\");\n      if (window.gapi) {\n        GAuth.authorize()\n        this._setStatus(true);\n      } else {\n        // reload the script\n        this._reloadScript();\n      }\n    },\n\n    _offlineEvent: function() {\n      console.log(\"offline event\");\n      this._setStatus(false);\n      // keep doing everything\n    },\n\n\n    _setStatus: function(online) {\n      this._online = online;\n      Event.trigger(\"onlineStatusChanged\", {\n        online: online\n      });\n    }\n  }\n\n  return new Online();\n});",
    "\ndefine('sections/statusIndicator',[\"event\", \"section\"], function(Event, Section) {\n\n  var StatusIndicator = Section.extend({\n    id: \"mode\",\n\n    init: function() {\n      this._super();\n      this._onlineStatusChanged = this._onlineStatusChanged.bind(this);\n\n      Event.addListener(\"onlineStatusChanged\", this._onlineStatusChanged);\n    },\n\n    _onlineStatusChanged: function(e) {\n      if (e.online) {\n        this.element.classList.remove(\"offline\");\n\n        // check for updates if we come online while looking at this page\n        if (this._visible) {\n          Data.checkForUpdates()\n            .then((function() {\n              this._scheduleUpdate()\n            }).bind(this))\n            .\n          catch (function(error) {\n            console.error(error, error.stack, error.message);\n          });\n        }\n      } else {\n        // we are now offline, set the indicator\n        this.element.classList.add(\"offline\");\n      }\n    },\n  });\n\n  return StatusIndicator;\n\n});",
    "\ndefine('templates/fileList',[], function() {\n\n  function FileList() {\n    var template = '<li class=\"file-info\">'+\n                      '<div class=\"thumbnail-wrapper\">'+\n                        '<img class=\"thumbnail\" />'+\n                        '<div class=\"overlay\">'+\n                          '<span class=\"file-name\"></span>'+\n                        '</div>'+\n                        '<div class=\"bottom-info\">'+\n                          '<span class=\"delete icon-close\" data-action=\"delete\"></span>'+\n                        '</div>'+\n                      '</div>'+\n                    '</li';\n    var element = document.createElement(\"div\");\n    element.innerHTML = template;\n    return element.firstChild;\n  }\n\n  return FileList;\n});",
    "\ndefine('sections/fileList',[\"section\", \"tapHandler\", \"event\", \"globals\", \"helpers\", \"online\", \"sections/statusIndicator\", \"dataLayer/data\", \"templates/fileList\"], function(Section, TapHandler, Event, g, Helpers, Online, StatusIndicator, Data, FileListTemplate) {\n\n  var FileList = Section.extend({\n    id: \"files-list-container\",\n\n    // The parent pane for this page\n    _filesPane: null,\n\n    // The element\n    _fileListElement: null,\n\n    _files: null,\n\n    // The timer we use to schedule updates\n    _updateTimeout: null,\n\n    _indicator: null,\n\n    init: function(filesPane) {\n      this._super();\n\n      this._filesPane = filesPane;\n\n      this._files = [];\n\n      this._indicator = new StatusIndicator();\n\n      this._fileListElement = document.getElementById(\"files-list\");\n\n      this._scheduleUpdate = this._scheduleUpdate.bind(this);\n      this._onlineStatusChanged = this._onlineStatusChanged.bind(this);\n\n      Data.getFiles()\n        .then((function(files) {\n          for (var i = 0; i < files.length; i++) {\n            var fileInfo = files[i];\n            var fileTemplate = this._newFileWrapper(fileInfo);\n            this._fileListElement.appendChild(fileTemplate);\n          }\n        }).bind(this));\n\n      this.element.addEventListener(\"wheel\", function(e) {\n        e.stopPropagation();\n      });\n\n      new TapHandler(this._fileListElement, {\n        tap: this._docSelected.bind(this)\n      });\n\n      Event.addListener(\"fileAdded\", this._fileAdded.bind(this));\n      Event.addListener(\"fileRemoved\", this._fileRemoved.bind(this));\n      Event.addListener(\"fileModified\", this._fileModified.bind(this));\n      Event.addListener(\"fileRenamed\", this._fileRenamed.bind(this));\n      Event.addListener(\"fileIdChanged\", this._fileIdChanged.bind(this));\n      Event.addListener(\"fileModifiedRemotely\", this._fileModifiedRemotely.bind(this));\n      Event.addListener(\"thumbnailUpdated\", this._thumbnailUpdated.bind(this));\n\n\n    },\n\n    _newFileWrapper: function(fileInfo) {\n      var newEle = new FileListTemplate();\n\n      // The element has a reference to fileInfo\n      newEle.fileInfo = fileInfo;\n\n      var fileName = newEle.getElementsByClassName(\"file-name\")[0];\n      var thumbnail = newEle.getElementsByClassName(\"thumbnail\")[0];\n\n      fileName.textContent = fileInfo.name;\n      thumbnail.src = fileInfo.thumbnail;\n\n      this._files.push({\n        fileInfo: fileInfo,\n        element: newEle,\n      });\n\n      return newEle;\n    },\n\n    show: function() {\n      console.log(\"Showing file list\");\n      Event.addListener(\"onlineStatusChanged\", this._onlineStatusChanged);\n\n      // This could happen if we are online and then navigate to this page\n      if (Online.isOnline()) {\n        Data.checkForUpdates()\n          .then((function() {\n            this._scheduleUpdate()\n          }).bind(this));\n      }\n\n\n    },\n\n    hide: function() {\n      Event.removeListener(\"onlineStatusChanged\", this._onlineStatusChanged);\n\n      if (this._updateTimeout) {\n        clearTimeout(this._updateTimeout);\n      }\n    },\n\n    _scheduleUpdate: function() {\n      if (this._updateTimeout) {\n        clearTimeout(this._updateTimeout);\n      }\n\n      this._updateTimeout = setTimeout((function() {\n        if (!this._visible) {\n          return;\n        }\n\n        Data.checkForUpdates().then((function() {\n          this._scheduleUpdate()\n        }).bind(this));\n      }).bind(this), 15 * 1000);\n    },\n\n    _docSelected: function(e) {\n      var element = e.target;\n      var parent = Helpers.parentEleWithClassname(element, \"file-info\");\n\n      if (parent) {\n        if (parent.classList.contains(\"create\")) {\n          // Create was called\n          this._newDoc();\n        } else {\n          if (element.dataset.action && element.dataset.action == \"delete\") {\n            // Delete was clicked\n            return Data.deleteFile(parent.fileInfo.id);\n          }\n\n          // Regular file was clicked\n          this._filesPane.setPane(\"draw\", parent.fileInfo);\n        }\n      }\n    },\n\n    _newDoc: function() {\n      return Data.createFile()\n        .then(function(file) {\n          return file.fileInfoPromise;\n        })\n        .then((function(fileInfo) {\n          console.log(\"Showing draw for\", fileInfo);\n          this._filesPane.setPane(\"draw\", fileInfo);\n        }).bind(this));\n    },\n\n    // EVENTS\n    _onlineStatusChanged: function(e) {\n      // check for updates if we come online while looking at this page\n      if (e.online) {\n        Data.checkForUpdates()\n          .then((function() {\n            this._scheduleUpdate()\n          }).bind(this))\n          .\n        catch (function(error) {\n          console.error(error, error.stack, error.message);\n        });\n      }\n    },\n\n    _fileAdded: function(fileInfo) {\n      var fileTemplate = this._newFileWrapper(fileInfo);\n\n      this._fileListElement.insertBefore(fileTemplate, this._fileListElement.children[1]);\n    },\n\n    _fileRemoved: function(fileId) {\n      for (var i in this._files) {\n        var file = this._files[i];\n        if (file.fileInfo.id == fileId) {\n          this._fileListElement.removeChild(file.element);\n          delete this._files[i];\n          return;\n        }\n      }\n    },\n\n    _fileModified: function(fileInfo) {\n      for (var i in this._files) {\n        var file = this._files[i];\n        if (file.fileInfo.id == fileInfo.id) {\n          file.fileInfo.modifiedTime = fileInfo.modifiedTime;\n\n          this._fileListElement.removeChild(file.element);\n          this._fileListElement.insertBefore(file.element, this._fileListElement.children[1]);\n          return;\n        }\n      }\n    },\n\n    _fileRenamed: function(fileInfo) {\n      for (var i in this._files) {\n        var file = this._files[i];\n        if (file.fileInfo.id == fileInfo.id) {\n          file.fileInfo.name = fileInfo.name;\n\n          var fileNameElement = file.element.getElementsByClassName(\"file-name\")[0];\n          fileNameElement.textContent = fileInfo.name;\n          return;\n        }\n      }\n    },\n\n    _fileIdChanged: function(e) {\n      for (var i in this._files) {\n        var file = this._files[i];\n        if (file.fileInfo.id == e.oldId) {\n          file.fileInfo.id = e.newId;\n          break;\n        }\n      }\n    },\n\n    _fileModifiedRemotely: function(fileInfo) {\n\n    },\n\n    _thumbnailUpdated: function(fileInfo) {\n      for (var i in this._files) {\n        var file = this._files[i];\n        if (file.fileInfo.id == fileInfo.id) {\n\n          file.fileInfo.thumbnail = fileInfo.thumbnail;\n\n          var thumbnailElement = file.element.getElementsByClassName(\"thumbnail\")[0];\n          thumbnailElement.src = fileInfo.thumbnail;\n          return;\n        }\n      }\n    },\n  });\n\n  return FileList;\n\n});",
    "\ndefine('sections/draw',[\"section\", \"globals\", \"event\", \"helpers\", \"tapHandler\", \"platform\", \"db\", \"bezierCurve\", \"dataLayer/data\", \"components/manipulateCanvas\"], function(Section, g, Event, Helpers, TapHandler, Platform, db, BezierCurve, Data, ManipulateCanvas) {\n\n  var Draw = Section.extend({\n    id: \"draw\",\n\n    // The parent pane for this page\n    _filesPane: null,\n\n    // Instance of draw canvas that is handling all the drawing\n    _manipulateCanvas: null,\n\n    // The actual canvas element\n    _canvas: null,\n\n    // The file we are currently rendering\n    _file: null,\n\n    // Local settings such as offset and zoom\n    _settings: null,\n\n    // If we are currently doing something like drawing, it will be here\n    _currentAction: null,\n\n    // If we need to redraw but shouldn't re-render anything\n    _update: false,\n\n    // Do we need to update on this frame?\n    _updateAll: true,\n\n    // Does the current action need to be redrawn?\n    _updateCurrentAction: false,\n\n    // Set this to false to stop the render loop\n    _shouldRender: false,\n\n    // Timeout for saving settings\n    _saveSettingsTimeout: null,\n\n    // The timer we use to schedule file sync\n    _fileSyncTimeout: null,\n\n    // The tap handler for the draw pane. Needed to turn on and off gestures\n    _canvasTapHandler: null,\n\n    _toolTapHandler: null,\n\n    _fileNameElement: null,\n\n    // The overlay of modals\n    _overlay: null,\n\n    init: function(filesPane) {\n      this._super();\n\n      this._filesPane = filesPane;\n\n      this._canvas = document.getElementById('canvas');\n\n      this._actionsAdded = this._actionsAdded.bind(this);\n      this._actionsRemoved = this._actionsRemoved.bind(this);\n      this._resize = this._resize.bind(this);\n      this._fileModifiedRemotely = this._fileModifiedRemotely.bind(this);\n      this._fileRenamed = this._fileRenamed.bind(this);\n      this._redraw = this._redraw.bind(this);\n      this._onlineStatusChanged = this._onlineStatusChanged.bind(this);\n\n      // Keep the trackpad from trigger chrome's back event\n      this.element.addEventListener(\"touchmove\", function(e) {\n        e.preventDefault();\n      });\n\n      this._canvasTapHandler = new TapHandler(this.element, {\n        start: this._start.bind(this),\n        move: this._move.bind(this),\n        end: this._end.bind(this),\n        gesture: this._gesture.bind(this),\n        gestureStart: this._gestureStart.bind(this),\n        gestureEnd: this._gestureEnd.bind(this)\n      });\n\n\n      this._toolTapHandler = new TapHandler(document.getElementById(\"tools\"), {\n        tap: this._toolChanged.bind(this),\n        start: this._toolStart.bind(this),\n        end: this._toolEnd.bind(this)\n      });\n\n      new TapHandler(document.getElementById(\"menu\"), {\n        start: function(e) {\n          e.stopPropagation();\n        },\n        tap: this._menuTapped.bind(this),\n      });\n\n      new TapHandler(document.getElementById(\"fileName\"), {\n        start: function(e) {\n          e.stopPropagation();\n        }\n      });\n\n      new TapHandler(document.getElementById(\"options\"), {\n        start: function(e) {\n          e.stopPropagation();\n        },\n        tap: this._menuTapped.bind(this),\n      });\n\n      new TapHandler(document.getElementById(\"colorPicker\"), {\n        start: function(e) {\n          e.stopPropagation();\n        },\n        tap: this._colorPicked.bind(this)\n      });\n\n      this._overlay = document.getElementById(\"draw-overlay\");\n      this._overlay.addEventListener(\"mousedown\", this._hideModal.bind(this));\n      this._overlay.addEventListener(\"touchstart\", this._hideModal.bind(this));\n\n      this.element.addEventListener(Platform.mouseWheel, this._mouseWheel.bind(this));\n      this.element.addEventListener(\"keydown\", this._keyDown.bind(this));\n\n      this._fileNameElement = document.getElementById(\"fileName\");\n      this._fileNameElement.addEventListener(\"keydown\", this._fileNameKeyDown.bind(this));\n      this._fileNameElement.addEventListener(\"blur\", this._fileNameBlur.bind(this));\n\n    },\n\n    show: function(fileInfo) {\n      Data.loadFile(fileInfo.id)\n        .then((function(file) {\n\n          this._file = file;\n\n          file.listen(this._actionsAdded, this._actionsRemoved);\n\n          file.fileInfoPromise.then((function(fileInfo) {\n            this._fileNameElement.value = fileInfo.name;\n          }).bind(this));\n\n          file.localSettings().then((function(settings) {\n            this._settings = settings;\n            document.getElementById(\"chosenColorSwatch\").style.backgroundColor = this._settings.color;\n\n            this._setActiveTool();\n            this._manipulateCanvas = new ManipulateCanvas(this._canvas, this._settings);\n\n            this._redraw();\n\n            // Keep this file in sync\n            this._scheduleUpdate();\n          }).bind(this));\n\n          this._updateAll = true;\n          this._shouldRender = true;\n\n          Event.addListener(\"fileModifiedRemotely\", this._fileModifiedRemotely);\n          Event.addListener(\"fileRenamed\", this._fileRenamed);\n          Event.addListener(\"onlineStatusChanged\", this._onlineStatusChanged);\n\n        }).bind(this))\n        .\n      catch ((function(error) {\n        console.error(\"Unable to draw for this file\", error);\n        this._filesPane.setPane(\"list\");\n        return;\n      }).bind(this));\n\n      // We don't need data to resize\n      this._resize();\n\n      // Focus on the canvas after we navigate to it\n      setTimeout(function() {\n        canvas.focus();\n      }.bind(this), 400);\n\n      window.addEventListener(\"resize\", this._resize);\n    },\n\n    hide: function() {\n      this._file.stopListening();\n\n      // Close the file after we have left, keep it from stuttering.\n      window.setTimeout((function() {\n        this._file.updateThumbnail()\n          .then((function(file) {\n            return Data.close(file);\n          }).bind(this, this._file))\n          .\n        catch (function(error) {\n          console.error(error, error.stack, error.message);\n        });\n      }).bind(this), 600);\n\n      this._shouldRender = false;\n\n      Event.removeListener(\"fileModifiedRemotely\", this._fileModifiedRemotely);\n      Event.removeListener(\"fileRenamed\", this._fileRenamed);\n      Event.removeListener(\"onlineStatusChanged\", this._onlineStatusChanged);\n      window.removeEventListener(\"resize\", this._resize);\n    },\n\n    _actionsAdded: function(e) {\n      if (e.isLocal) {\n        this._update = true;\n        this._manipulateCanvas.addAction(e.items[0]);\n      } else {\n        this._updateAll = true;\n      }\n    },\n\n    _actionsRemoved: function(e) {\n      this._updateAll = true;\n    },\n\n    _resize: function() {\n      this._canvas.width = window.innerWidth;\n      this._canvas.height = window.innerHeight;\n\n      this._updateAll = true;\n    },\n\n    _zoom: function(x, y, dScale) {\n      if (this._manipulateCanvas.zoom(x, y, dScale)) {\n        this._saveSettings();\n        this._updateAll = true;\n      }\n    },\n\n    _pan: function(dx, dy) {\n      if (this._manipulateCanvas.pan(dx, dy)) {\n        this._saveSettings();\n        this._updateAll = true;\n      }\n    },\n\n    _mouseWheel: function(e) {\n      //console.log(e);\n      // deltaX is chrome, wheelDelta is safari\n      var dx = !isNaN(e.deltaX) ? -e.deltaX : (e.wheelDeltaX / 5);\n      var dy = !isNaN(e.deltaY) ? -e.deltaY : (e.wheelDeltaY / 5);\n\n      if (this._settings.tools.scroll == \"pan\") {\n        this._pan(dx, dy);\n      } else if (this._settings.tools.scroll == \"zoom\") {\n        if (dy != 0) {\n          this._zoom(e.clientX, e.clientY, dy / 100.0 * this._settings.scale);\n        }\n      }\n    },\n\n    _start: function(e) {\n      var tool = this._settings.tools.gesture || this._settings.tools.point;\n      if (e.button == 1) { // middle mouse\n        tool = \"pan\";\n      }\n\n      if (tool == \"pan\") {\n        this._manipulateCanvas.useCurves(false);\n        return;\n      }\n\n      var world = Helpers.screenToWorld(this._settings, e.distFromLeft, e.distFromTop);\n\n      if (this._currentAction) {\n        console.error(\"Current action isn't null!\");\n      }\n\n      this._currentAction = {\n        type: \"stroke\",\n        value: {\n          points: [\n            [world.x, world.y]\n          ],\n          width: 2,\n          lockWidth: true, // should the width stay the same regardless of zoom\n          color: this._settings.color\n        }\n      }\n\n      if (tool == \"eraser\") {\n        this._currentAction.value.width = 30 / this._settings.scale;\n        this._currentAction.value.color = \"#ffffff\";\n        this._currentAction.value.lockWidth = false;\n      } else if (this._settings.tools.point == \"pencil\") {\n\n      }\n    },\n\n    _move: function(e) {\n      var tool = this._settings.tools.gesture || this._settings.tools.point;\n\n      if (e.button == 1) { // middle mouse\n        tool = \"pan\";\n      }\n\n      if (tool == \"pan\") {\n        this._pan(e.xFromLast, e.yFromLast);\n      } else if (tool == \"pencil\" || tool == \"eraser\") {\n\n        if (!this._currentAction) {\n          // no current action. This can happen if we were dragging a tool and let up the\n          // tool button and kept dragging\n          return;\n        }\n\n        var world = Helpers.screenToWorld(this._settings, e.distFromLeft, e.distFromTop);\n\n        var currentStroke = this._currentAction.value;\n\n        var points = currentStroke.points;\n        var lastPoint = points[points.length - 1];\n\n\n        var dist = Math.sqrt(\n          ((lastPoint[0] - world[0]) * (lastPoint[0] - world[0])) +\n          ((lastPoint[1] - world[1]) * (lastPoint[1] - world[1]))\n        );\n\n        if (dist < 0.001) {\n          return;\n        }\n\n        currentStroke.points.push([world.x, world.y]);\n        this._updateCurrentAction = true;\n      }\n    },\n\n    _end: function(e) {\n      var tool = this._settings.tools.gesture || this._settings.tools.point;\n\n      if (tool == \"pan\") {\n        this._manipulateCanvas.useCurves(true);\n        this._updateAll = true;\n      }\n      else if (tool == \"pencil\" || tool == \"eraser\") {\n        if (!this._currentAction) {\n          // no current action. This can happen if we were dragging a tool and let up the\n          // tool button and kept dragging\n          return;\n        }\n\n        var currentAction = this._currentAction;\n        this._currentAction = null;\n\n        var currentStroke = currentAction.value;\n\n        if (currentStroke.points.length < 2) {\n          // two options, don't count the stroke\n          return;\n\n          // or render a point\n        }\n\n        // Copy the control points out now that we are done with it.\n        var controlPoints = Helpers.cloneArray(BezierCurve.getCurveControlPoints(currentStroke.points));\n\n        currentStroke.controlPoints = controlPoints;\n\n        this._updateCurrentAction = true;\n\n        // the actions is done, we should redraw everything.\n        this._updateAll = true;\n\n        this._saveAction(currentAction);\n      }\n    },\n\n    _saveAction: function(action) {\n      // We aren't going to send these to drive\n      // delete action.value.controlPoints;\n      action.id = Helpers.getGuid();\n      this._file.addAction(action)\n        .\n      catch (function(e) {\n        console.error(e, e.stack, e.message);\n      });\n    },\n\n    _gesture: function(e) {\n      this._pan(e.xFromLast, e.yFromLast);\n      this._zoom(e.x, e.y, e.scaleFromLast * this._settings.scale);\n    },\n\n    _gestureStart: function() {\n      this._manipulateCanvas.useCurves(false);\n    },\n\n    _gestureEnd: function() {\n      this._manipulateCanvas.useCurves(true);\n      this._updateAll = true;\n    },\n\n    _redraw: function() {\n      // If we shouldn't render, exit the loop\n      if (!this._shouldRender) {\n        return;\n      }\n\n      if (this._updateAll) {\n        var actions = this._file.getActions();\n        this._manipulateCanvas.doAll(actions);\n      }\n\n      if (this._updateCurrentAction && this._currentAction) {\n        var currentAction = this._currentAction;\n        var controlPoints = BezierCurve.getCurveControlPoints(currentAction.value.points);\n\n        currentAction.value.controlPoints = controlPoints;\n        this._manipulateCanvas.doTemporaryAction(currentAction)\n      }\n\n      if (this._updateAll || this._updateCurrentAction || this._update) {\n        this._manipulateCanvas.render();\n\n        this._update = false;\n        this._updateAll = false;\n        this._updateCurrentAction = false;\n      }\n\n      requestAnimationFrame(this._redraw);\n    },\n\n    _menuTapped: function(e) {\n      if (e.target.tagName == \"LI\") {\n        var action = e.target.dataset.action;\n\n        if (action == \"back\") {\n          this._file.fileInfoPromise.then((function(fileInfo) {\n            this._filesPane.setPane(\"list\", fileInfo);\n          }).bind(this));\n        } else if (action == \"rename\") {\n          e.target.focus();\n        } else if (action == \"export\") {\n          var dataURL = this._canvas.toDataURL();\n          window.open(dataURL);\n        }\n      }\n    },\n\n    _showModal: function(modalId) {\n      var modal = document.getElementById(modalId);\n      if (!modal) {\n        console.error(\"No modal with that id\");\n        return;\n      }\n\n      this._overlay.currentModal = modalId;\n      this._overlay.style.display = \"block\";\n\n      setTimeout(function() {\n        modal.classList.add(\"visible\");\n      }, 0);\n    },\n\n    _hideModal: function(e) {\n      if (e && e.target != this._overlay) {\n        // overlay was explicitly tapped\n        return;\n      }\n\n      if (this._overlay.currentModal) {\n        // A modal is showing\n        var modal = document.getElementById(this._overlay.currentModal);\n        modal.classList.remove(\"visible\");\n        this._overlay.currentModal = \"\";\n      }\n\n      this._overlay.style.display = \"\";\n\n      if (e) {\n        //e.stopPropagation();\n      }\n    },\n\n    _colorPicked: function(e) {\n      parent = Helpers.parentEleWithClassname(e.target, \"swatch\");\n      if (parent) {\n        var color = parent.style.backgroundColor;\n        this._settings.color = color;\n        this._saveSettings();\n\n        document.getElementById(\"chosenColorSwatch\").style.backgroundColor = color;\n        this._hideModal();\n      }\n\n      e.stopPropagation();\n    },\n\n    _toolStart: function(e) {\n\n      var tool = e.target.dataset.tool;\n      var action = e.target.dataset.action;\n\n      if (e.target.tagName == \"LI\" && tool) {\n        if (tool == \"pan\" || tool == \"eraser\" || tool == \"pencil\") {\n          this._settings.tools.gesture = tool;\n\n          this._setActiveTool();\n\n          this._canvasTapHandler.ignoreGestures(true);\n          this._toolTapHandler.ignoreGestures(true);\n        }\n      }\n\n      e.stopPropagation();\n      e.preventDefault();\n    },\n\n    _toolEnd: function(e) {\n      if (e) {\n        var tool = e.target.dataset.tool;\n\n        if (e.target.tagName == \"LI\" && tool) {\n          if (tool == \"pan\" || tool == \"eraser\" || tool == \"pencil\") {\n            this._settings.tools.gesture = null;\n\n            this._setActiveTool();\n\n            this._canvasTapHandler.ignoreGestures(false);\n            this._toolTapHandler.ignoreGestures(false);\n          }\n        }\n      }\n    },\n\n    _toolChanged: function(e) {\n      var parent = Helpers.parentEleWithClassname(e.target, \"toolitem\");\n\n      if (parent && parent.tagName == \"LI\") {\n        var action = parent.dataset.action;\n        var tool = parent.dataset.tool;\n\n        if (tool) {\n          if (tool == \"pencil\") {\n            this._settings.tools.point = \"pencil\";\n          } else if (tool == \"eraser\") {\n            this._settings.tools.point = \"eraser\";\n          } else if (tool == \"pan\") {\n            // TODO: this should probably check if the event was a touch\n            // or mouse event\n            if (g.isComputer()) {\n              this._settings.tools.scroll = \"pan\";\n            } else {\n              this._settings.tools.point = \"pan\";\n            }\n          } else if (tool == \"zoom\") {\n            this._settings.tools.scroll = \"zoom\";\n          }\n\n          this._setActiveTool();\n          this._saveSettings();\n        } else if (action) {\n          if (action == \"undo\") {\n            this._undo();\n          } else if (action == \"redo\") {\n            this._redo();\n          }\n          if (action == \"color\") {\n            this._showModal(\"colorPicker\");\n\n            e.preventDefault();\n            e.stopImmediatePropagation();\n          }\n        }\n      }\n    },\n\n    _setActiveTool: function() {\n      var toolsElement = document.getElementById(\"tools\");\n\n      function addRemove(type) {\n        var prevTool = toolsElement.dataset[\"active\" + type];\n        if (prevTool) {\n          var toolItem = document.getElementById(prevTool);\n          toolItem.classList.remove(\"active-\" + type);\n        }\n\n        var currentTool = this._settings.tools[type];\n\n        if (currentTool) {\n\n          var currentToolId = currentTool + \"-tool\";\n          var newToolItem = document.getElementById(currentToolId);\n          newToolItem.classList.add(\"active-\" + type);\n\n          toolsElement.dataset[\"active\" + type] = currentToolId;\n        } else {\n          delete toolsElement.dataset[\"active\" + type];\n        }\n\n      }\n\n      addRemove = addRemove.bind(this);\n\n      addRemove(\"point\");\n\n      if (g.isComputer()) {\n        addRemove(\"scroll\");\n      }\n    },\n\n    _keyDown: function(e) {\n      var key = String.fromCharCode(e.keyCode);\n\n      if (\n        ((g.isMac() && e.metaKey && e.shiftKey) && key == \"Z\") ||\n        ((g.isPC() && e.ctrlKey) && key == \"Y\")) {\n        // Redo\n\n        this._redo();\n      } else if ((\n          (g.isMac() && e.metaKey) ||\n          (g.isPC() && e.ctrlKey)\n        ) &&\n        key == \"Z\") {\n        // Undo\n\n        e.preventDefault();\n        this._undo();\n      } else if (key == \"Z\") {\n        this._settings.tools.scroll = \"zoom\";\n        this._setActiveTool();\n      } else if (key == \"P\") {\n        this._settings.tools.scroll = \"pan\";\n        this._setActiveTool();\n      }\n\n    },\n\n    _undo: function() {\n      this._file.undo();\n      this._updateAll = true;\n\n    },\n\n    _redo: function() {\n      this._file.redo();\n      this._updateAll = true;\n    },\n\n    _fileNameKeyDown: function(e) {\n      if (e.keyCode == 13) { // Enter\n        this._fileNameElement.blur();\n      }\n    },\n\n    _fileNameBlur: function(e) {\n      var name = e.target.value;\n      this._file.rename(name);\n    },\n\n\n    _saveSettings: function() {\n      // If the timeout is set already\n      if (this._saveSettingsTimeout) {\n\n        // Clear it and set a new one\n        clearTimeout(this._saveSettingsTimeout);\n      }\n\n      this._saveSettingsTimeout = setTimeout((function() {\n        this._file.localSettings(this._settings);\n      }).bind(this), 100);\n\n    },\n\n    _fileModifiedRemotely: function(fileInfo) {\n      this._file.fileInfoPromise.then((function(file) {\n        if (fileInfo.id == file.id) {\n          this._updateAll = true;\n        }\n      }).bind(this));\n    },\n\n    _fileRenamed: function(file) {\n      this._file.fileInfoPromise.then((function(fileInfo) {\n        if (fileInfo.id == file.id) {\n          this._fileNameElement.value = file.name;\n        }\n      }).bind(this));\n    },\n\n    _onlineStatusChanged: function() {\n      // check for updates if we come online while looking at this page\n      // Make sure we sync actions in this case\n      this._file.sync(null, true)\n        .then((function() {\n          this._scheduleUpdate()\n        }).bind(this))\n        .\n      catch (function(error) {\n        console.error(error, error.stack, error.message);\n      });\n    },\n\n    _scheduleUpdate: function() {\n      if (this._fileSyncTimeout) {\n        clearTimeout(this._fileSyncTimeout);\n      }\n\n      this._fileSyncTimeout = setTimeout((function() {\n        if (!this._visible) {\n          return;\n        }\n\n        if (this._currentAction) {\n          console.log(\"We are currently drawing, delaying sync\");\n          this._scheduleUpdate();\n          return;\n        }\n\n        // If we haven't yet finished loading the file, skip the sync for now\n        if (this._file.isConnected()) {\n          this._file.sync(null, false).then((function() {\n            this._scheduleUpdate()\n          }).bind(this));\n        } else {\n          this._scheduleUpdate();\n        }\n\n      }).bind(this), 15 * 1000);\n    },\n  });\n\n  return Draw;\n\n});",
    "\ndefine('managers/files',[\"section\", \"event\", \"platform\", \"sections/fileList\", \"sections/draw\"], function(Section, Event, Platform, FileList, Draw) {\n\n  var Files = Section.extend({\n    id: \"files\",\n\n    _paneWrapper: null,\n\n    _screenWidth: 0,\n\n    panes: null,\n\n    currentPaneName: null,\n\n    _currentState: null,\n\n    init: function() {\n      this._super();\n\n      this._screenWidth = window.innerWidth;\n\n      this._paneWrapper = document.getElementById(\"files-pane-wrapper\");\n\n      this._windowResized = this._windowResized.bind(this);\n      this._finishedSliding = this._finishedSliding.bind(this);\n\n      this._paneWrapper.addEventListener(Platform.transitionEnd, this._finishedSliding);\n\n      this.panes = {};\n\n      this.panes.list = {\n        offsetX: 0,\n        pane: new FileList(this)\n      };\n\n      this.panes.draw = {\n        offsetX: this._screenWidth,\n        pane: new Draw(this)\n      };\n\n      this.panes.draw.pane.element.style[Platform.transform] = 'translate(' + this._screenWidth + \"px, 0px)\";\n\n      this._currentState = {\n        pane: \"list\",\n        details: null\n      };\n\n      if (localStorage.filesPane) {\n        this._currentState = JSON.parse(localStorage.filesPane);\n      }\n\n      this.setPane(this._currentState.pane, this._currentState.details);\n      this._redoOffsets();\n\n      Event.addListener(\"fileIdChanged\", this._fileIdChanged.bind(this));\n    },\n\n    show: function() {\n      window.addEventListener(\"resize\", this._windowResized);\n    },\n\n    hide: function() {\n      window.removeEventListener(\"resize\", this._windowResized);\n    },\n\n    setPane: function(pane, details) {\n      if (this.currentPaneName == pane)\n        return;\n\n      var paneobj = null;\n\n      if (this.currentPaneName) {\n\n        var paneobj = this.panes[this.currentPaneName].pane;\n\n        if (paneobj.hide) {\n          paneobj.hide();\n        }\n\n        paneobj.afterHide();\n      }\n\n\n      paneobj = this.panes[pane].pane;\n\n      if (paneobj.show) {\n        paneobj.show(details);\n      }\n\n      paneobj.afterShow();\n\n      this.currentPaneName = pane;\n\n\n      // Finish up\n      var totalPane = this.panes[pane];\n\n      var translate = \"translate(\" + (-1 * totalPane.offsetX) + \"px, 0px)\";\n      if (this._paneWrapper.style[Platform.transform] != translate) {\n        this._paneWrapper.classList.add(\"ani4\");\n        this._paneWrapper.style[Platform.transform] = translate;\n      }\n\n\n      this._currentState = {\n        pane: \"list\",\n        details: null\n      };\n\n      if (pane != \"list\") {\n        this._currentState.pane = pane;\n        this._currentState.details = details;\n      }\n\n      localStorage.filesPane = JSON.stringify(this._currentState);\n    },\n\n    _finishedSliding: function(e) {\n      if (e.target != this._paneWrapper) {\n        return;\n      }\n\n      // Remove the animation\n      this._paneWrapper.classList.remove(\"ani4\");\n\n      this._redoOffsets();\n    },\n\n    _windowResized: function() {\n      this._redoOffsets();\n    },\n\n    _redoOffsets: function() {\n      this._screenWidth = window.innerWidth;\n\n      // Set the offsets on all the panes so that the current pane is 0,0\n      var currentIndex = 0;\n      for (var pane in this.panes) {\n        if (this.currentPaneName == pane) {\n          break;\n        }\n\n        currentIndex++;\n\n      }\n\n      var startX = -1 * currentIndex * this._screenWidth;\n      for (var pane in this.panes) {\n        this.panes[pane].offsetX = startX;\n        this.panes[pane].pane.element.style[Platform.transform] = 'translate(' + startX + \"px, 0px)\";\n        startX += this._screenWidth;\n      }\n\n      this._paneWrapper.style[Platform.transform] = \"\";\n    },\n\n    _fileIdChanged: function(e) {      \n      // the current state details is a reference, so the id will change out from under us\n      // if it is the new id, then save it\n      if (this._currentState.details && this._currentState.details.id == e.newId) {\n        localStorage.filesPane = JSON.stringify(this._currentState);\n      }\n    },\n  });\n\n  return Files;\n\n});",
    "\ndefine('sections/main',[\"section\", \"event\", \"managers/files\"], function(Section, Event, Files) {\n\n  var Main = Section.extend({\n    id: \"main-container\",\n\n    mainContent: null,\n\n    // The panes we slide between in the main-content\n    panes: null,\n    currentPane: \"\",\n\n\n    init: function() {\n      this._super();\n\n      this.mainContent = document.getElementById(\"main-content\");\n      this.panes = {};\n\n      this.panes.files = new Files();\n      \n      Event.addListener(\"logout\", this._logout.bind(this));\n    },\n\n    show: function() {\n      if (localStorage.currentPane) {\n        this.setPane(localStorage.currentPane);\n      } else {\n        this.setPane(\"files\");\n      }\n    },\n\n\n    setPane: function(pane) {\n      if (this.currentPane == pane)\n        return;\n\n      var paneobj = null;\n\n      if (this.currentPane) {\n\n        var paneobj = this.panes[this.currentPane];\n\n        if (paneobj.hide) {\n          paneobj.hide();\n        }\n\n        paneobj.afterHide();\n      }\n\n      paneobj = this.panes[pane];\n\n      if (paneobj.show) {\n        paneobj.show();\n      }\n\n      paneobj.afterShow();\n\n      this.currentPane = pane;\n\n      localStorage.currentPane = pane;\n      Event.trigger(\"paneChanged\", {\n        pane: paneobj\n      });\n    },\n\n    _logout: function() {\n      delete localStorage.currentPane;\n    }\n  });\n\n  return Main;\n\n});",
    "\ndefine('managers/login',[\"event\", \"sections/login\", \"sections/main\"], function(Event, LoginSection, MainSection) {\n  function LoginManager() {\n    this.init();\n  }\n\n  LoginManager.prototype = {\n    pages: null,\n    currentPage: \"\",\n\n    init: function() {\n      this.pages = {};\n\n      Event.addListener(\"login\", this._login.bind(this));\n      Event.addListener(\"logout\", this._logout.bind(this));\n\n      this.pages.login = new LoginSection();\n      this.pages.main = new MainSection();\n\n      if (localStorage.loggedIn == \"true\") {\n        this.setPage(\"main\");\n      }\n      else\n      {\n        this.setPage(\"login\");\n      }\n    },\n\n    setPage: function(page) {\n      var pageobj = null;\n\n      if (this.currentPage) {\n\n        var pageobj = this.pages[this.currentPage];\n\n        if (pageobj.hide) {\n          pageobj.hide();\n        }\n        pageobj.afterHide();\n      }\n\n      pageobj = this.pages[page];\n      \n      if (pageobj.show) {\n        pageobj.show();\n      }\n      pageobj.afterShow();\n\n      this.currentPage = page;\n    },\n\n    _login: function() {\n      localStorage.loggedIn = true;\n      this.setPage(\"main\");\n    },\n\n    _logout: function() {\n      // https://accounts.google.com/Logout\n      localStorage.loggedIn = false;\n      this.setPage(\"login\");\n    }\n  };\n\n  return LoginManager;\n});",
    "\nfunction init() {\n  window.log = console.log.bind(console);\n\n  window.addEventListener(\"wheel\", function(e) {\n    e.preventDefault();\n  });\n\n  require([\"promise\", \"event\", \"globals\", \"helpers\", \"managers/login\", \"gauth\"], function(Promise, Event, g, Helpers, LoginManager, GAuth) {\n    g.setHTMLDevices();\n\n    var loginManager = new LoginManager();\n\n    window.addEventListener(\"resize\", function() {\n      // make sure we are scrolled to 0. Without this there are problems \n      // when changing device orientation\n      window.scroll(0, 0);\n      setHeight();\n    });\n\n    function setHeight() {\n      document.body.style.height = window.innerHeight + \"px\";\n    }\n\n    setHeight();\n  });\n}\n\nif (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n  init();\n} else {\n  document.addEventListener(\"DOMContentLoaded\", init, false);\n}\n\n\nif (!window.Promise) {\n  require([\"promise\"], function(Promise) {\n    window.Promise = Promise;\n  });\n}\n\nwindow.gapiLoaded = function() {\n  require([\"online\"], function(Online) {\n    Online.gapiLoaded();\n  });\n}\n\nwindow.gapiLoadError = function() {\n  require([\"online\"], function(Online) {\n    Online.gapiLoadError();\n  });\n};\ndefine(\"main\", function(){});\n"
  ]
}