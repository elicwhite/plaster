{
  "version": 3,
  "file": "/Users/eli/projects/draw/build/javascript/main.min.js",
  "sources": [
    "../../node_modules/grunt-requirejs/node_modules/almond/almond.js",
    "event.js",
    "globals.js",
    "class.js",
    "section.js",
    "tapHandler.js",
    "sections/login.js",
    "helpers.js",
    "vendor/indexedDBShim.js",
    "vendor/db.js",
    "data.js",
    "templates/fileList.js",
    "components/drawCanvas.js",
    "components/manipulateCanvas.js",
    "components/thumbnail.js",
    "sections/fileList.js",
    "sections/draw.js",
    "managers/files.js",
    "sections/main.js",
    "managers/login.js",
    "main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA,ADgEA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClNA,ADmNA;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA,AD+BA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxoDA,ADyoDA;ACxoDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpmBA,ADqmBA;ACpmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA,ADmBA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/KA,ADgLA;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChdA,ADidA;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3EA,AD4EA;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA,AD+DA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\n/**\n * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n",
    "\ndefine('event',[], function() {\n\n  function Event() {\n    this.init();\n  }\n\n  Event.prototype = {\n    listeners: null,\n\n    init: function() {\n      this.listeners = [];\n    },\n\n    addListener: function(event, callback) {\n      if (!this.listeners[event]) {\n        this.listeners[event] = [];\n      }\n\n      this.listeners[event].push(callback);\n    },\n\n    removeListener: function(event, callback) {\n      if (!this.listeners[event]) {\n        return false;\n      }\n\n      for(var i = 0; i < this.listeners[event].length; i++) {\n        if (this.listeners[event][i] == callback) {\n          this.listeners[event] = this.listeners[event].splice(i, 1);\n          return true;\n        }\n      }\n    },\n\n    trigger: function(event, data) {\n      if (!this.listeners[event]) {\n        return false;\n      }\n\n      function callListener(listener) {\n        setTimeout(function() {\n          listener(data);\n        }, 0);\n      }\n\n      for(var i = 0; i < this.listeners[event].length; i++) {\n        callListener(this.listeners[event][i]);\n      }\n\n      return true;\n    }\n  }\n\n  return new Event(); \n\n});",
    "\ndefine('globals',[], function() {\n  return {\n    isiOS: function() {\n      return this.hasDeviceType(\"iOS\");\n    },\n\n    isPC: function() {\n      return this.hasDeviceType(\"PC\");\n    },\n\n    isMac: function() {\n      return this.hasDeviceType(\"Mac\");\n    },\n\n    hasDeviceType: function(type) {\n      return this.getDeviceType().indexOf(type) !== -1;\n    },\n\n    getDeviceType: function() {\n      if (localStorage.deviceType) {\n        //return JSON.parse(localStorage.deviceType);\n      }\n\n      var devices = [];\n      var userAgent = navigator.userAgent;\n\n      if (userAgent.match(/OS 7/g)) {\n        devices.push(\"iOS\");\n\n        if (userAgent.match(/iPad/g)) {\n          devices.push(\"iPad\");\n          devices.push(\"tablet\");\n        }\n        else if (userAgent.match(/iPhone/g)) {\n          devices.push(\"iPhone\");\n          devices.push(\"phone\");\n        }\n      }\n      else if (userAgent.match(/Mac/g)) {\n        devices.push(\"Mac\");\n        devices.push(\"computer\");\n      }\n      else\n      {\n        devices.push(\"PC\");\n        devices.push(\"computer\");\n      }\n\n\n\n      localStorage.deviceType = JSON.stringify(devices);\n\n      return devices;\n    },\n\n    setHTMLDevices: function() {\n      var devices = this.getDeviceType();\n\n      var body = document.body;\n      body.className = devices.join(\" \");\n    }\n\n  }\n});",
    "\ndefine('class',[], function() {\n\t/* Simple Javascript inheritance by John Resig */\n\n\tvar initializing = false,\n\t\tfnTest = /xyz/.test(function() {\n\t\t\txyz;\n\t\t}) ? /\\b_super\\b/ : /.*/;\n\n\t// The base CClass implementation (does nothing)\n\tthis.Class = function() {};\n\n\t// Create a new CLass that inherits from this class\n\tClass.extend = function(prop) {\n\t\tvar _super = this.prototype;\n\n\t\t// Instantiate a base class (but only create the instance, don't run the consutrcutor)\n\t\tinitializing = true;\n\t\tvar prototype = new this();\n\t\tinitializing = false;\n\n\t\t// Copy the properties over onto the new prototype\n\t\tfor (var name in prop) {\n\t\t\t// Check if we're overwriting an existing function\n\t\t\tprototype[name] = typeof prop[name] == \"function\" && typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n\t\t\t\t(function(name, fn) {\n\t\t\t\treturn function() {\t\t\t\t\n\t\t\t\t\tvar tmp = this._super;\n\n\t\t\t\t\t// Add a new ._super() method that is the same method\n\t\t\t\t\t// but on the super-class\n\t\t\t\t\tthis._super = _super[name];\n\n\t\t\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t\t\t// remove it when we're done executing\n\n\t\t\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\t\t\tthis._super = tmp;\n\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\t\t\t})(name, prop[name]) : prop[name];\n\t\t}\n\n\t\t// The dummy class constructor\n\n\t\tfunction Class() {\n\t\t\t// All construction is actually done in the init method\n\t\t\tif (!initializing && this.init)\n\t\t\t\tthis.init.apply(this, arguments);\n\t\t}\n\n\t\t// Populate our constructed prototype object\n\t\tClass.prototype = prototype;\n\n\t\t// Enforce the constructor to be what we expect\n\t\tClass.prototype.constructor = Class;\n\n\t\t// And make this class extendable\n\t\tClass.extend = arguments.callee;\n\n\t\treturn Class;\n\n\t};\n\n\treturn this.Class;\n});",
    "\ndefine('section',[\"class\"], function(Class) {\n\n\tvar Section = Class.extend({\n\t\tid: null,\n\t\telement: null,\n\n\t\tinit: function() {\n\t\t\tthis.element = document.getElementById(this.id);\n\t\t},\n\n\t\tshow: null,\n\t\thide: null,\n\n\t\tafterShow: function() {\n\t\t\tthis.element.style.display = \"block\";\n\t\t},\n\n\t\tafterHide: function() {\n\t\t\tthis.element.style.display = \"\";\n\t\t}\n\n\t});\n\n\treturn Section;\n});",
    "\ndefine('tapHandler',[], function() {\n  function TapHandler(element, options) {\n    this.init(element, options);\n  }\n\n  TapHandler.prototype = {\n    _element: null,\n    _options: null,\n\n    _distCutoff: 20,\n    _timeCutoff: 500,\n\n    _startTime: null,\n    _startX: null,\n    _startY: null,\n\n    _startScale: null,\n\n    _lastX: null,\n    _lastY: null,\n\n    _lastScale: null,\n\n    // Object with x and why of where the element is on the page\n    _offset: null,\n\n    _inTouch: false,\n    _inGesture: false,\n\n    _ignoreGestures: false,\n\n    init: function(element, options) {\n      this._element = element;\n      this._options = options;\n\n      // Replace with binded events\n      this._move = this._move.bind(this);\n      this._end = this._end.bind(this);\n      this._gestureChange = this._gestureChange.bind(this);\n      this._gestureEnd = this._gestureEnd.bind(this);\n\n      this._offset = {\n        x: element.offsetLeft,\n        y: element.offsetTop\n      };\n\n\n      this._element.addEventListener(\"mousedown\", this._start.bind(this));\n      this._element.addEventListener(\"touchstart\", this._start.bind(this));\n      this._element.addEventListener(\"gesturestart\", this._gestureStart.bind(this));\n    },\n\n    ignoreGestures: function(value) {\n      this._ignoreGestures = value;\n    },\n\n    _start: function(e) {\n      // Ignore these if we are currently gesturing\n      if (this._inGesture) {\n        return;\n      }\n\n      this._inTouch = true;\n\n      this._processEvent(e);\n      this._startTime = e.timeStamp;\n\n      this._startX = this._lastX = e.x;\n      this._startY = this._lastY = e.y;\n\n      if (this._options.start) {\n        this._options.start(e);\n      }\n\n      document.addEventListener(\"touchmove\", this._move);\n      document.addEventListener(\"mousemove\", this._move);\n\n      document.addEventListener(\"touchend\", this._end);\n      document.addEventListener(\"mouseup\", this._end);\n    },\n\n    _move: function(e) {\n      this._processEvent(e);\n\n      this._lastX = e.x;\n      this._lastY = e.y;\n\n      if (this._options.move) {\n        this._options.move(e);\n      }\n    },\n\n    _end: function(e) {\n      this._endTouchHandlers();\n\n      if (e) {\n        this._processEvent(e);\n\n        var dist = Math.sqrt(((e.x - this._startX) * (e.x - this._startX)) + ((e.y - this._startY) * (e.y - this._startY)));\n        if (dist < this._distCutoff && (e.timeStamp - this._startTime < this._timeCutoff)) {\n          if (this._options.tap) {\n            this._options.tap(e);\n          }\n        }\n      }\n\n      // It wasn't a tap, just an up\n      if (this._options.end) {\n        this._options.end(e);\n      }\n\n      this._inTouch = false;\n    },\n\n    _gestureStart: function(e) {\n      if (this._ignoreGestures) {\n        return;\n      }\n\n      this._inGesture = true;\n\n      // We need to end the touch\n      this._end();\n\n\n      this._processEvent(e);\n      this._processGesture(e);\n\n      this._startTime = e.timeStamp;\n\n      this._startX = this._lastX = e.x;\n      this._startY = this._lastY = e.y;\n\n      this._startScale = this._lastScale = e.scale;\n\n      document.addEventListener(\"gesturechange\", this._gestureChange);\n      document.addEventListener(\"gestureend\", this._gestureEnd);\n    },\n\n    _gestureChange: function(e) {\n      this._processEvent(e);\n      this._processGesture(e);\n\n      this._lastX = e.x;\n      this._lastY = e.y;\n      this._lastScale = e.scale;\n\n      //console.log(e.xFromLast, e.yFromLast);\n\n      this._lastScale = e.scale;\n\n      if (this._options.gesture) {\n        this._options.gesture(e);\n      }\n    },\n\n    _gestureEnd: function(e) {\n      this._processEvent(e);\n      this._processGesture(e);\n\n      document.removeEventListener(\"gesturechange\", this._gestureChange);\n      document.removeEventListener(\"gestureend\", this._gestureEnd);\n\n      this._inGesture = false;\n    },\n\n    // Unregister the regular touch handlers, used for when gestures start\n    _endTouchHandlers: function() {\n      document.removeEventListener(\"touchmove\", this._move);\n      document.removeEventListener(\"mousemove\", this._move);\n      document.removeEventListener(\"touchend\", this._end);\n      document.removeEventListener(\"mouseup\", this._end);\n    },\n\n    // Given an e, add things like x and y regardless of touch or mouse\n    _processEvent: function(e) {\n      // It's a touch\n      if (e.touches && e.touches.length > 0) {\n        // Use the last touch\n        e.x = e.touches[e.touches.length - 1].clientX;\n        e.y = e.touches[e.touches.length - 1].clientY;\n      } else if (e.clientX) {\n        // It's a click\n        e.x = e.clientX;\n        e.y = e.clientY;\n      } else if (e.pageX) {\n        // gesture events only get a layerx\n        e.x = e.pageX;\n        e.y = e.pageY;\n      } else {\n        // It's probably an end, there is no coords\n        e.x = this._lastX;\n        e.y = this._lastY;\n      }\n\n      e.distFromLeft = e.x - this._offset.x;\n      e.distFromTop = e.y - this._offset.y;\n\n      e.xFromLast = e.x - this._lastX;\n      e.yFromLast = e.y - this._lastY;\n    },\n\n    _processGesture: function(e) {\n      e.scaleFromLast = e.scale - this._lastScale;\n    }\n\n\n  };\n\n  return TapHandler;\n});",
    "\ndefine('sections/login',[\"event\", \"section\", \"tapHandler\"], function(Event, Section, TapHandler) {\n\n  var Login = Section.extend({\n    id: \"login\",\n\n    init: function() {\n      this._super();\n      console.log(\"login init\");\n      \n      var button = document.getElementById(\"loginbutton\");\n      new TapHandler(button, {tap: this._loginClicked.bind(this) });\n    },\n\n    _loginClicked: function() {\n      setTimeout(function() {\n        Event.trigger(\"login\");  \n      }, 400);\n    },\n\n    show: function() {\n      console.log(\"login shown\");\n    },\n\n    hide: function() {\n      console.log(\"login hidden\");\n    }, \n  });\n\n  return Login;\n\n});",
    "\ndefine('helpers',[], function() {\n  return {\n    parentEleWithClassname: function(ele, className) {\n      if (ele == null || !ele.classList) {\n        return false;\n      }\n\n      if (ele.classList.contains(className)) {\n        return ele;\n      }\n\n      return this.parentEleWithClassname(ele.parentNode, className);\n    },\n\n\n    screenToWorld: function(settings, x, y) {\n      return {\n        x: (x - settings.offsetX) / settings.scale,\n        y: (y - settings.offsetY) / settings.scale\n      };\n    },\n\n    worldToScreen: function(settings, x, y) {\n      return {\n        x: (x) * settings.scale + settings.offsetX,\n        y: (y) * settings.scale + settings.offsetY\n      };\n    },\n\n    getCurveControlPoints: function(knots) {\n\n      function getFirstControlPoints(rhs) {\n        var n = rhs.length;\n        var x = new Array(n); // Solution vector\n        var tmp = new Array(n); // Temp workspace\n\n        var b = 2.0;\n        x[0] = rhs[0] / b;\n\n        for (var i = 1; i < n; i++) { // Decomposition and forward substitution\n          tmp[i] = 1 / b;\n          b = (i < n - 1 ? 4 : 3.5) - tmp[i];\n          x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (var i = 1; i < n; i++) {\n          x[n - i - 1] -= tmp[n - i] * x[n - i]; // backsubstituion\n        }\n\n        return x;\n      };\n\n\n      var n = knots.length - 1;\n\n      var firstControlPoints = [];\n      var secondControlPoints = [];\n\n      if (n < 1) {\n        console.error(\"Must have at least two knots\");\n        return;\n      }\n\n      if (n == 1) {\n        // Special case: should be a line\n        firstControlPoints.push({});\n        firstControlPoints[0].x = (2 * knots[0].x + knots[1].x) / 3;\n        firstControlPoints[0].y = (2 * knots[0].y + knots[1].y) / 3;\n\n        secondControlPoints.push({});\n        secondControlPoints[0].x = 2 * firstControlPoints[0].x - knots[0].x;\n        secondControlPoints[0].y = 2 * firstControlPoints[0].y - knots[0].y;\n\n        return [{\n          first: firstControlPoints[0],\n          second: secondControlPoints[0]\n        }];\n      }\n\n      // Calculate first Bezier control points\n      // Right hand side vector\n      var rhs = new Array(n);\n\n\n      // Set right hand side X values\n      for (var i = 1; i < n - 1; ++i) {\n        rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n      }\n\n      rhs[0] = knots[0].x + 2 * knots[1].x;\n      rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2;\n\n      // Get first control points x-values\n      var x = getFirstControlPoints(rhs);\n\n      // Set right hand side Y values\n      for (var i = 1; i < n - 1; ++i) {\n        rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n      }\n\n      rhs[0] = knots[0].y + 2 * knots[1].y;\n      rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2;\n\n      // Get first control points Y-values\n      var y = getFirstControlPoints(rhs);\n\n      // Fill output arrays.\n      firstControlPoints = new Array(n);\n      secondControlPoints = new Array(n);\n\n      for (var i = 0; i < n; ++i) {\n        // First control point\n        firstControlPoints[i] = {\n          x: x[i],\n          y: y[i]\n        };\n\n        // Second control point\n        if (i < n - 1) {\n          secondControlPoints[i] = {\n            x: 2 * knots[i + 1].x - x[i + 1],\n            y: 2 * knots[i + 1].y - y[i + 1]\n          };\n        } else {\n          secondControlPoints[i] = {\n            x: (knots[n].x + x[n - 1]) / 2,\n            y: (knots[n].y + y[n - 1]) / 2\n          };\n        }\n      }\n\n      var controlPoints = new Array(n);\n      for (var i = 0; i < n; ++i) {\n        controlPoints[i] = {\n          first: firstControlPoints[i],\n          second: secondControlPoints[i]\n        }\n      }\n\n      return controlPoints;\n    },\n  };\n});",
    "\n/*jshint globalstrict: true*/\n'use strict';\n/**\n * An initialization file that checks for conditions, removes console.log and warn, etc\n */\nvar idbModules = {/*DEBUG: true*/};\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules) {\n    /**\n     * A utility method to callback onsuccess, onerror, etc as soon as the calling function's context is over\n     * @param {Object} fn\n     * @param {Object} context\n     * @param {Object} argArray\n     */\n\n    function callback(fn, context, event, func) {\n        //window.setTimeout(function(){\n        event.target = context;\n        (typeof context[fn] === \"function\") && context[fn].apply(context, [event]);\n        (typeof func === \"function\") && func();\n        //}, 1);\n    }\n\n    /**\n     * Throws a new DOM Exception,\n     * @param {Object} name\n     * @param {Object} message\n     * @param {Object} error\n     */\n\n    function throwDOMException(name, message, error) {\n        var e = new DOMException.constructor(0, message);\n        e.name = name;\n        e.message = message;\n        if (idbModules.DEBUG) {\n            console.log(name, message, error, e);\n            console.trace && console.trace();\n        }\n        throw e;\n    }\n\n    /**\n     * Shim the DOMStringList object.\n     *\n     */\n    var StringList = function() {\n        this.length = 0;\n        this._items = [];\n        //Internal functions on the prototype have been made non-enumerable below.\n        if (Object.defineProperty) {\n            Object.defineProperty(this, '_items', {\n                enumerable: false\n            });\n        }\n    };\n    StringList.prototype = {\n        // Interface.\n        contains: function(str) {\n            return -1 !== this._items.indexOf(str);\n        },\n        item: function(key) {\n            return this._items[key];\n        },\n\n        // Helpers. Should only be used internally.\n        indexOf: function(str) {\n            return this._items.indexOf(str);\n        },\n        push: function(item) {\n            this._items.push(item);\n            this.length += 1;\n            for (var i = 0; i < this._items.length; i++) {\n                this[i] = this._items[i];\n            }\n        },\n        splice: function( /*index, howmany, item1, ..., itemX*/ ) {\n            this._items.splice.apply(this._items, arguments);\n            this.length = this._items.length;\n            for (var i in this) {\n                if (i === String(parseInt(i, 10))) {\n                    delete this[i];\n                }\n            }\n            for (i = 0; i < this._items.length; i++) {\n                this[i] = this._items[i];\n            }\n        }\n    };\n    if (Object.defineProperty) {\n        for (var i in {\n            'indexOf': false,\n            'push': false,\n            'splice': false\n        }) {\n            Object.defineProperty(StringList.prototype, i, {\n                enumerable: false\n            });\n        }\n    }\n    idbModules.util = {\n        \"throwDOMException\": throwDOMException,\n        \"callback\": callback,\n        \"quote\": function(arg) {\n            return \"'\" + arg + \"'\";\n        },\n        \"StringList\": StringList\n    };\n}(idbModules));\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n    /**\n     * Implementation of the Structured Cloning Algorithm.  Supports the\n     * following object types:\n     * - Blob\n     * - Boolean\n     * - Date object\n     * - File object (deserialized as Blob object).\n     * - Number object\n     * - RegExp object\n     * - String object\n     * This is accomplished by doing the following:\n     * 1) Using the cycle/decycle functions from:\n     *    https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n     * 2) Serializing/deserializing objects to/from string that don't work with\n     *    JSON.stringify and JSON.parse by using object specific logic (eg use \n     *    the FileReader API to convert a Blob or File object to a data URL.   \n     * 3) JSON.stringify and JSON.parse do the final conversion to/from string.\n     */\n    var Sca = (function(){\n        return {\n            decycle: function(object, callback) {\n                //From: https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n                // Contains additional logic to convert the following object types to string\n                // so that they can properly be encoded using JSON.stringify:\n                //  *Boolean\n                //  *Date\n                //  *File\n                //  *Blob\n                //  *Number\n                //  *Regex\n                // Make a deep copy of an object or array, assuring that there is at most\n                // one instance of each object or array in the resulting structure. The\n                // duplicate references (which might be forming cycles) are replaced with\n                // an object of the form\n                //      {$ref: PATH}\n                // where the PATH is a JSONPath string that locates the first occurance.\n                // So,\n                //      var a = [];\n                //      a[0] = a;\n                //      return JSON.stringify(JSON.decycle(a));\n                // produces the string '[{\"$ref\":\"$\"}]'.\n\n                // JSONPath is used to locate the unique object. $ indicates the top level of\n                // the object or array. [NUMBER] or [STRING] indicates a child member or\n                // property.\n\n                var objects = [],   // Keep a reference to each unique object or array\n                paths = [],     // Keep the path to each unique object or array\n                queuedObjects = [],\n                returnCallback = callback;\n\n                /**\n                 * Check the queue to see if all objects have been processed.\n                 * if they have, call the callback with the converted object.\n                 */\n                function checkForCompletion() {\n                    if (queuedObjects.length === 0) {\n                        returnCallback(derezObj);\n                    }    \n                }\n\n                /**\n                 * Convert a blob to a data URL.\n                 * @param {Blob} blob to convert.\n                 * @param {String} path of blob in object being encoded.\n                 */\n                function readBlobAsDataURL(blob, path) {\n                    var reader = new FileReader();\n                    reader.onloadend = function(loadedEvent) {\n                        var dataURL = loadedEvent.target.result;\n                        var blobtype = 'blob'; \n                        if (blob instanceof File) {\n                            //blobtype = 'file';\n                        }\n                        updateEncodedBlob(dataURL, path, blobtype);\n                    };\n                    reader.readAsDataURL(blob);\n                }\n                \n                /**\n                 * Async handler to update a blob object to a data URL for encoding.\n                 * @param {String} dataURL\n                 * @param {String} path\n                 * @param {String} blobtype - file if the blob is a file; blob otherwise\n                 */\n                function updateEncodedBlob(dataURL, path, blobtype) {\n                    var encoded = queuedObjects.indexOf(path);\n                    path = path.replace('$','derezObj');\n                    eval(path+'.$enc=\"'+dataURL+'\"');\n                    eval(path+'.$type=\"'+blobtype+'\"');\n                    queuedObjects.splice(encoded, 1);\n                    checkForCompletion();\n                }\n\n                function derez(value, path) {\n\n                    // The derez recurses through the object, producing the deep copy.\n\n                    var i,          // The loop counter\n                    name,       // Property name\n                    nu;         // The new object or array\n\n                    // typeof null === 'object', so go on if this value is really an object but not\n                    // one of the weird builtin objects.\n\n                    if (typeof value === 'object' && value !== null &&\n                        !(value instanceof Boolean) &&\n                        !(value instanceof Date)    &&\n                        !(value instanceof Number)  &&\n                        !(value instanceof RegExp)  &&\n                        !(value instanceof Blob)  &&\n                        !(value instanceof String)) {\n\n                        // If the value is an object or array, look to see if we have already\n                        // encountered it. If so, return a $ref/path object. This is a hard way,\n                        // linear search that will get slower as the number of unique objects grows.\n\n                        for (i = 0; i < objects.length; i += 1) {\n                            if (objects[i] === value) {\n                                return {$ref: paths[i]};\n                            }\n                        }\n\n                        // Otherwise, accumulate the unique value and its path.\n\n                        objects.push(value);\n                        paths.push(path);\n\n                        // If it is an array, replicate the array.\n\n                        if (Object.prototype.toString.apply(value) === '[object Array]') {\n                            nu = [];\n                            for (i = 0; i < value.length; i += 1) {\n                                nu[i] = derez(value[i], path + '[' + i + ']');\n                            }\n                        } else {\n                            // If it is an object, replicate the object.\n                            nu = {};\n                            for (name in value) {\n                                if (Object.prototype.hasOwnProperty.call(value, name)) {\n                                    nu[name] = derez(value[name],\n                                     path + '[' + JSON.stringify(name) + ']');\n                                }\n                            }\n                        }\n\n                        return nu;\n                    } else if (value instanceof Blob) {\n                        //Queue blob for conversion\n                        queuedObjects.push(path);\n                        readBlobAsDataURL(value, path);\n                    } else if (value instanceof Boolean) {\n                        value = {\n                            '$type': 'bool',\n                            '$enc': value.toString()\n                        };\n                    } else if (value instanceof Date) {\n                        value = {\n                            '$type': 'date',\n                            '$enc': value.getTime()\n                        };\n                    } else if (value instanceof Number) {\n                        value = {\n                            '$type': 'num',\n                            '$enc': value.toString()\n                        };\n                    } else if (value instanceof RegExp) {\n                        value = {\n                            '$type': 'regex',\n                            '$enc': value.toString()\n                        }; \n                    }\n                    return value;\n                }\n                var derezObj = derez(object, '$');\n                checkForCompletion();\n            },\n                \n            retrocycle: function retrocycle($) {\n                //From: https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\n                // Contains additional logic to convert strings to the following object types \n                // so that they can properly be decoded:\n                //  *Boolean\n                //  *Date\n                //  *File\n                //  *Blob\n                //  *Number\n                //  *Regex\n                // Restore an object that was reduced by decycle. Members whose values are\n                // objects of the form\n                //      {$ref: PATH}\n                // are replaced with references to the value found by the PATH. This will\n                // restore cycles. The object will be mutated.\n\n                // The eval function is used to locate the values described by a PATH. The\n                // root object is kept in a $ variable. A regular expression is used to\n                // assure that the PATH is extremely well formed. The regexp contains nested\n                // * quantifiers. That has been known to have extremely bad performance\n                // problems on some browsers for very long strings. A PATH is expected to be\n                // reasonably short. A PATH is allowed to belong to a very restricted subset of\n                // Goessner's JSONPath.\n\n                // So,\n                //      var s = '[{\"$ref\":\"$\"}]';\n                //      return JSON.retrocycle(JSON.parse(s));\n                // produces an array containing a single element which is the array itself.\n\n                var px = /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n                \n                /**\n                 * Converts the specified data URL to a Blob object\n                 * @param {String} dataURL to convert to a Blob\n                 * @returns {Blob} the converted Blob object\n                 */\n                function dataURLToBlob(dataURL) {\n                    var BASE64_MARKER = ';base64,',\n                        contentType,\n                        parts,\n                        raw;\n                    if (dataURL.indexOf(BASE64_MARKER) === -1) {\n                        parts = dataURL.split(',');\n                        contentType = parts[0].split(':')[1];\n                        raw = parts[1];\n\n                        return new Blob([raw], {type: contentType});\n                    }\n\n                    parts = dataURL.split(BASE64_MARKER);\n                    contentType = parts[0].split(':')[1];\n                    raw = window.atob(parts[1]);\n                    var rawLength = raw.length;\n                    var uInt8Array = new Uint8Array(rawLength);\n\n                    for (var i = 0; i < rawLength; ++i) {\n                        uInt8Array[i] = raw.charCodeAt(i);\n                    }\n                    return new Blob([uInt8Array.buffer], {type: contentType});\n                }\n                \n                function rez(value) {\n                    // The rez function walks recursively through the object looking for $ref\n                    // properties. When it finds one that has a value that is a path, then it\n                    // replaces the $ref object with a reference to the value that is found by\n                    // the path.\n\n                    var i, item, name, path;\n\n                    if (value && typeof value === 'object') {\n                        if (Object.prototype.toString.apply(value) === '[object Array]') {\n                            for (i = 0; i < value.length; i += 1) {\n                                item = value[i];\n                                if (item && typeof item === 'object') {\n                                    path = item.$ref;\n                                    if (typeof path === 'string' && px.test(path)) {\n                                        value[i] = eval(path);\n                                    } else {\n                                        value[i] = rez(item);\n                                    }\n                                }\n                            }\n                        } else {\n                            if (value.$type !== undefined) {\n                                switch(value.$type) {\n                                    case 'blob':\n                                    case 'file': \n                                        value = dataURLToBlob(value.$enc);\n                                        break;\n                                    case 'bool':\n                                        value = Boolean(value.$enc === 'true');\n                                        break;\n                                    case 'date':\n                                        value = new Date(value.$enc);\n                                        break;\n                                    case 'num':\n                                        value = Number(value.$enc);\n                                        break;\n                                    case 'regex':\n                                        value = eval(value.$enc);\n                                        break;\n                                }\n                            } else {\n                                for (name in value) {\n                                    if (typeof value[name] === 'object') {\n                                        item = value[name];\n                                        if (item) {\n                                            path = item.$ref;\n                                            if (typeof path === 'string' && px.test(path)) {\n                                                value[name] = eval(path);\n                                            } else {\n                                                value[name] = rez(item);\n                                            }\n                                        }\n                                    }   \n                                }\n                            }\n                        }\n                    }\n                    return value;\n                }\n                rez($);\n                return $;\n\n            },\n\n            /**\n             * Encode the specified object as a string.  Because of the asynchronus\n             * conversion of Blob/File to string, the encode function requires\n             * a callback\n             * @param {Object} val the value to convert.\n             * @param {function} callback the function to call once conversion is\n             * complete.  The callback gets called with the converted value.\n             */\n            \"encode\": function(val, callback){\n                function finishEncode(val) {\n                    callback(JSON.stringify(val));\n                }\n                this.decycle(val, finishEncode);                        \n            },\n                    \n            /**\n             * Deserialize the specified string to an object\n             * @param {String} val the serialized string\n             * @returns {Object} the deserialized object\n             */\n            \"decode\": function(val){\n                return this.retrocycle(JSON.parse(val));\n            }\n        };\n    }());\n    idbModules.Sca = Sca;\n}(idbModules));\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n    /**\n     * Encodes the keys and values based on their types. This is required to maintain collations\n     */\n    var collations = [\"\", \"number\", \"string\", \"boolean\", \"object\", \"undefined\"];\n    var getGenericEncoder = function(){\n        return {\n            \"encode\": function(key){\n                return collations.indexOf(typeof key) + \"-\" + JSON.stringify(key);\n            },\n            \"decode\": function(key){\n                if (typeof key === \"undefined\") {\n                    return undefined;\n                }\n                else {\n                    return JSON.parse(key.substring(2));\n                }\n            }\n        };\n    };\n    \n    var types = {\n        \"number\": getGenericEncoder(\"number\"), // decoder will fail for NaN\n        \"boolean\": getGenericEncoder(),\n        \"object\": getGenericEncoder(),\n        \"string\": {\n            \"encode\": function(key){\n                return collations.indexOf(\"string\") + \"-\" + key;\n            },\n            \"decode\": function(key){\n                return \"\" + key.substring(2);\n            }\n        },\n        \"undefined\": {\n            \"encode\": function(key){\n                return collations.indexOf(\"undefined\") + \"-undefined\";\n            },\n            \"decode\": function(key){\n                return undefined;\n            }\n        }\n    };\n  \n    var Key = (function(){\n        return {\n            encode: function(key){\n                return types[typeof key].encode(key);\n            },\n            decode: function(key){\n                return types[collations[key.substring(0, 1)]].decode(key);\n            }\n        };\n    }());\n    idbModules.Key = Key;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules, undefined){\n  // The event interface used for IndexedBD Actions.\n  var Event = function(type, debug){\n    // Returning an object instead of an even as the event's target cannot be set to IndexedDB Objects\n    // We still need to have event.target.result as the result of the IDB request\n    return {\n      \"type\": type,\n      debug: debug,\n      bubbles: false,\n      cancelable: false,\n      eventPhase: 0,\n      timeStamp: new Date()\n    };\n  };\n  idbModules.Event = Event;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n\n    /**\n     * The IDBRequest Object that is returns for all async calls\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#request-api\n     */\n    var IDBRequest = function(){\n        this.onsuccess = this.onerror = this.result = this.error = this.source = this.transaction = null;\n        this.readyState = \"pending\";\n    };\n    /**\n     * The IDBOpen Request called when a database is opened\n     */\n    var IDBOpenRequest = function(){\n        this.onblocked = this.onupgradeneeded = null;\n    };\n    IDBOpenRequest.prototype = IDBRequest;\n    \n    idbModules.IDBRequest = IDBRequest;\n    idbModules.IDBOpenRequest = IDBOpenRequest;\n    \n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules, undefined){\n    /**\n     * The IndexedDB KeyRange object\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n     * @param {Object} lower\n     * @param {Object} upper\n     * @param {Object} lowerOpen\n     * @param {Object} upperOpen\n     */\n    var IDBKeyRange = function(lower, upper, lowerOpen, upperOpen){\n        this.lower = lower;\n        this.upper = upper;\n        this.lowerOpen = lowerOpen;\n        this.upperOpen = upperOpen;\n    };\n    \n    IDBKeyRange.only = function(value){\n        return new IDBKeyRange(value, value, false, false);\n    };\n    \n    IDBKeyRange.lowerBound = function(value, open){\n        return new IDBKeyRange(value, undefined, open, undefined);\n    };\n    IDBKeyRange.upperBound = function(value){\n        return new IDBKeyRange(undefined, value, undefined, open);\n    };\n    IDBKeyRange.bound = function(lower, upper, lowerOpen, upperOpen){\n        return new IDBKeyRange(lower, upper, lowerOpen, upperOpen);\n    };\n    \n    idbModules.IDBKeyRange = IDBKeyRange;\n    \n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules, undefined){\n    /**\n     * The IndexedDB Cursor Object\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBCursor\n     * @param {Object} range\n     * @param {Object} direction\n     * @param {Object} idbObjectStore\n     * @param {Object} cursorRequest\n     */\n    function IDBCursor(range, direction, idbObjectStore, cursorRequest, keyColumnName, valueColumnName){\n        this.__range = range;\n        this.source = this.__idbObjectStore = idbObjectStore;\n        this.__req = cursorRequest;\n        \n        this.key = undefined;\n        this.direction = direction;\n        \n        this.__keyColumnName = keyColumnName;\n        this.__valueColumnName = valueColumnName;\n        \n        if (!this.source.transaction.__active) {\n            idbModules.util.throwDOMException(\"TransactionInactiveError - The transaction this IDBObjectStore belongs to is not active.\");\n        }\n        // Setting this to -1 as continue will set it to 0 anyway\n        this.__offset = -1;\n\n        this.__lastKeyContinued = undefined; // Used when continuing with a key\n\n        this[\"continue\"]();\n    }\n    \n    IDBCursor.prototype.__find = function(key, tx, success, error){\n        var me = this;\n        var sql = [\"SELECT * FROM \", idbModules.util.quote(me.__idbObjectStore.name)];\n        var sqlValues = [];\n        sql.push(\"WHERE \", me.__keyColumnName, \" NOT NULL\");\n        if (me.__range && (me.__range.lower || me.__range.upper)) {\n            sql.push(\"AND\");\n            if (me.__range.lower) {\n                sql.push(me.__keyColumnName + (me.__range.lowerOpen ? \" >\" : \" >= \") + \" ?\");\n                sqlValues.push(idbModules.Key.encode(me.__range.lower));\n            }\n            (me.__range.lower && me.__range.upper) && sql.push(\"AND\");\n            if (me.__range.upper) {\n                sql.push(me.__keyColumnName + (me.__range.upperOpen ? \" < \" : \" <= \") + \" ?\");\n                sqlValues.push(idbModules.Key.encode(me.__range.upper));\n            }\n        }\n        if (typeof key !== \"undefined\") {\n            me.__lastKeyContinued = key;\n            me.__offset = 0;\n        }\n        if (me.__lastKeyContinued !== undefined) {\n            sql.push(\"AND \" + me.__keyColumnName + \" >= ?\");\n            sqlValues.push(idbModules.Key.encode(me.__lastKeyContinued));\n        }\n        sql.push(\"ORDER BY \", me.__keyColumnName);\n        sql.push(\"LIMIT 1 OFFSET \" + me.__offset);\n        idbModules.DEBUG && console.log(sql.join(\" \"), sqlValues);\n        tx.executeSql(sql.join(\" \"), sqlValues, function(tx, data){\n            if (data.rows.length === 1) {\n                var key = idbModules.Key.decode(data.rows.item(0)[me.__keyColumnName]);\n                var val = me.__valueColumnName === \"value\" ? idbModules.Sca.decode(data.rows.item(0)[me.__valueColumnName]) : idbModules.Key.decode(data.rows.item(0)[me.__valueColumnName]);\n                success(key, val);\n            }\n            else {\n                idbModules.DEBUG && console.log(\"Reached end of cursors\");\n                success(undefined, undefined);\n            }\n        }, function(tx, data){\n            idbModules.DEBUG && console.log(\"Could not execute Cursor.continue\");\n            error(data);\n        });\n    };\n    \n    IDBCursor.prototype[\"continue\"] = function(key){\n        var me = this;\n        this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__offset++;\n            me.__find(key, tx, function(key, val){\n                me.key = key;\n                me.value = val;\n                success(typeof me.key !== \"undefined\" ? me : undefined, me.__req);\n            }, function(data){\n                error(data);\n            });\n        });\n    };\n    \n    IDBCursor.prototype.advance = function(count){\n        if (count <= 0) {\n            idbModules.util.throwDOMException(\"Type Error - Count is invalid - 0 or negative\", count);\n        }\n        var me = this;\n        this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__offset += count;\n            me.__find(undefined, tx, function(key, value){\n                me.key = key;\n                me.value = value;\n                success(typeof me.key !== \"undefined\" ? me : undefined, me.__req);\n            }, function(data){\n                error(data);\n            });\n        });\n    };\n    \n    IDBCursor.prototype.update = function(valueToUpdate){\n        var me = this,\n            request = this.__idbObjectStore.transaction.__createRequest(function(){}); //Stub request\n        idbModules.Sca.encode(valueToUpdate, function(encoded) {\n            this.__idbObjectStore.__pushToQueue(request, function(tx, args, success, error){\n                me.__find(undefined, tx, function(key, value){\n                    var sql = \"UPDATE \" + idbModules.util.quote(me.__idbObjectStore.name) + \" SET value = ? WHERE key = ?\";\n                    idbModules.DEBUG && console.log(sql, encoded, key);\n                    tx.executeSql(sql, [idbModules.Sca.encode(encoded), idbModules.Key.encode(key)], function(tx, data){\n                        if (data.rowsAffected === 1) {\n                            success(key);\n                        }\n                        else {\n                            error(\"No rowns with key found\" + key);\n                        }\n                    }, function(tx, data){\n                        error(data);\n                    });\n                }, function(data){\n                    error(data);\n                });\n            });\n        });\n        return request;\n    };\n    \n    IDBCursor.prototype[\"delete\"] = function(){\n        var me = this;\n        return this.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__find(undefined, tx, function(key, value){\n                var sql = \"DELETE FROM  \" + idbModules.util.quote(me.__idbObjectStore.name) + \" WHERE key = ?\";\n                idbModules.DEBUG && console.log(sql, key);\n                tx.executeSql(sql, [idbModules.Key.encode(key)], function(tx, data){\n                    if (data.rowsAffected === 1) {\n                        success(undefined);\n                    }\n                    else {\n                        error(\"No rowns with key found\" + key);\n                    }\n                }, function(tx, data){\n                    error(data);\n                });\n            }, function(data){\n                error(data);\n            });\n        });\n    };\n    \n    idbModules.IDBCursor = IDBCursor;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules, undefined){\n    /**\n     * IDB Index\n     * http://www.w3.org/TR/IndexedDB/#idl-def-IDBIndex\n     * @param {Object} name;\n     * @param {Object} objectStore;\n     */\n    function IDBIndex(indexName, idbObjectStore){\n        this.indexName = this.name = indexName;\n        this.__idbObjectStore = this.objectStore = this.source = idbObjectStore;\n        \n        var indexList = idbObjectStore.__storeProps && idbObjectStore.__storeProps.indexList;\n        indexList && (indexList = JSON.parse(indexList));\n        \n        this.keyPath = ((indexList && indexList[indexName] && indexList[indexName].keyPath) || indexName);\n        ['multiEntry','unique'].forEach(function(prop){\n            this[prop] = !!indexList && !!indexList[indexName] && !!indexList[indexName].optionalParams && !!indexList[indexName].optionalParams[prop];\n        }, this);\n    }\n    \n    IDBIndex.prototype.__createIndex = function(indexName, keyPath, optionalParameters){\n        var me = this;\n        var transaction = me.__idbObjectStore.transaction;\n        transaction.__addToTransactionQueue(function(tx, args, success, failure){\n            me.__idbObjectStore.__getStoreProps(tx, function(){\n                function error(){\n                    idbModules.util.throwDOMException(0, \"Could not create new index\", arguments);\n                }\n                if (transaction.mode !== 2) {\n                    idbModules.util.throwDOMException(0, \"Invalid State error, not a version transaction\", me.transaction);\n                }\n                var idxList = JSON.parse(me.__idbObjectStore.__storeProps.indexList);\n                if (typeof idxList[indexName] !== \"undefined\") {\n                    idbModules.util.throwDOMException(0, \"Index already exists on store\", idxList);\n                }\n                var columnName = indexName;\n                idxList[indexName] = {\n                    \"columnName\": columnName,\n                    \"keyPath\": keyPath,\n                    \"optionalParams\": optionalParameters\n                };\n                // For this index, first create a column\n                me.__idbObjectStore.__storeProps.indexList = JSON.stringify(idxList);\n                var sql = [\"ALTER TABLE\", idbModules.util.quote(me.__idbObjectStore.name), \"ADD\", columnName, \"BLOB\"].join(\" \");\n                idbModules.DEBUG && console.log(sql);\n                tx.executeSql(sql, [], function(tx, data){\n                    // Once a column is created, put existing records into the index\n                    tx.executeSql(\"SELECT * FROM \" + idbModules.util.quote(me.__idbObjectStore.name), [], function(tx, data){\n                        (function initIndexForRow(i){\n                            if (i < data.rows.length) {\n                                try {\n                                    var value = idbModules.Sca.decode(data.rows.item(i).value);\n                                    var indexKey = eval(\"value['\" + keyPath + \"']\");\n                                    tx.executeSql(\"UPDATE \" + idbModules.util.quote(me.__idbObjectStore.name) + \" set \" + columnName + \" = ? where key = ?\", [idbModules.Key.encode(indexKey), data.rows.item(i).key], function(tx, data){\n                                        initIndexForRow(i + 1);\n                                    }, error);\n                                } \n                                catch (e) {\n                                    // Not a valid value to insert into index, so just continue\n                                    initIndexForRow(i + 1);\n                                }\n                            }\n                            else {\n                                idbModules.DEBUG && console.log(\"Updating the indexes in table\", me.__idbObjectStore.__storeProps);\n                                tx.executeSql(\"UPDATE __sys__ set indexList = ? where name = ?\", [me.__idbObjectStore.__storeProps.indexList, me.__idbObjectStore.name], function(){\n                                    me.__idbObjectStore.__setReadyState(\"createIndex\", true);\n                                    success(me);\n                                }, error);\n                            }\n                        }(0));\n                    }, error);\n                }, error);\n            }, \"createObjectStore\");\n        });\n    };\n    \n    IDBIndex.prototype.openCursor = function(range, direction){\n        var cursorRequest = new idbModules.IDBRequest();\n        var cursor = new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, \"value\");\n        return cursorRequest;\n    };\n    \n    IDBIndex.prototype.openKeyCursor = function(range, direction){\n        var cursorRequest = new idbModules.IDBRequest();\n        var cursor = new idbModules.IDBCursor(range, direction, this.source, cursorRequest, this.indexName, \"key\");\n        return cursorRequest;\n    };\n    \n    IDBIndex.prototype.__fetchIndexData = function(key, opType){\n        var me = this;\n        return me.__idbObjectStore.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            var sql = [\"SELECT * FROM \", idbModules.util.quote(me.__idbObjectStore.name), \" WHERE\", me.indexName, \"NOT NULL\"];\n            var sqlValues = [];\n            if (typeof key !== \"undefined\") {\n                sql.push(\"AND\", me.indexName, \" = ?\");\n                sqlValues.push(idbModules.Key.encode(key));\n            }\n            idbModules.DEBUG && console.log(\"Trying to fetch data for Index\", sql.join(\" \"), sqlValues);\n            tx.executeSql(sql.join(\" \"), sqlValues, function(tx, data){\n                var d;\n                if (typeof opType === \"count\") {\n                    d = data.rows.length;\n                }\n                else \n                    if (data.rows.length === 0) {\n                        d = undefined;\n                    }\n                    else \n                        if (opType === \"key\") {\n                            d = idbModules.Key.decode(data.rows.item(0).key);\n                        }\n                        else { // when opType is value\n                            d = idbModules.Sca.decode(data.rows.item(0).value);\n                        }\n                success(d);\n            }, error);\n        });\n    };\n    \n    IDBIndex.prototype.get = function(key){\n        return this.__fetchIndexData(key, \"value\");\n    };\n    \n    IDBIndex.prototype.getKey = function(key){\n        return this.__fetchIndexData(key, \"key\");\n    };\n    \n    IDBIndex.prototype.count = function(key){\n        return this.__fetchIndexData(key, \"count\");\n    };\n    \n    idbModules.IDBIndex = IDBIndex;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n\n    /**\n     * IndexedDB Object Store\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBObjectStore\n     * @param {Object} name\n     * @param {Object} transaction\n     */\n    var IDBObjectStore = function(name, idbTransaction, ready){\n        this.name = name;\n        this.transaction = idbTransaction;\n        this.__ready = {};\n        this.__setReadyState(\"createObjectStore\", typeof ready === \"undefined\" ? true : ready);\n        this.indexNames = new idbModules.util.StringList();\n    };\n    \n    /**\n     * Need this flag as createObjectStore is synchronous. So, we simply return when create ObjectStore is called\n     * but do the processing in the background. All other operations should wait till ready is set\n     * @param {Object} val\n     */\n    IDBObjectStore.prototype.__setReadyState = function(key, val){\n        this.__ready[key] = val;\n    };\n    \n    /**\n     * Called by all operations on the object store, waits till the store is ready, and then performs the operation\n     * @param {Object} callback\n     */\n    IDBObjectStore.prototype.__waitForReady = function(callback, key){\n        var ready = true;\n        if (typeof key !== \"undefined\") {\n            ready = (typeof this.__ready[key] === \"undefined\") ? true : this.__ready[key];\n        }\n        else {\n            for (var x in this.__ready) {\n                if (!this.__ready[x]) {\n                    ready = false;\n                }\n            }\n        }\n        \n        if (ready) {\n            callback();\n        }\n        else {\n            idbModules.DEBUG && console.log(\"Waiting for to be ready\", key);\n            var me = this;\n            window.setTimeout(function(){\n                me.__waitForReady(callback, key);\n            }, 100);\n        }\n    };\n    \n    /**\n     * Gets (and optionally caches) the properties like keyPath, autoincrement, etc for this objectStore\n     * @param {Object} callback\n     */\n    IDBObjectStore.prototype.__getStoreProps = function(tx, callback, waitOnProperty){\n        var me = this;\n        this.__waitForReady(function(){\n            if (me.__storeProps) {\n                idbModules.DEBUG && console.log(\"Store properties - cached\", me.__storeProps);\n                callback(me.__storeProps);\n            }\n            else {\n                tx.executeSql(\"SELECT * FROM __sys__ where name = ?\", [me.name], function(tx, data){\n                    if (data.rows.length !== 1) {\n                        callback();\n                    }\n                    else {\n                        me.__storeProps = {\n                            \"name\": data.rows.item(0).name,\n                            \"indexList\": data.rows.item(0).indexList,\n                            \"autoInc\": data.rows.item(0).autoInc,\n                            \"keyPath\": data.rows.item(0).keyPath\n                        };\n                        idbModules.DEBUG && console.log(\"Store properties\", me.__storeProps);\n                        callback(me.__storeProps);\n                    }\n                }, function(){\n                    callback();\n                });\n            }\n        }, waitOnProperty);\n    };\n    \n    /**\n     * From the store properties and object, extracts the value for the key in hte object Store\n     * If the table has auto increment, get the next in sequence\n     * @param {Object} props\n     * @param {Object} value\n     * @param {Object} key\n     */\n    IDBObjectStore.prototype.__deriveKey = function(tx, value, key, callback){\n        function getNextAutoIncKey(){\n            tx.executeSql(\"SELECT * FROM sqlite_sequence where name like ?\", [me.name], function(tx, data){\n                if (data.rows.length !== 1) {\n                    callback(0);\n                }\n                else {\n                    callback(data.rows.item(0).seq);\n                }\n            }, function(tx, error){\n                idbModules.util.throwDOMException(0, \"Data Error - Could not get the auto increment value for key\", error);\n            });\n        }\n        \n        var me = this;\n        me.__getStoreProps(tx, function(props){\n            if (!props) {\n                idbModules.util.throwDOMException(0, \"Data Error - Could not locate defination for this table\", props);\n            }\n            if (props.keyPath) {\n                if (typeof key !== \"undefined\") {\n                    idbModules.util.throwDOMException(0, \"Data Error - The object store uses in-line keys and the key parameter was provided\", props);\n                }\n                if (value) {\n                    try {\n                        var primaryKey = eval(\"value['\" + props.keyPath + \"']\");\n                        if (!primaryKey) {\n                            if (props.autoInc === \"true\") {\n                                getNextAutoIncKey();\n                            }\n                            else {\n                                idbModules.util.throwDOMException(0, \"Data Error - Could not eval key from keyPath\");\n                            }\n                        }\n                        else {\n                            callback(primaryKey);\n                        }\n                    } \n                    catch (e) {\n                        idbModules.util.throwDOMException(0, \"Data Error - Could not eval key from keyPath\", e);\n                    }\n                }\n                else {\n                    idbModules.util.throwDOMException(0, \"Data Error - KeyPath was specified, but value was not\");\n                }\n            }\n            else {\n                if (typeof key !== \"undefined\") {\n                    callback(key);\n                }\n                else {\n                    if (props.autoInc === \"false\") {\n                        idbModules.util.throwDOMException(0, \"Data Error - The object store uses out-of-line keys and has no key generator and the key parameter was not provided. \", props);\n                    }\n                    else {\n                        // Looks like this has autoInc, so lets get the next in sequence and return that.\n                        getNextAutoIncKey();\n                    }\n                }\n            }\n        });\n    };\n    \n    IDBObjectStore.prototype.__insertData = function(tx, value, primaryKey, success, error){\n        var paramMap = {};\n        if (typeof primaryKey !== \"undefined\") {\n            paramMap.key = idbModules.Key.encode(primaryKey);\n        }\n        var indexes = JSON.parse(this.__storeProps.indexList);\n        for (var key in indexes) {\n            try {\n                paramMap[indexes[key].columnName] = idbModules.Key.encode(eval(\"value['\" + indexes[key].keyPath + \"']\"));\n            } \n            catch (e) {\n                error(e);\n            }\n        }\n        var sqlStart = [\"INSERT INTO \", idbModules.util.quote(this.name), \"(\"];\n        var sqlEnd = [\" VALUES (\"];\n        var sqlValues = [];\n        for (key in paramMap) {\n            sqlStart.push(key + \",\");\n            sqlEnd.push(\"?,\");\n            sqlValues.push(paramMap[key]);\n        }\n        // removing the trailing comma\n        sqlStart.push(\"value )\");\n        sqlEnd.push(\"?)\");\n        sqlValues.push(value);\n        \n        var sql = sqlStart.join(\" \") + sqlEnd.join(\" \");\n        \n        idbModules.DEBUG && console.log(\"SQL for adding\", sql, sqlValues);\n        tx.executeSql(sql, sqlValues, function(tx, data){\n            success(primaryKey);\n        }, function(tx, err){\n            error(err);\n        });\n    };\n    \n    IDBObjectStore.prototype.add = function(value, key){\n        var me = this,\n            request = me.transaction.__createRequest(function(){}); //Stub request\n        idbModules.Sca.encode(value, function(encoded) {\n            me.transaction.__pushToQueue(request, function(tx, args, success, error){\n                me.__deriveKey(tx, value, key, function(primaryKey){\n                    me.__insertData(tx, encoded, primaryKey, success, error);\n                });\n            });\n        });\n        return request;\n    };\n    \n    IDBObjectStore.prototype.put = function(value, key){\n        var me = this,\n            request = me.transaction.__createRequest(function(){}); //Stub request\n        idbModules.Sca.encode(value, function(encoded) {\n            me.transaction.__pushToQueue(request, function(tx, args, success, error){\n                me.__deriveKey(tx, value, key, function(primaryKey){\n                    // First try to delete if the record exists\n                    var sql = \"DELETE FROM \" + idbModules.util.quote(me.name) + \" where key = ?\";\n                    tx.executeSql(sql, [idbModules.Key.encode(primaryKey)], function(tx, data){\n                        idbModules.DEBUG && console.log(\"Did the row with the\", primaryKey, \"exist? \", data.rowsAffected);\n                        me.__insertData(tx, encoded, primaryKey, success, error);\n                    }, function(tx, err){\n                        error(err);\n                    });\n                });\n            });\n        });\n        return request;\n    };\n    \n    IDBObjectStore.prototype.get = function(key){\n        // TODO Key should also be a key range\n        var me = this;\n        return me.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__waitForReady(function(){\n                var primaryKey = idbModules.Key.encode(key);\n                idbModules.DEBUG && console.log(\"Fetching\", me.name, primaryKey);\n                tx.executeSql(\"SELECT * FROM \" + idbModules.util.quote(me.name) + \" where key = ?\", [primaryKey], function(tx, data){\n                    idbModules.DEBUG && console.log(\"Fetched data\", data);\n                    try {\n                        // Opera can't deal with the try-catch here.\n                        if (0 === data.rows.length) {\n                            return success();\n                        }\n                        \n                        success(idbModules.Sca.decode(data.rows.item(0).value));\n                    } \n                    catch (e) {\n                        idbModules.DEBUG && console.log(e);\n                        // If no result is returned, or error occurs when parsing JSON\n                        success(undefined);\n                    }\n                }, function(tx, err){\n                    error(err);\n                });\n            });\n        });\n    };\n    \n    IDBObjectStore.prototype[\"delete\"] = function(key){\n        // TODO key should also support key ranges\n        var me = this;\n        return me.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__waitForReady(function(){\n                var primaryKey = idbModules.Key.encode(key);\n                idbModules.DEBUG && console.log(\"Fetching\", me.name, primaryKey);\n                tx.executeSql(\"DELETE FROM \" + idbModules.util.quote(me.name) + \" where key = ?\", [primaryKey], function(tx, data){\n                    idbModules.DEBUG && console.log(\"Deleted from database\", data.rowsAffected);\n                    success();\n                }, function(tx, err){\n                    error(err);\n                });\n            });\n        });\n    };\n    \n    IDBObjectStore.prototype.clear = function(){\n        var me = this;\n        return me.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__waitForReady(function(){\n                tx.executeSql(\"DELETE FROM \" + idbModules.util.quote(me.name), [], function(tx, data){\n                    idbModules.DEBUG && console.log(\"Cleared all records from database\", data.rowsAffected);\n                    success();\n                }, function(tx, err){\n                    error(err);\n                });\n            });\n        });\n    };\n    \n    IDBObjectStore.prototype.count = function(key){\n        var me = this;\n        return me.transaction.__addToTransactionQueue(function(tx, args, success, error){\n            me.__waitForReady(function(){\n                var sql = \"SELECT * FROM \" + idbModules.util.quote(me.name) + ((typeof key !== \"undefined\") ? \" WHERE key = ?\" : \"\");\n                var sqlValues = [];\n                (typeof key !== \"undefined\") && sqlValues.push(idbModules.Key.encode(key));\n                tx.executeSql(sql, sqlValues, function(tx, data){\n                    success(data.rows.length);\n                }, function(tx, err){\n                    error(err);\n                });\n            });\n        });\n    };\n    \n    IDBObjectStore.prototype.openCursor = function(range, direction){\n        var cursorRequest = new idbModules.IDBRequest();\n        var cursor = new idbModules.IDBCursor(range, direction, this, cursorRequest, \"key\", \"value\");\n        return cursorRequest;\n    };\n    \n    IDBObjectStore.prototype.index = function(indexName){\n        var index = new idbModules.IDBIndex(indexName, this);\n        return index;\n    };\n    \n    IDBObjectStore.prototype.createIndex = function(indexName, keyPath, optionalParameters){\n        var me = this;\n        optionalParameters = optionalParameters || {};\n        me.__setReadyState(\"createIndex\", false);\n        var result = new idbModules.IDBIndex(indexName, me);\n        me.__waitForReady(function(){\n            result.__createIndex(indexName, keyPath, optionalParameters);\n        }, \"createObjectStore\");\n        me.indexNames.push(indexName);\n        return result;\n    };\n    \n    IDBObjectStore.prototype.deleteIndex = function(indexName){\n        var result = new idbModules.IDBIndex(indexName, this, false);\n        result.__deleteIndex(indexName);\n        return result;\n    };\n    \n    idbModules.IDBObjectStore = IDBObjectStore;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n\n    /**\n     * The IndexedDB Transaction\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBTransaction\n     * @param {Object} storeNames\n     * @param {Object} mode\n     * @param {Object} db\n     */\n    var READ = 0;\n    var READ_WRITE = 1;\n    var VERSION_TRANSACTION = 2;\n    \n    var IDBTransaction = function(storeNames, mode, db){\n        if (typeof mode === \"number\") {\n            this.mode = mode;\n            (mode !== 2) && idbModules.DEBUG && console.log(\"Mode should be a string, but was specified as \", mode);\n        }\n        else \n            if (typeof mode === \"string\") {\n                switch (mode) {\n                    case \"readwrite\":\n                        this.mode = READ_WRITE;\n                        break;\n                    case \"readonly\":\n                        this.mode = READ;\n                        break;\n                    default:\n                        this.mode = READ;\n                        break;\n                }\n            }\n        \n        this.storeNames = typeof storeNames === \"string\" ? [storeNames] : storeNames;\n        for (var i = 0; i < this.storeNames.length; i++) {\n            if (!db.objectStoreNames.contains(this.storeNames[i])) {\n                idbModules.util.throwDOMException(0, \"The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.\", this.storeNames[i]);\n            }\n        }\n        this.__active = true;\n        this.__running = false;\n        this.__requests = [];\n        this.__aborted = false;\n        this.db = db;\n        this.error = null;\n        this.onabort = this.onerror = this.oncomplete = null;\n        var me = this;\n    };\n    \n    IDBTransaction.prototype.__executeRequests = function(){\n        if (this.__running && this.mode !== VERSION_TRANSACTION) {\n            idbModules.DEBUG && console.log(\"Looks like the request set is already running\", this.mode);\n            return;\n        }\n        this.__running = true;\n        var me = this;\n        window.setTimeout(function(){\n            if (me.mode !== 2 && !me.__active) {\n                idbModules.util.throwDOMException(0, \"A request was placed against a transaction which is currently not active, or which is finished\", me.__active);\n            }\n            // Start using the version transaction\n            me.db.__db.transaction(function(tx){\n                me.__tx = tx;\n                var q = null, i = 0;\n                function success(result, req){\n                    if (req) {\n                        q.req = req;// Need to do this in case of cursors\n                    }\n                    q.req.readyState = \"done\";\n                    q.req.result = result;\n                    delete q.req.error;\n                    var e = idbModules.Event(\"success\");\n                    idbModules.util.callback(\"onsuccess\", q.req, e);\n                    i++;\n                    executeRequest();\n                }\n                \n                function error(errorVal){\n                    q.req.readyState = \"done\";\n                    q.req.error = \"DOMError\";\n                    var e = idbModules.Event(\"error\", arguments);\n                    idbModules.util.callback(\"onerror\", q.req, e);\n                    i++;\n                    executeRequest();\n                }\n                function executeRequest(){\n                    if (i >= me.__requests.length) {\n                        me.__active = false; // All requests in the transaction is done\n                        me.__requests = [];\n                        return;\n                    }\n                    q = me.__requests[i];\n                    q.op(tx, q.args, success, error);\n                }\n                try {\n                    executeRequest();\n                } \n                catch (e) {\n                    idbModules.DEBUG && console.log(\"An exception occured in transaction\", arguments);\n                    typeof me.onerror === \"function\" && me.onerror();\n                }\n            }, function(){\n                idbModules.DEBUG && console.log(\"An error in transaction\", arguments);\n                typeof me.onerror === \"function\" && me.onerror();\n            }, function(){\n                idbModules.DEBUG && console.log(\"Transaction completed\", arguments);\n                typeof me.oncomplete === \"function\" && me.oncomplete();\n            });\n        }, 1);\n    };\n    \n    IDBTransaction.prototype.__addToTransactionQueue = function(callback, args){\n        if (!this.__active && this.mode !== VERSION_TRANSACTION) {\n            idbModules.util.throwDOMException(0, \"A request was placed against a transaction which is currently not active, or which is finished.\", this.__mode);\n        }\n        var request = this.__createRequest();\n        this.__pushToQueue(request, callback, args);       \n        return request;\n    };\n    \n    IDBTransaction.prototype.__createRequest = function(){\n        var request = new idbModules.IDBRequest();\n        request.source = this.db;\n        return request;\n    };\n    \n    IDBTransaction.prototype.__pushToQueue = function(request, callback, args) {\n        this.__requests.push({\n            \"op\": callback,\n            \"args\": args,\n            \"req\": request\n        });\n        // Start the queue for executing the requests\n        this.__executeRequests();\n    };\n    \n    IDBTransaction.prototype.objectStore = function(objectStoreName){\n        return new idbModules.IDBObjectStore(objectStoreName, this);\n    };\n    \n    IDBTransaction.prototype.abort = function(){\n        !this.__active && idbModules.util.throwDOMException(0, \"A request was placed against a transaction which is currently not active, or which is finished\", this.__active);\n        \n    };\n    \n    IDBTransaction.prototype.READ_ONLY = 0;\n    IDBTransaction.prototype.READ_WRITE = 1;\n    IDBTransaction.prototype.VERSION_CHANGE = 2;\n    \n    idbModules.IDBTransaction = IDBTransaction;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n\n    /**\n     * IDB Database Object\n     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#database-interface\n     * @param {Object} db\n     */\n    var IDBDatabase = function(db, name, version, storeProperties){\n        this.__db = db;\n        this.version = version;\n        this.__storeProperties = storeProperties;\n        this.objectStoreNames = new idbModules.util.StringList();\n        for (var i = 0; i < storeProperties.rows.length; i++) {\n            this.objectStoreNames.push(storeProperties.rows.item(i).name);\n        }\n        this.name = name;\n        this.onabort = this.onerror = this.onversionchange = null;\n    };\n    \n    IDBDatabase.prototype.createObjectStore = function(storeName, createOptions){\n        var me = this;\n        createOptions = createOptions || {};\n        createOptions.keyPath = createOptions.keyPath || null;\n        var result = new idbModules.IDBObjectStore(storeName, me.__versionTransaction, false);\n        \n        var transaction = me.__versionTransaction;\n        transaction.__addToTransactionQueue(function(tx, args, success, failure){\n            function error(){\n                idbModules.util.throwDOMException(0, \"Could not create new object store\", arguments);\n            }\n            \n            if (!me.__versionTransaction) {\n                idbModules.util.throwDOMException(0, \"Invalid State error\", me.transaction);\n            }\n            //key INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE\n            var sql = [\"CREATE TABLE\", idbModules.util.quote(storeName), \"(key BLOB\", createOptions.autoIncrement ? \", inc INTEGER PRIMARY KEY AUTOINCREMENT\" : \"PRIMARY KEY\", \", value BLOB)\"].join(\" \");\n            idbModules.DEBUG && console.log(sql);\n            tx.executeSql(sql, [], function(tx, data){\n                tx.executeSql(\"INSERT INTO __sys__ VALUES (?,?,?,?)\", [storeName, createOptions.keyPath, createOptions.autoIncrement ? true : false, \"{}\"], function(){\n                    result.__setReadyState(\"createObjectStore\", true);\n                    success(result);\n                }, error);\n            }, error);\n        });\n        \n        // The IndexedDB Specification needs us to return an Object Store immediatly, but WebSQL does not create and return the store immediatly\n        // Hence, this can technically be unusable, and we hack around it, by setting the ready value to false\n        me.objectStoreNames.push(storeName);\n        return result;\n    };\n    \n    IDBDatabase.prototype.deleteObjectStore = function(storeName){\n        var error = function(){\n            idbModules.util.throwDOMException(0, \"Could not delete ObjectStore\", arguments);\n        };\n        var me = this;\n        !me.objectStoreNames.contains(storeName) && error(\"Object Store does not exist\");\n        me.objectStoreNames.splice(me.objectStoreNames.indexOf(storeName), 1);\n        \n        var transaction = me.__versionTransaction;\n        transaction.__addToTransactionQueue(function(tx, args, success, failure){\n            if (!me.__versionTransaction) {\n                idbModules.util.throwDOMException(0, \"Invalid State error\", me.transaction);\n            }\n            me.__db.transaction(function(tx){\n                tx.executeSql(\"SELECT * FROM __sys__ where name = ?\", [storeName], function(tx, data){\n                    if (data.rows.length > 0) {\n                        tx.executeSql(\"DROP TABLE \" + idbModules.util.quote(storeName), [], function(){\n                            tx.executeSql(\"DELETE FROM __sys__ WHERE name = ?\", [storeName], function(){\n                            }, error);\n                        }, error);\n                    }\n                });\n            });\n        });\n    };\n    \n    IDBDatabase.prototype.close = function(){\n        // Don't do anything coz the database automatically closes\n    };\n    \n    IDBDatabase.prototype.transaction = function(storeNames, mode){\n        var transaction = new idbModules.IDBTransaction(storeNames, mode || 1, this);\n        return transaction;\n    };\n    \n    idbModules.IDBDatabase = IDBDatabase;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(idbModules){\n    var DEFAULT_DB_SIZE = 4 * 1024 * 1024;\n    if (!window.openDatabase) {\n        return;\n    }\n    // The sysDB to keep track of version numbers for databases\n    var sysdb = window.openDatabase(\"__sysdb__\", 1, \"System Database\", DEFAULT_DB_SIZE);\n    sysdb.transaction(function(tx){\n        tx.executeSql(\"SELECT * FROM dbVersions\", [], function(t, data){\n            // dbVersions already exists\n        }, function(){\n            // dbVersions does not exist, so creating it\n            sysdb.transaction(function(tx){\n                tx.executeSql(\"CREATE TABLE IF NOT EXISTS dbVersions (name VARCHAR(255), version INT);\", [], function(){\n                }, function(){\n                    idbModules.util.throwDOMException(\"Could not create table __sysdb__ to save DB versions\");\n                });\n            });\n        });\n    }, function(){\n        // sysdb Transaction failed\n       idbModules.DEBUG && console.log(\"Error in sysdb transaction - when selecting from dbVersions\", arguments);\n    });\n    \n    var shimIndexedDB = {\n        /**\n         * The IndexedDB Method to create a new database and return the DB\n         * @param {Object} name\n         * @param {Object} version\n         */\n        open: function(name, version){\n            var req = new idbModules.IDBOpenRequest();\n            var calledDbCreateError = false;\n            \n            function dbCreateError(){\n                if (calledDbCreateError) {\n                    return;\n                }\n                var e = idbModules.Event(\"error\", arguments);\n                req.readyState = \"done\";\n                req.error = \"DOMError\";\n                idbModules.util.callback(\"onerror\", req, e);\n                calledDbCreateError = true;\n            }\n            \n            function openDB(oldVersion){\n                var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);\n                req.readyState = \"done\";\n                if (typeof version === \"undefined\") {\n                    version = oldVersion || 1;\n                }\n                if (version <= 0 || oldVersion > version) {\n                    idbModules.util.throwDOMException(0, \"An attempt was made to open a database using a lower version than the existing version.\", version);\n                }\n                \n                db.transaction(function(tx){\n                    tx.executeSql(\"CREATE TABLE IF NOT EXISTS __sys__ (name VARCHAR(255), keyPath VARCHAR(255), autoInc BOOLEAN, indexList BLOB)\", [], function(){\n                        tx.executeSql(\"SELECT * FROM __sys__\", [], function(tx, data){\n                            var e = idbModules.Event(\"success\");\n                            req.source = req.result = new idbModules.IDBDatabase(db, name, version, data);\n                            if (oldVersion < version) {\n                                // DB Upgrade in progress \n                                sysdb.transaction(function(systx){\n                                    systx.executeSql(\"UPDATE dbVersions set version = ? where name = ?\", [version, name], function(){\n                                        var e = idbModules.Event(\"upgradeneeded\");\n                                        e.oldVersion = oldVersion;\n                                        e.newVersion = version;\n                                        req.transaction = req.result.__versionTransaction = new idbModules.IDBTransaction([], 2, req.source);\n                                        idbModules.util.callback(\"onupgradeneeded\", req, e, function(){\n                                            var e = idbModules.Event(\"success\");\n                                            idbModules.util.callback(\"onsuccess\", req, e);\n                                        });\n                                    }, dbCreateError);\n                                }, dbCreateError);\n                            } else {\n                                idbModules.util.callback(\"onsuccess\", req, e);\n                            }\n                        }, dbCreateError);\n                    }, dbCreateError);\n                }, dbCreateError);\n            }\n            \n            sysdb.transaction(function(tx){\n                tx.executeSql(\"SELECT * FROM dbVersions where name = ?\", [name], function(tx, data){\n                    if (data.rows.length === 0) {\n                        // Database with this name does not exist\n                        tx.executeSql(\"INSERT INTO dbVersions VALUES (?,?)\", [name, version || 1], function(){\n                            openDB(0);\n                        }, dbCreateError);\n                    } else {\n                        openDB(data.rows.item(0).version);\n                    }\n                }, dbCreateError);\n            }, dbCreateError);\n            \n            return req;\n        },\n        \n        \"deleteDatabase\": function(name){\n            var req = new idbModules.IDBOpenRequest();\n            var calledDBError = false;\n            function dbError(msg){\n                if (calledDBError) {\n                    return;\n                }\n                req.readyState = \"done\";\n                req.error = \"DOMError\";\n                var e = idbModules.Event(\"error\");\n                e.message = msg;\n                e.debug = arguments;\n                idbModules.util.callback(\"onerror\", req, e);\n                calledDBError = true;\n            }\n            var version = null;\n            function deleteFromDbVersions(){\n                sysdb.transaction(function(systx){\n                    systx.executeSql(\"DELETE FROM dbVersions where name = ? \", [name], function(){\n                        req.result = undefined;\n                        var e = idbModules.Event(\"success\");\n                        e.newVersion = null;\n                        e.oldVersion = version;\n                        idbModules.util.callback(\"onsuccess\", req, e);\n                    }, dbError);\n                }, dbError);\n            }\n            sysdb.transaction(function(systx){\n                systx.executeSql(\"SELECT * FROM dbVersions where name = ?\", [name], function(tx, data){\n                    if (data.rows.length === 0) {\n                        req.result = undefined;\n                        var e = idbModules.Event(\"success\");\n                        e.newVersion = null;\n                        e.oldVersion = version;\n                        idbModules.util.callback(\"onsuccess\", req, e);\n                        return;\n                    }\n                    version = data.rows.item(0).version;\n                    var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);\n                    db.transaction(function(tx){\n                        tx.executeSql(\"SELECT * FROM __sys__\", [], function(tx, data){\n                            var tables = data.rows;\n                            (function deleteTables(i){\n                                if (i >= tables.length) {\n                                    // If all tables are deleted, delete the housekeeping tables\n                                    tx.executeSql(\"DROP TABLE __sys__\", [], function(){\n                                        // Finally, delete the record for this DB from sysdb\n                                        deleteFromDbVersions();\n                                    }, dbError);\n                                } else {\n                                    // Delete all tables in this database, maintained in the sys table\n                                    tx.executeSql(\"DROP TABLE \" + idbModules.util.quote(tables.item(i).name), [], function(){\n                                        deleteTables(i + 1);\n                                    }, function(){\n                                        deleteTables(i + 1);\n                                    });\n                                }\n                            }(0));\n                        }, function(e){\n                            // __sysdb table does not exist, but that does not mean delete did not happen\n                            deleteFromDbVersions();\n                        });\n                    }, dbError);\n                });\n            }, dbError);\n            return req;\n        },\n        \"cmp\": function(key1, key2){\n            return idbModules.Key.encode(key1) > idbModules.Key.encode(key2) ? 1 : key1 === key2 ? 0 : -1;\n        }\n    };\n    \n    idbModules.shimIndexedDB = shimIndexedDB;\n}(idbModules));\n\n/*jshint globalstrict: true*/\n'use strict';\n(function(window, idbModules){\n    if (typeof window.openDatabase !== \"undefined\") {\n        window.shimIndexedDB = idbModules.shimIndexedDB;\n        if (window.shimIndexedDB) {\n            window.shimIndexedDB.__useShim = function(){\n                window.indexedDB = idbModules.shimIndexedDB;\n                window.IDBDatabase = idbModules.IDBDatabase;\n                window.IDBTransaction = idbModules.IDBTransaction;\n                window.IDBCursor = idbModules.IDBCursor;\n                window.IDBKeyRange = idbModules.IDBKeyRange;\n            };\n            window.shimIndexedDB.__debug = function(val){\n                idbModules.DEBUG = val;\n            };\n        }\n    }\n    \n    window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB;\n    \n    if (typeof window.indexedDB === \"undefined\" && typeof window.openDatabase !== \"undefined\") {\n        window.shimIndexedDB.__useShim();\n    }\n    else {\n        window.IDBDatabase = window.IDBDatabase || window.webkitIDBDatabase;\n        window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;\n        window.IDBCursor = window.IDBCursor || window.webkitIDBCursor;\n        window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;\n        if(!window.IDBTransaction){\n            window.IDBTransaction = {};\n        }\n        window.IDBTransaction.READ_ONLY = window.IDBTransaction.READ_ONLY || \"readonly\";\n        window.IDBTransaction.READ_WRITE = window.IDBTransaction.READ_WRITE || \"readwrite\";\n    }\n    \n}(window, idbModules));\n\ndefine(\"indexedDBShim\", function(){});\n",
    "\ndefine('db',['indexedDBShim'], function(idbpoly) {\n    'use strict';\n    var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB,\n        IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange,\n        transactionModes = {\n            readonly: 'readonly',\n            readwrite: 'readwrite'\n        };\n        \n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    if ( !indexedDB ) {\n        throw 'IndexedDB required';\n    }\n\n    var defaultMapper = function (value) {\n        return value;\n    };\n\n    var CallbackList = function () {\n        var state,\n            list = [];\n\n        var exec = function ( context , args ) {\n            if ( list ) {\n                args = args || [];\n                state = state || [ context , args ];\n\n                for ( var i = 0 , il = list.length ; i < il ; i++ ) {\n                    list[ i ].apply( state[ 0 ] , state[ 1 ] );\n                }\n\n                list = [];\n            }\n        };\n\n        this.add = function () {\n            for ( var i = 0 , il = arguments.length ; i < il ; i ++ ) {\n                list.push( arguments[ i ] );\n            }\n\n            if ( state ) {\n                exec();\n            }\n\n            return this;\n        };\n\n        this.execute = function () {\n            exec( this , arguments );\n            return this;\n        };\n    };\n\n    var Deferred = function ( func ) {\n        var state = 'progress',\n            actions = [\n                [ 'resolve' , 'done' , new CallbackList() , 'resolved' ],\n                [ 'reject' , 'fail' , new CallbackList() , 'rejected' ],\n                [ 'notify' , 'progress' , new CallbackList() ],\n            ],\n            deferred = {},\n            promise = {\n                state: function () {\n                    return state;\n                },\n                then: function ( /* doneHandler , failedHandler , progressHandler */ ) {\n                    var handlers = arguments;\n\n                    return Deferred(function ( newDefer ) {\n                        actions.forEach(function ( action , i ) {\n                            var handler = handlers[ i ];\n\n                            deferred[ action[ 1 ] ]( typeof handler === 'function' ?\n                                function () {\n                                    var returned = handler.apply( this , arguments );\n\n                                    if ( returned && typeof returned.promise === 'function' ) {\n                                        returned.promise()\n                                            .done( newDefer.resolve )\n                                            .fail( newDefer.reject )\n                                            .progress( newDefer.notify );\n                                    }\n                                } : newDefer[ action[ 0 ] ]\n                            );\n                        });\n                    }).promise();\n                },\n                promise: function ( obj ) {\n                    if ( obj ) {\n                        Object.keys( promise )\n                            .forEach(function ( key ) {\n                                obj[ key ] = promise[ key ];\n                            });\n\n                        return obj;\n                    }\n                    return promise;\n                }\n            };\n\n        actions.forEach(function ( action , i ) {\n            var list = action[ 2 ],\n                actionState = action[ 3 ];\n\n            promise[ action[ 1 ] ] = list.add;\n\n            if ( actionState ) {\n                list.add(function () {\n                    state = actionState;\n                });\n            }\n\n            deferred[ action[ 0 ] ] = list.execute;\n        });\n\n        promise.promise( deferred );\n\n        if ( func ) {\n            func.call( deferred , deferred );\n        }\n\n        return deferred;\n    };\n\n    var Server = function ( db , name ) {\n        var that = this,\n            closed = false;\n\n        this.add = function( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n\n            var records = [];\n            for (var i = 0; i < arguments.length - 1; i++) {\n                records[i] = arguments[i + 1];\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n            \n            records.forEach( function ( record ) {\n                var req;\n                if ( record.item && record.key ) {\n                    var key = record.key;\n                    record = record.item;\n                    req = store.add( record , key );\n                } else {\n                    req = store.add( record );\n                }\n\n                req.onsuccess = function ( e ) {\n                    var target = e.target;\n                    var keyPath = target.source.keyPath;\n                    if ( keyPath === null ) {\n                        keyPath = '__id__';\n                    }\n                    Object.defineProperty( record , keyPath , {\n                        value: target.result,\n                        enumerable: true\n                    });\n                    deferred.notify();\n                };\n            } );\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( records , e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( records , e );\n            };\n            return deferred.promise();\n        };\n\n        this.update = function( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n\n            var records = [];\n            for ( var i = 0 ; i < arguments.length - 1 ; i++ ) {\n                records[ i ] = arguments[ i + 1 ];\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                keyPath = store.keyPath,\n                deferred = Deferred();\n\n            records.forEach( function ( record ) {\n                var req;\n                if ( record.item && record.key ) {\n                    var key = record.key;\n                    record = record.item;\n                    req = store.put( record , key );\n                } else {\n                    req = store.put( record );\n                }\n\n                req.onsuccess = function ( e ) {\n                    deferred.notify();\n                };\n            } );\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( records , e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( records , e );\n            };\n            return deferred.promise();\n        };\n        \n        this.remove = function ( table , key ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n            \n            var req = store.delete( key );\n            transaction.oncomplete = function ( ) {\n                deferred.resolve( key );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.clear = function ( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var req = store.clear();\n            transaction.oncomplete = function ( ) {\n                deferred.resolve( );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n        \n        this.close = function ( ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            db.close();\n            closed = true;\n            delete dbCache[ name ];\n        };\n\n        this.get = function ( table , id ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var req = store.get( id );\n            req.onsuccess = function ( e ) {\n                deferred.resolve( e.target.result );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.query = function ( table , index ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            return new IndexQuery( table , db , index );\n        };\n\n        for ( var i = 0 , il = db.objectStoreNames.length ; i < il ; i++ ) {\n            (function ( storeName ) {\n                that[ storeName ] = { };\n                for ( var i in that ) {\n                    if ( !hasOwn.call( that , i ) || i === 'close' ) {\n                        continue;\n                    }\n                    that[ storeName ][ i ] = (function ( i ) {\n                        return function () {\n                            var args = [ storeName ].concat( [].slice.call( arguments , 0 ) );\n                            return that[ i ].apply( that , args );\n                        };\n                    })( i );\n                }\n            })( db.objectStoreNames[ i ] );\n        }\n    };\n\n    var IndexQuery = function ( table , db , indexName ) {\n        var that = this;\n        var modifyObj = false;\n\n        var runQuery = function ( type, args , cursorType , direction, limitRange, filters , mapper ) {\n            var transaction = db.transaction( table, modifyObj ? transactionModes.readwrite : transactionModes.readonly ),\n                store = transaction.objectStore( table ),\n                index = indexName ? store.index( indexName ) : store,\n                keyRange = type ? IDBKeyRange[ type ].apply( null, args ) : null,\n                results = [],\n                deferred = Deferred(),\n                indexArgs = [ keyRange ],\n                limitRange = limitRange ? limitRange : null,\n                filters = filters ? filters : [],\n                counter = 0;\n\n            if ( cursorType !== 'count' ) {\n                indexArgs.push( direction || 'next' );\n            };\n\n            // create a function that will set in the modifyObj properties into\n            // the passed record.\n            var modifyKeys = modifyObj ? Object.keys(modifyObj) : false;\n            var modifyRecord = function(record) {\n                for(var i = 0; i < modifyKeys.length; i++) {\n                    var key = modifyKeys[i];\n                    var val = modifyObj[key];\n                    if(val instanceof Function) val = val(record);\n                    record[key] = val;\n                }\n                return record;\n            };\n\n            index[cursorType].apply( index , indexArgs ).onsuccess = function ( e ) {\n                var cursor = e.target.result;\n                if ( typeof cursor === typeof 0 ) {\n                    results = cursor;\n                } else if ( cursor ) {\n                  if ( limitRange !== null && limitRange[0] > counter) {\n                      counter = limitRange[0];\n                      cursor.advance(limitRange[0]);\n                    } else if ( limitRange !== null && counter >= (limitRange[0] + limitRange[1]) ) {\n                        //out of limit range... skip\n                    } else {\n                        var matchFilter = true;\n                        var result = 'value' in cursor ? cursor.value : cursor.key;\n\n                        filters.forEach( function ( filter ) {\n                            if ( !filter || !filter.length ) {\n                                //Invalid filter do nothing\n                            } else if ( filter.length === 2 ) {\n                                matchFilter = (result[filter[0]] === filter[1])\n                            } else {\n                                matchFilter = filter[0].apply(undefined,[result]);\n                            }\n                        });\n\n                        if (matchFilter) {\n                            counter++;\n                            results.push( mapper(result) );\n                            // if we're doing a modify, run it now\n                            if(modifyObj) {\n                                result = modifyRecord(result);\n                                cursor.update(result);\n                            }\n                        }\n                        cursor.continue();\n                    }\n                }\n            };\n\n            transaction.oncomplete = function () {\n                deferred.resolve( results );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        var Query = function ( type , args ) {\n            var direction = 'next',\n                cursorType = 'openCursor',\n                filters = [],\n                limitRange = null,\n                mapper = defaultMapper,\n                unique = false;\n\n            var execute = function () {\n                return runQuery( type , args , cursorType , unique ? direction + 'unique' : direction, limitRange, filters , mapper );\n            };\n\n            var limit = function () {\n                limitRange = Array.prototype.slice.call( arguments , 0 , 2 )\n                if (limitRange.length == 1) {\n                    limitRange.unshift(0)\n                }\n\n                return {\n                    execute: execute\n                };\n            };\n            var count = function () {\n                direction = null;\n                cursorType = 'count';\n\n                return {\n                    execute: execute\n                };\n            };\n            var keys = function () {\n                cursorType = 'openKeyCursor';\n\n                return {\n                    desc: desc,\n                    execute: execute,\n                    filter: filter,\n                    distinct: distinct,\n                    map: map\n                };\n            };\n            var filter = function ( ) {\n                filters.push( Array.prototype.slice.call( arguments , 0 , 2 ) );\n\n                return {\n                    keys: keys,\n                    execute: execute,\n                    filter: filter,\n                    desc: desc,\n                    distinct: distinct,\n                    modify: modify,\n                    limit: limit,\n                    map: map\n                };\n            };\n            var desc = function () {\n                direction = 'prev';\n\n                return {\n                    keys: keys,\n                    execute: execute,\n                    filter: filter,\n                    distinct: distinct,\n                    modify: modify,\n                    map: map\n                };\n            };\n            var distinct = function () {\n                unique = true;\n                return {\n                    keys: keys,\n                    count: count,\n                    execute: execute,\n                    filter: filter,\n                    desc: desc,\n                    modify: modify,\n                    map: map\n                };\n            };\n            var modify = function(update) {\n                modifyObj = update;\n                return {\n                    execute: execute\n                };\n            };\n            var map = function (fn) {\n                mapper = fn;\n\n                return {\n                    execute: execute,\n                    count: count,\n                    keys: keys,\n                    filter: filter,\n                    desc: desc,\n                    distinct: distinct,\n                    modify: modify,\n                    limit: limit,\n                    map: map\n                };\n            };\n\n            return {\n                execute: execute,\n                count: count,\n                keys: keys,\n                filter: filter,\n                desc: desc,\n                distinct: distinct,\n                modify: modify,\n                limit: limit,\n                map: map\n            };\n        };\n        \n        'only bound upperBound lowerBound'.split(' ').forEach(function (name) {\n            that[name] = function () {\n                return new Query( name , arguments );\n            };\n        });\n\n        this.filter = function () {\n            var query = new Query( null , null );\n            return query.filter.apply( query , arguments );\n        };\n\n        this.all = function () {\n            return this.filter();\n        };\n    };\n    \n    var createSchema = function ( e , schema , db ) {\n        if ( typeof schema === 'function' ) {\n            schema = schema();\n        }\n        \n        for ( var tableName in schema ) {\n            var table = schema[ tableName ];\n            var store;\n            if (!hasOwn.call(schema, tableName) || db.objectStoreNames.contains(tableName)) {\n                store = e.currentTarget.transaction.objectStore(tableName);\n            } else {\n                store = db.createObjectStore(tableName, table.key);\n            }\n\n            for ( var indexKey in table.indexes ) {\n                var index = table.indexes[ indexKey ];\n                store.createIndex( indexKey , index.key || indexKey , Object.keys(index).length ? index : { unique: false } );\n            }\n        }\n    };\n    \n    var open = function ( e , server , version , schema ) {\n        var db = e.target.result;\n        var s = new Server( db , server );\n        var upgrade;\n\n        var deferred = Deferred();\n        deferred.resolve( s );\n        dbCache[ server ] = db;\n\n        return deferred.promise();\n    };\n\n    var dbCache = {};\n\n    var db = {\n        version: '0.9.0',\n        open: function ( options ) {\n            var request;\n\n            var deferred = Deferred();\n\n            // Check if we already have it in cache\n            var serverCache = dbCache[options.server];\n\n            if (serverCache) {\n                // If it is already in cache, make sure that we also \n                // have all of the tables we are opening already\n\n                for (var table in options.schema) {\n                    if (!serverCache.objectStoreNames.contains(table)) {\n                        serverCache.close();\n                        delete dbCache[options.server];\n                    }\n                }\n            }\n             \n\n            if ( dbCache[ options.server ]) {\n                open( {\n                    target: {\n                        result: dbCache[ options.server ]\n                    }\n                } , options.server , options.version , options.schema )\n                .done(deferred.resolve)\n                .fail(deferred.reject)\n                .progress(deferred.notify);\n            } else {\n                request = indexedDB.open( options.server , options.version );\n                            \n                request.onsuccess = function ( e ) {\n                    open( e , options.server , options.version , options.schema )\n                        .done(deferred.resolve)\n                        .fail(deferred.reject)\n                        .progress(deferred.notify);\n                };\n            \n                request.onupgradeneeded = function ( e ) {\n                    createSchema( e , options.schema , e.target.result );\n                };\n                request.onerror = function ( e ) {\n                    deferred.reject( e );\n                };\n            }\n\n            return deferred.promise();\n        }\n    };\n\n    return db;\n});",
    "\ndefine('data',[\"class\", \"db\", \"event\"], function(Class, db, Event) {\n  var Data = Class.extend({\n    _server: null,\n    _files: null,\n\n    // If we call other functions before the database is opened, \n    //these are the things we need to run\n    _initCallbacks: null,\n\n    init: function() {\n      this._files = [];\n\n      this._initCallbacks = [];\n\n      db.open({\n        server: 'draw',\n        version: 1,\n        schema: {\n          files: {\n            key: {\n              keyPath: 'id',\n            },\n            indexes: {\n              id: {\n                unique: true\n              },\n              modifiedTime: {\n                //keyPath: 'modifiedTime'\n              }\n            }\n          }\n        }\n      })\n        .done((function(server) {\n          console.log(\"Set up files server\");\n          this._server = server;\n\n          // Go through all our delayed callbacks\n          for (var i = 0; i < this._initCallbacks.length; i++) {\n            var callback = this._initCallbacks[i];\n            callback.func.apply(this, callback.args);\n          }\n\n        }).bind(this))\n        .fail(function(e) {\n          console.error(\"Failed setting up database\", e);\n        });\n\n      Event.addListener(\"fileModified\", this._fileModified.bind(this));\n    },\n\n    _doLater: function(func, args) {\n      this._initCallbacks.push({\n        func: func,\n        args: args\n      })\n    },\n\n    // Get the name of all the files we have\n    getFiles: function(callback) {\n      if (!this._server) {\n        this._doLater(this.getFiles, [callback]);\n        return;\n      }\n\n      if (!callback) {\n        throw \"You must specify a callback\";\n      }\n\n      this._server.files.query('modifiedTime')\n        .all()\n        .desc()\n        .execute()\n        .done((function(results) {\n          callback(results);\n        }).bind(this));\n\n    },\n\n    // Create a new file and returns the file name\n    createFile: function(callback) {\n      if (!this._server) {\n        this._doLater(this.createFile, [callback]);\n        return;\n      }\n\n      if (!callback) {\n        throw \"You must specify a callback\";\n      }\n\n      var fileId = this._getGuid();\n\n      var file = {\n        id: fileId,\n        name: \"Untitled File\",\n        modifiedTime: Date.now()\n      }\n\n      this._server.files.add(file)\n        .done((function(items) {\n          var item = items[0];\n\n          this.getFile(item.id, (function(s) {\n            callback(item);\n          }).bind(this));\n\n        }).bind(this))\n        .fail(function(e) {\n          console.error(\"fail to add file to file list\", e);\n        });\n    },\n\n    getFile: function(fileId, callback) {\n      if (!this._server) {\n        this._doLater(this.getFile, [fileId, callback]);\n        return;\n      }\n\n      db.open({\n        server: fileId,\n        version: 1,\n        schema: {\n          actions: {\n            key: {\n              keyPath: 'id',\n              autoIncrement: true\n            }\n            /*,\n            indexes: {\n              type: {},\n              id: {\n                unique: true\n              }\n            }\n            */\n          }\n        }\n      }).done((function(s) {\n        this._files[fileId] = s;\n        callback(s);\n      }).bind(this))\n        .fail(function(e) {\n          console.error(\"Failed to create file database\", e);\n        });;\n    },\n\n    renameFile: function(fileId, newFileName) {\n      if (!this._server) {\n        this._doLater(this.renameFile, [fileId]);\n        return;\n      }\n\n      this._server.files.query('id')\n        .only(fileId)\n        .modify({\n          name: newFileName\n        })\n        .execute()\n        .done(function(results) {\n          console.log(\"Want to rename file\", results);\n        })\n        .fail(function(e) {\n          console.error(\"Couldn't find file\", e);\n        })\n    },\n\n    deleteFile: function(fileId) {\n      if (!this._server) {\n        this._doLater(this.deleteFile, [fileId]);\n        return;\n      }\n\n      this._server.files.remove(fileId)\n        .done(function(key) {\n          // item removed\n          console.log(\"Deleted file from file table\", fileId);\n\n          var f = indexedDB.deleteDatabase(fileId);\n          f.onsuccess = function(e) {\n            console.log(\"Deleted Database for file\", key);\n          }\n          f.onerror = function(e) {\n            console.log(\"Error deleting database\", e);\n          }\n\n          // Delete settings from local storage\n          delete localStorage[fileId];\n\n        })\n        .fail(function(e) {\n          console.error(\"Failed to delete file from file table\", fileId);\n        });\n    },\n\n    // Get the stored file settings\n    localFileSettings: function(fileId, settings) {\n      if (settings) {\n        localStorage[fileId] = JSON.stringify(settings);\n      }\n\n      if (!localStorage[fileId]) {\n        localStorage[fileId] = JSON.stringify({\n          offsetX: 0,\n          offsetY: 0,\n          scale: 1\n        });\n      }\n\n      return JSON.parse(localStorage[fileId]);\n    },\n\n    _getGuid: function() {\n      return 'T^' + Date.now() + \"-\" + Math.round(Math.random() * 1000000);\n    },\n\n    _fileModified: function(data) {\n      if (!this._server) {\n        this._doLater(this._fileModified, [data]);\n        return;\n      }\n\n      this._server.files.query('id')\n        .only(data.fileId)\n        .modify({\n          modifiedTime: data.timestamp\n        })\n        .execute()\n        .done(function(results) {\n        })\n        .fail(function(e) {\n          console.error(\"Couldn't find file\", e);\n        })\n    }\n  });\n\n  var data = new Data();\n  window.data = data\n\n  return data;\n});",
    "\ndefine('templates/fileList',[], function() {\n\n  function FileList() {\n    var template = '<li class=\"file-info\">'+\n                      '<div class=\"thumbnail-wrapper\">'+\n                        '<canvas class=\"thumbnail\"></canvas>'+\n                      '</div>'+\n                      '<div class=\"file-details\">'+\n                        '<span class=\"file-name\"></span>'+\n                        '<span data-action=\"delete\">Delete</span>'+\n                      '</div>'+\n                    '</li';\n    var element = document.createElement(\"div\");\n    element.innerHTML = template;\n    return element.firstChild;\n  }\n\n  return FileList;\n});",
    "\ndefine('components/drawCanvas',[\"class\", \"helpers\"], function(Class, Helpers) {\n  var DrawCanvas = Class.extend({\n    _canvas: null,\n    _ctx: null,\n\n    _settings: null,\n\n    init: function(canvas, settings) {\n      this._canvas = canvas;\n      this._ctx = canvas.getContext(\"2d\");\n\n      this._settings = settings;\n    },\n\n    drawAll: function(actions) {\n      this._ctx.setTransform(this._settings.scale, 0, 0, this._settings.scale, this._settings.offsetX, this._settings.offsetY);\n\n      var topLeft = Helpers.screenToWorld(this._settings, 0, 0);\n      var bottomRight = Helpers.screenToWorld(this._settings, this._canvas.width, this._canvas.height);\n\n      this._ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n\n      // Keep the line width the same no matter the zoom level\n      var strokeSize = 1;\n      this._ctx.lineWidth = strokeSize / this._settings.scale;\n\n      for (var i = 0; i < actions.length; i++) {\n        var action = actions[i];\n\n        this.doAction(action);\n        \n      }\n    },\n\n    doAction: function(action) {\n      if (action.type == \"stroke\") {\n        this._drawStroke(action.stroke);\n      }\n    },\n\n    updateSettings: function(settings) {\n      this._settings = settings;\n    },\n\n    _drawStroke: function(stroke) {\n      if (stroke.points.length < 2) {\n        return;\n      }\n\n      var controlPoints = [];\n      var points = stroke.points;\n\n      if (!stroke.controlPoints) {\n        controlPoints = Helpers.getCurveControlPoints(points);\n      } else {\n        controlPoints = stroke.controlPoints;\n      }\n\n      var point = points[0];\n\n      this._ctx.beginPath();\n      this._ctx.moveTo(point.x, point.y);\n\n      for (var i = 1; i < points.length; i++) {\n        point = points[i];\n        var cp1 = controlPoints[i - 1].first;\n        var cp2 = controlPoints[i - 1].second;\n        this._ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, point.x, point.y);\n      }\n\n      this._ctx.stroke();\n    },\n  });\n\n  return DrawCanvas;\n\n});",
    "\ndefine('components/manipulateCanvas',[\"components/drawCanvas\", \"helpers\"], function(DrawCanvas, Helpers) {\n\n  var ManipulateCanvas = DrawCanvas.extend({\n    zoom: function(x, y, dScale) {\n      // Can't zoom that far!\n      if (this._settings.scale + dScale < .001 || this._settings.scale + dScale > 20000) {\n        return false;\n      }\n\n      var world = Helpers.screenToWorld(this._settings, x, y);\n      this._settings.scale += dScale;\n      var scr = Helpers.worldToScreen(this._settings, world.x, world.y);\n\n      var diffScr = {\n        x: x - scr.x,\n        y: y - scr.y\n      };\n\n      this._settings.offsetX += diffScr.x; // * this._settings.scale;\n      this._settings.offsetY += diffScr.y; // * this._settings.scale;\n\n      return true;\n    },\n\n    pan: function(dx, dy) {\n      this._settings.offsetX += dx;\n      this._settings.offsetY += dy;\n\n      return true;\n    },\n\n    panTo: function(x, y) {\n      this._settings.offsetX = x;\n      this._settings.offsetY = y;\n    }\n  });\n\n  return ManipulateCanvas;\n});",
    "\ndefine('components/thumbnail',[\"class\", \"helpers\", \"data\", \"components/manipulateCanvas\"], function(Class, Helpers, Data, ManipulateCanvas) {\n\n  var Thumbnail = Class.extend({\n    _canvas: null,\n\n    init: function(canvas) {\n      this._canvas = canvas;\n    },\n\n    render: function(file) {\n      var fileInfo = file;\n\n      data.getFile(file.id, (function(server) {\n        server.actions.query()\n          .all()\n          .execute()\n          .done((function(actions) {\n\n            var settings = data.localFileSettings(file.id);\n\n            var manipulateCanvas = new ManipulateCanvas(this._canvas, settings);\n\n            // Find out what world point is in the middle\n            var centerScreen = {x: window.innerWidth/2, y: window.innerHeight/2};\n            var centerWorld = Helpers.screenToWorld(settings, centerScreen.x, centerScreen.y);\n\n            var scale = Math.min(this._canvas.width / window.innerWidth, this._canvas.height / window.innerHeight);\n            var zoomDiff = (settings.scale * scale) - settings.scale;\n            manipulateCanvas.zoom(0, 0, zoomDiff);\n            \n            // Now that we have zoomed, find the middle of the canvas\n            var centerScreenAfter = {x: this._canvas.width/2, y: this._canvas.height/2};\n\n            // And where the middle point was from before\n            var centerScreenPointAfter = Helpers.worldToScreen(settings, centerWorld.x, centerWorld.y);\n\n            // pan the difference\n            var diffScreen = {x: centerScreenAfter.x - centerScreenPointAfter.x, y: centerScreenAfter.y - centerScreenPointAfter.y};\n            manipulateCanvas.pan(diffScreen.x, diffScreen.y);\n\n            manipulateCanvas.drawAll(actions);\n\n            window.a = actions;\n            window.c = manipulateCanvas;\n          }).bind(this));\n      }).bind(this));\n    }\n  });\n\n  return Thumbnail;\n});",
    "\ndefine('sections/fileList',[\"section\", \"tapHandler\", \"event\", \"helpers\", \"data\", \"templates/fileList\", \"components/thumbnail\"], function(Section, TapHandler, Event, Helpers, Data, FileListTemplate, Thumbnail) {\n\n  var FileList = Section.extend({\n    id: \"files-list-container\",\n\n    // The parent pane for this page\n    _filesPane: null,\n\n    // The element\n    _fileListElement: null,\n\n    // The set of files we are displaying on the page\n    // fileId => info\n    _files: null,\n\n    // Th order the files appear on the page\n    // index => fileId\n    _fileOrder: null,\n\n    _resizeTimeout: null,\n\n    init: function(filesPane) {\n      this._super();\n\n      this._filesPane = filesPane;\n\n      this._fileListElement = document.getElementById(\"files-list\");\n      this._files = {};\n      this._fileOrder = [];\n\n      this._resizeAndRender = this._resizeAndRender.bind(this);\n      this._actuallyResizeAndRender = this._actuallyResizeAndRender.bind(this);\n\n      Data.getFiles((function(files) {\n\n        console.log(\"got files\", files);\n\n        for (var i = 0; i < files.length; i++) {\n          var file = files[i];\n          this._files[file.id] = file;\n          this._fileOrder[i] = file.id;\n          var fileTemplate = this._newFileWrapper(file);\n          this._fileListElement.appendChild(fileTemplate);\n        }\n\n        this._actuallyResizeAndRender();\n      }).bind(this));\n\n      new TapHandler(document.getElementById(\"file-create\"), {\n        tap: this._newDoc.bind(this)\n      });\n\n      new TapHandler(this._fileListElement, {\n        tap: this._docSelected.bind(this)\n      });\n\n      Event.addListener(\"fileModified\", this._fileModified.bind(this));\n    },\n\n    show: function(fileInfo) {\n      if (fileInfo) {\n        // We came from draw, it is the info of the file we were just looking at\n        var file = this._files[fileInfo.id];\n        if (!file) {\n          console.error(\"We somehow came from a file that doesn't exist\");\n        }\n\n        file.thumbnail.render(file.file);\n      }\n\n      window.addEventListener(\"resize\", this._resizeAndRender);\n    },\n\n    hide: function() {\n      window.removeEventListener(\"resize\", this._resizeAndRender);\n    },\n\n    _newFileWrapper: function(file) {\n      var newEle = new FileListTemplate();\n\n      var canvas = newEle.getElementsByClassName(\"thumbnail\")[0];\n      var fileName = newEle.getElementsByClassName(\"file-name\")[0];\n\n      var thumbnail = new Thumbnail(canvas);\n      fileName.innerText = file.name;\n\n      newEle.fileId = file.id;\n\n      this._files[file.id] = {\n        element: newEle,\n        file: file,\n        canvas: canvas,\n        thumbnail: thumbnail\n      };\n\n      return newEle;\n    },\n\n    // Resize every thumbnail canvas and re-render them\n    _resizeAndRender: function() {\n      if (this._resizeTimeout) {\n        clearTimeout(this._resizeTimeout);\n      }\n\n      this._resizeTimeout = setTimeout(this._actuallyResizeAndRender.bind(this), 500);\n    },\n\n    _actuallyResizeAndRender: function() {\n      for (var fileId in this._files) {\n        var file = this._files[fileId];\n\n        var canvasParent = file.canvas.parentElement;\n        file.canvas.width = canvasParent.offsetWidth;\n        file.canvas.height = canvasParent.offsetHeight;\n        file.thumbnail.render(file.file);\n      }\n    },\n\n    _newDoc: function() {\n      console.log(\"new doc\");\n      data.createFile((function(file) {\n        var fileTemplate = this._newFileWrapper(file);\n        this._fileOrder.unshift(file.id);\n        this._fileListElement.insertBefore(fileTemplate, this._fileListElement.children[0]);\n      }).bind(this));\n    },\n\n    _docSelected: function(e) {\n      var element = e.srcElement;\n      var parent = Helpers.parentEleWithClassname(e.srcElement, \"file-info\");\n\n      if (parent) {\n        if (element.dataset.action && element.dataset.action == \"delete\") {\n\n          var file = this._files[parent.fileId];\n          this._fileListElement.removeChild(file.element);\n          delete this._files[parent.fileId];\n          data.deleteFile(parent.fileId);\n\n          // delete file\n          return;\n        }\n\n        this._filesPane.setPane(\"draw\", this._files[parent.fileId].file);\n      }\n\n    },\n\n    _fileModified: function(data) {\n      console.log(\"File was changed\", data);\n\n      var index = this._fileOrder.indexOf(data.fileId);\n      console.log(\"was index\", index);\n\n      // Move every element up\n      for (var i = index; i < this._files.length - 1; i++) {\n        this._fileOrder[i] = this._fileOrder[i+1];\n      }\n\n      // Change the length to get rid of the last element\n      this._fileOrder.length = this._fileOrder.length - 1;\n\n      // Put this one at the beginning\n      this._fileOrder.unshift(data.fileId);\n\n      // Now actually take the element out and put it at the beginning too\n      var element = this._files[data.fileId].element;\n      this._fileListElement.removeChild(element);\n      this._fileListElement.insertBefore(element, this._fileListElement.children[0]);\n    }\n\n  });\n\n  return FileList;\n\n});",
    "\ndefine('sections/draw',[\"section\", \"globals\", \"event\", \"helpers\", \"tapHandler\", \"db\", \"data\", \"components/manipulateCanvas\"], function(Section, g, Event, Helpers, TapHandler, db, Data, ManipulateCanvas) {\n\n  var Draw = Section.extend({\n    id: \"draw\",\n\n    // The parent pane for this page\n    _filesPane: null,\n\n    // Instance of draw canvas that is handling all the drawing\n    _manipulateCanvas: null,\n\n    // The actual canvas element\n    _canvas: null,\n\n    // The file we are currently rendering\n    _fileInfo: null,\n\n    // The file server we are using\n    _fileServer: null,\n\n    // Local settings such as offset and zoom\n    _settings: null,\n\n    // The actions we are taking\n    _actions: null,\n\n    // If we are currently doing something like drawing, it will be here\n    _currentAction: null,\n\n    // Do we need to update on this frame?\n    _needsUpdate: true,\n\n    // Set this to false to stop the render loop\n    _shouldRender: false,\n\n    // The current tool, zoom or pan\n    _currentTool: \"pan\",\n\n    // When you move the mouse, what is the tool to use?\n    _currentPointTool: \"pencil\",\n\n    // Timeout for \n    _saveTransformTimeout: null,\n\n    _redoStack: null,\n\n    // The tap handler for the draw pane. Needed to turn on and off gestures\n    _canvasTapHandler: null,\n\n    _toolTapHandler: null,\n\n    init: function(filesPane) {\n      this._super();\n\n      this._filesPane = filesPane;\n\n      this._canvas = document.getElementById('canvas');\n\n      this._resize = this._resize.bind(this);\n\n\n      this._canvasTapHandler = new TapHandler(canvas, {\n        start: this._start.bind(this),\n        move: this._move.bind(this),\n        end: this._end.bind(this),\n        gesture: this._gesture.bind(this)\n      });\n\n      this._toolTapHandler = new TapHandler(document.getElementById(\"tools\"), {\n        tap: this._toolChanged.bind(this),\n        start: this._toolStart.bind(this),\n        end: this._toolEnd.bind(this)\n      });\n\n      /*\n      new TapHandler(document.getElementById(\"menu\"), {\n        tap: this._menuTapped.bind(this),\n      });\n*/\n\n      this.element.addEventListener(\"mousewheel\", this._mouseWheel.bind(this));\n\n      this.element.addEventListener(\"keydown\", this._keyDown.bind(this));\n    },\n\n    show: function(file) {\n      this._fileInfo = file;\n\n      this._actions = [];\n      this._redoStack = [];\n\n      console.log(\"draw shown for file\", file);\n\n      data.getFile(file.id, (function(server) {\n\n        this._fileServer = server;\n        this._fileServer.actions.query()\n          .all()\n          .execute()\n          .done((function(results) {\n\n            this._actions = results;\n            this._needsUpdate = true;\n\n            this._settings = data.localFileSettings(file.id);\n\n            this._manipulateCanvas = new ManipulateCanvas(this._canvas, this._settings);\n\n            this._shouldRender = true;\n            this._redraw();\n\n\n          }).bind(this));\n      }).bind(this));\n\n      // We don't need data to resize\n      this._resize();\n\n      // Focus on the canvas after we navigate to it\n      setTimeout(function() {\n        canvas.focus();\n      }.bind(this), 400);\n\n      window.addEventListener(\"resize\", this._resize);\n    },\n\n    hide: function() {\n      this._shouldRender = false;\n\n      window.removeEventListener(\"resize\", this._resize);\n    },\n\n    _resize: function() {\n      this._canvas.width = window.innerWidth;\n      this._canvas.height = window.innerHeight;\n\n      this._needsUpdate = true;\n    },\n\n    _zoom: function(x, y, dScale) {\n      if (this._manipulateCanvas.zoom(x, y, dScale)) {\n        this._saveTransform();\n        this._needsUpdate = true;\n      }\n    },\n\n    _pan: function(dx, dy) {\n      if (this._manipulateCanvas.pan(dx, dy)) {\n        this._saveTransform();\n        this._needsUpdate = true;\n      }\n    },\n\n    _mouseWheel: function(e) {\n\n      if (this._currentTool == \"pan\") {\n        //console.log(\"pan\", e);\n        this._pan(-e.deltaX, -e.deltaY);\n      } else if (this._currentTool == \"zoom\") {\n        if (e.deltaY != 0) {\n          //console.log(e);\n          this._zoom(e.offsetX, e.offsetY, e.deltaY / 100 * this._settings.scale);\n        }\n      }\n    },\n\n    _start: function(e) {\n      if (this._currentPointTool == \"pan\") {\n\n      } else if (this._currentPointTool == \"pencil\") {\n        var world = Helpers.screenToWorld(this._settings, e.distFromLeft, e.distFromTop);\n\n        console.log(\"started at\", world);\n        if (this._currentAction) {\n          console.error(\"Current action isn't null!\");\n        }\n\n        this._currentAction = {\n          type: \"stroke\",\n          stroke: {\n            points: [world]\n          }\n        }\n\n        // Make sure the redo stack is empty as we are starting to draw again\n        this._redoStack = [];\n      }\n    },\n\n    _move: function(e) {\n      if (this._currentPointTool == \"pan\") {\n        this._pan(e.xFromLast, e.yFromLast);\n      } else if (this._currentPointTool == \"pencil\") {\n\n        var world = Helpers.screenToWorld(this._settings, e.distFromLeft, e.distFromTop);\n\n        //console.log(\"world\", e, world);\n        var currentStroke = this._currentAction.stroke;\n\n\n        var points = currentStroke.points;\n        var lastPoint = points[points.length - 1];\n\n\n        var dist = Math.sqrt(((lastPoint.x - world.x) * (lastPoint.x - world.x)) + ((lastPoint.y - world.y) * (lastPoint.y - world.y)));\n        //console.log(\"dist\", dist);\n\n        //if (dist < 0.0003) {\n        if (dist < 0.001) {\n          return;\n        }\n\n        currentStroke.points.push(world);\n        this._needsUpdate = true;\n      }\n    },\n\n    _end: function(e) {\n      if (this._currentPointTool == \"pencil\") {\n        var currentAction = this._currentAction;\n        this._currentAction = null;\n\n        var currentStroke = currentAction.stroke;\n\n        if (currentStroke.points.length < 2) {\n          // two options, don't count the stroke\n          return;\n\n          // Or create a second point, same as the first.\n          // Canvas doesn't seem to render a line with two identical points.\n          currentStroke.points.push(currentStroke.points[0]);\n        }\n\n        var controlPoints = Helpers.getCurveControlPoints(currentStroke.points);\n        currentStroke.controlPoints = controlPoints;\n\n        this._saveAction(currentAction);\n      }\n    },\n\n    _saveAction: function(action) {\n      // Store the current action\n      this._actions.push(action);\n      //this._currentAction = null;\n\n      // And persist it\n\n      this._fileServer.actions.add(action)\n        .done(function(item) {\n          // item stored\n        })\n        .fail(function(e) {\n          console.error(\"fail to write\", e);\n        });\n\n      Event.trigger(\"fileModified\", {\n        fileId: this._fileInfo.id,\n        timestamp: Date.now()\n      })\n\n      this._needsUpdate = true;\n    },\n\n    _gesture: function(e) {\n      this._pan(e.xFromLast, e.yFromLast);\n      this._zoom(e.x, e.y, e.scaleFromLast * this._settings.scale);\n    },\n\n    _redraw: function() {\n      // If we shouldn't render, exit the loop\n      if (!this._shouldRender) {\n        return;\n      }\n\n      if (this._needsUpdate) {\n        this._manipulateCanvas.drawAll(this._actions);\n\n        if (this._currentAction) {\n          this._manipulateCanvas.doAction(this._currentAction)\n        }\n        this._needsUpdate = false;\n      }\n\n      requestAnimationFrame(this._redraw.bind(this));\n    },\n\n    _menuTapped: function(e) {\n      if (e.srcElement.tagName == \"LI\") {\n        var action = e.srcElement.dataset.action;\n\n        if (action == \"back\") {\n          this._filesPane.setPane(\"list\", this._fileInfo);\n        }\n      }\n    },\n\n    _toolChanged: function(e) {\n      if (e.srcElement.tagName == \"LI\") {\n        var action = e.srcElement.dataset.action;\n        var tool = e.srcElement.dataset.tool;\n\n        if (tool) {\n          this._currentTool = e.srcElement.dataset.tool;\n        } else if (action) {\n          if (action == \"undo\") {\n            this._undo();\n          } else if (action == \"redo\") {\n            this._redo();\n          }\n        }\n      }\n    },\n\n    _toolStart: function(e) {\n      var tool = e.srcElement.dataset.tool;\n\n      if (e.srcElement.tagName == \"LI\" && tool) {\n        this._currentPointTool = tool;\n\n        if (tool == \"pan\") {\n          console.log(\"pan started\",e);\n          this._canvasTapHandler.ignoreGestures(true);\n          this._toolTapHandler.ignoreGestures(true);\n        }\n      }\n    },\n\n    _toolEnd: function(e) {\n      console.log(\"tool ended\",e);\n      var tool = e.srcElement.dataset.tool;\n\n      if (e.srcElement.tagName == \"LI\" && tool) {\n        if (tool == \"pan\") {\n          console.log(\"pan ended\");\n          this._currentPointTool = \"pencil\";\n\n          this._canvasTapHandler.ignoreGestures(false);\n          this._toolTapHandler.ignoreGestures(false);\n        }\n      }\n    },\n\n    _keyDown: function(e) {\n      var key = String.fromCharCode(e.keyCode);\n      //console.log(e);\n      // console.log(\"key\", key);\n      // console.log(e);\n\n      if (\n        ((g.isMac() && e.metaKey && e.shiftKey) && key == \"Z\") ||\n        ((g.isPC() && e.ctrlKey) && key == \"Y\")) {\n        // Redo\n\n        if (this._redoStack.length > 0) {\n          this._redo();\n        }\n      } else if ((\n          (g.isMac() && e.metaKey) ||\n          (g.isPC() && e.ctrlKey)\n        ) &&\n        key == \"Z\") {\n        // Undo\n\n        e.preventDefault();\n        this._undo();\n      } else if (key == \"Z\") {\n        this._currentTool = \"zoom\";\n      } else if (key == \"P\") {\n        this._currentTool = \"pan\";\n      }\n\n    },\n\n    _undo: function() {\n      if (this._actions.length > 0) {\n        var action = this._actions.pop();\n\n        // It is impossible to delete the id off of the action, so we have to create a new object\n        var newObj = {};\n\n        for (var prop in action) {\n          if (prop != \"id\") {\n            newObj[prop] = action[prop];\n          }\n        }\n\n        this._redoStack.push(newObj);\n\n        this._fileServer.actions.remove(action.id).done(function(key) {\n          console.log('remove', key, action);\n          // item removed\n        });\n\n        this._needsUpdate = true;\n      }\n    },\n\n    _redo: function() {\n      if (this._redoStack.length > 0) {\n        var nowAction = this._redoStack.pop();\n        this._saveAction(nowAction);\n      }\n    },\n\n\n    /*\n    // Create an image with all of the lines on it.\n    _save: function() {\n      // FIgure out the bounds of the lines\n      var top = lines[0].startY;\n      var left = lines[0].startX;\n      var bottom = lines[0].startY;\n      var right = lines[0].startX;\n\n      for (var i = 0; i < lines.length; i++) {\n        var top = Math.min(lines[i].startY, Math.min(lines[i].endY, top));\n        var left = Math.min(lines[i].startX, Math.min(lines[i].endX, top));\n        var bottom = Math.max(lines[i].startY, Math.max(lines[i].endY, top));\n        var right = Math.max(lines[i].startX, Math.max(lines[i].endX, top));\n      }\n\n      // Create a canvas large enough that it can contain the bounds\n      var width = right - left;\n      var height = bottom - top;\n\n      // Expand for some padding\n      var paddingX = width * .05;\n      var paddingY = height * .05;\n      width *= 1.1;\n      height *= 1.1;\n\n      var transformations = {\n        offsetX: paddingX,\n        offsetY: paddingY,\n        scale: 1\n      }\n\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = width;\n      canvas.height = height;\n\n      var ctx = canvas.getContext(\"2d\");\n    }\n*/\n\n\n    _saveTransform: function() {\n      // If the timeout is set already\n      if (this._saveTransformTimeout) {\n\n        // Clear it and set a new one\n        clearTimeout(this._saveTransformTimeout);\n      }\n\n      this._saveTransformTimeout = setTimeout((function() {\n        data.localFileSettings(this._fileInfo.id, this._settings);\n        this._saveTransformTimeout = null;\n      }).bind(this), 100);\n\n    },\n  });\n\n  return Draw;\n\n});",
    "\ndefine('managers/files',[\"section\", \"event\", \"sections/fileList\", \"sections/draw\"], function(Section, Event, FileList, Draw) {\n\n  var Files = Section.extend({\n    id: \"files\",\n\n    _paneWrapper: null,\n\n    _screenWidth: 0,\n\n    _defaultSettings: {},\n\n    panes: null,\n\n    currentPaneName: null,\n\n    init: function() {\n      this._super();\n\n      this._defaultSettings = {\n        title: {\n          text: \"Photos\"\n        }\n      };\n\n      this._screenWidth = window.innerWidth;\n\n      this._paneWrapper = document.getElementById(\"files-pane-wrapper\");\n\n      this._windowResized = this._windowResized.bind(this);\n      this._finishedSliding = this._finishedSliding.bind(this);\n\n      this._paneWrapper.addEventListener(\"webkitTransitionEnd\", this._finishedSliding);\n\n      this.panes = {};\n\n      this.panes.list = {\n        offsetX: 0,\n        pane: new FileList(this)\n      };\n\n      this.panes.draw = {\n        offsetX: this._screenWidth,\n        pane: new Draw(this)\n      };\n\n      this.panes.draw.pane.element.style.webkitTransform = 'translate(' + this._screenWidth + \"px, 0)\";\n\n      var state = {\n        pane: \"list\",\n        details: null\n      };\n      if (localStorage.filesPane) {\n        state = JSON.parse(localStorage.filesPane);\n      }\n\n      this.setPane(state.pane, state.details);\n\n\n      window.files = this;\n    },\n\n    show: function() {\n      window.addEventListener(\"resize\", this._windowResized);\n    },\n\n    hide: function() {\n      window.removeEventListener(\"resize\", this._windowResized);\n    },\n\n    setPane: function(pane, details) {\n      if (this.currentPaneName == pane)\n        return;\n\n      var paneobj = null;\n\n      if (this.currentPaneName) {\n\n        var paneobj = this.panes[this.currentPaneName].pane;\n\n        if (paneobj.hide) {\n          paneobj.hide();\n        }\n\n        paneobj.afterHide();\n      }\n\n\n      paneobj = this.panes[pane].pane;\n\n      if (paneobj.show) {\n        paneobj.show(details);\n      }\n\n      paneobj.afterShow();\n\n      this.currentPaneName = pane;\n\n\n      // Finish up\n      var totalPane = this.panes[pane];\n\n      var translate = \"translate3d(\" + (-1 * totalPane.offsetX) + \"px, 0px, 0px)\";\n      if (this._paneWrapper.style.webkitTransform != translate) {\n        this._paneWrapper.classList.add(\"ani4\");\n        this._paneWrapper.style.webkitTransform = translate;\n      }\n\n\n      if (pane == \"list\") {\n        delete localStorage[\"filesPane\"];\n      } else {\n        localStorage.filesPane = JSON.stringify({\n          pane: pane,\n          details: details\n        });\n      }\n    },\n\n    _finishedSliding: function() {\n      // Remove the animation\n      this._paneWrapper.classList.remove(\"ani4\");\n\n      this._redoOffsets();\n\n      this._paneWrapper.style.webkitTransform = \"translate3d(0px, 0px, 0px)\";\n    },\n\n    _windowResized: function() {\n      this._redoOffsets();\n    },\n\n    _redoOffsets: function() {\n      this._screenWidth = window.innerWidth;\n\n      // Set the offsets on all the panes so that the current pane is 0,0\n      var currentIndex = 0;\n      for (var pane in this.panes) {\n        if (this.currentPaneName == pane) {\n          break;\n        }\n\n        currentIndex++;\n\n      }\n\n      var startX = -1 * currentIndex * this._screenWidth;\n      for (var pane in this.panes) {\n        this.panes[pane].offsetX = startX;\n        this.panes[pane].pane.element.style.webkitTransform = 'translate(' + startX + \"px, 0)\";\n        startX += this._screenWidth;\n      }\n    }\n  });\n\n  return Files;\n\n});",
    "\ndefine('sections/main',[\"section\", \"event\", \"managers/files\"], function(Section, Event, Files) {\n\n  var Main = Section.extend({\n    id: \"main-container\",\n\n    mainContent: null,\n\n    // The panes we slide between in the main-content\n    panes: null,\n    currentPane: \"\",\n\n\n    init: function() {\n      this._super();\n\n      this.mainContent = document.getElementById(\"main-content\");\n      this.panes = {};\n\n      this.panes.files = new Files();\n\n      Event.addListener(\"logout\", this._logout.bind(this));\n    },\n\n    show: function() {\n      console.log(\"screens shown\");\n\n      if (localStorage.currentPane) {\n        this.setPane(localStorage.currentPane);\n      } else {\n        this.setPane(\"files\");\n      }\n\n      //this.showDrawer();\n    },\n\n    setPane: function(pane) {\n      if (this.currentPane == pane)\n        return;\n\n      var paneobj = null;\n\n      if (this.currentPane) {\n\n        var paneobj = this.panes[this.currentPane];\n\n        if (paneobj.hide) {\n          paneobj.hide();\n        }\n\n        paneobj.afterHide();\n      }\n\n      paneobj = this.panes[pane];\n\n      if (paneobj.show) {\n        paneobj.show();\n      }\n\n      paneobj.afterShow();\n\n      this.currentPane = pane;\n\n      localStorage.currentPane = pane;\n      Event.trigger(\"paneChanged\", {\n        pane: paneobj\n      });\n    },\n\n    _logout: function() {\n      delete localStorage.currentPane;\n    }\n  });\n\n  return Main;\n\n});",
    "\ndefine('managers/login',[\"event\", \"sections/login\", \"sections/main\"], function(Event, LoginSection, MainSection) {\n  function LoginManager() {\n    this.init();\n  }\n\n  LoginManager.prototype = {\n    pages: null,\n    currentPage: \"\",\n\n    init: function() {\n      this.pages = {};\n\n      Event.addListener(\"login\", this._login.bind(this));\n      Event.addListener(\"logout\", this._logout.bind(this));\n\n      this.pages.login = new LoginSection();\n      this.pages.main = new MainSection();\n\n      if (localStorage.loggedIn == \"true\") {\n        this.setPage(\"main\");\n      }\n      else\n      {\n        this.setPage(\"login\");\n      }\n    },\n\n    setPage: function(page) {\n      var pageobj = null;\n\n      if (this.currentPage) {\n\n        var pageobj = this.pages[this.currentPage];\n\n        if (pageobj.hide) {\n          pageobj.hide();\n        }\n        pageobj.afterHide();\n      }\n\n      pageobj = this.pages[page];\n      \n      if (pageobj.show) {\n        pageobj.show();\n      }\n      pageobj.afterShow();\n\n      this.currentPage = page;\n    },\n\n    _login: function() {\n      localStorage.loggedIn = true;\n      this.setPage(\"main\");\n    },\n\n    _logout: function() {\n      localStorage.loggedIn = false;\n      this.setPage(\"login\");\n    }\n  };\n\n  return LoginManager;\n});",
    "\nrequire([\"event\", \"globals\", \"managers/login\"], function(Event, g, LoginManager) {\n\n  function init() {\n    window.log = console.log.bind(console);\n\n    document.addEventListener(\"touchmove\", function(e) {\n      e.preventDefault();\n    });\n\n    document.addEventListener(\"mousewheel\", function(e) {\n      e.preventDefault();\n    });\n\n    g.setHTMLDevices();\n\n    var loginManager = new LoginManager();\n    window.login = loginManager;\n  }\n\n  if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n    init();\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", init, false);\n  }\n});\ndefine(\"main\", function(){});\n"
  ]
}