{
  "version": 3,
  "file": "/Users/eli/projects/draw/build/javascript/main.min.js",
  "sources": [
    "../../node_modules/grunt-requirejs/node_modules/almond/almond.js",
    "event.js",
    "class.js",
    "section.js",
    "tapHandler.js",
    "sections/draw.js",
    "main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvDA,ADwDA;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxMA,ADyMA;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9aA,AD+aA;AC9aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\n/**\n * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n",
    "\ndefine('event',[], function() {\n\n  function Event() {\n    this.init();\n  }\n\n  Event.prototype = {\n    listeners: null,\n\n    init: function() {\n      this.listeners = [];\n    },\n\n    addListener: function(event, callback) {\n      if (!this.listeners[event]) {\n        this.listeners[event] = [];\n      }\n\n      this.listeners[event].push(callback);\n    },\n\n    removeListener: function(event, callback) {\n      if (!this.listeners[event]) {\n        return false;\n      }\n\n      for(var i = 0; i < this.listeners[event].length; i++) {\n        if (this.listeners[event][i] == callback) {\n          this.listeners[event] = this.listeners[event].splice(i, 1);\n          return true;\n        }\n      }\n    },\n\n    trigger: function(event, data) {\n      if (!this.listeners[event]) {\n        return false;\n      }\n\n      function callListener(listener) {\n        setTimeout(function() {\n          listener(data);\n        }, 0);\n      }\n\n      for(var i = 0; i < this.listeners[event].length; i++) {\n        callListener(this.listeners[event][i]);\n      }\n\n      return true;\n    }\n  }\n\n  return new Event(); \n\n});",
    "\ndefine('class',[], function() {\n\t/* Simple Javascript inheritance by John Resig */\n\n\tvar initializing = false,\n\t\tfnTest = /xyz/.test(function() {\n\t\t\txyz;\n\t\t}) ? /\\b_super\\b/ : /.*/;\n\n\t// The base CClass implementation (does nothing)\n\tthis.Class = function() {};\n\n\t// Create a new CLass that inherits from this class\n\tClass.extend = function(prop) {\n\t\tvar _super = this.prototype;\n\n\t\t// Instantiate a base class (but only create the instance, don't run the consutrcutor)\n\t\tinitializing = true;\n\t\tvar prototype = new this();\n\t\tinitializing = false;\n\n\t\t// Copy the properties over onto the new prototype\n\t\tfor (var name in prop) {\n\t\t\t// Check if we're overwriting an existing function\n\t\t\tprototype[name] = typeof prop[name] == \"function\" && typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n\t\t\t\t(function(name, fn) {\n\t\t\t\treturn function() {\t\t\t\t\n\t\t\t\t\tvar tmp = this._super;\n\n\t\t\t\t\t// Add a new ._super() method that is the same method\n\t\t\t\t\t// but on the super-class\n\t\t\t\t\tthis._super = _super[name];\n\n\t\t\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t\t\t// remove it when we're done executing\n\n\t\t\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\t\t\tthis._super = tmp;\n\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\t\t\t})(name, prop[name]) : prop[name];\n\t\t}\n\n\t\t// The dummy class constructor\n\n\t\tfunction Class() {\n\t\t\t// All construction is actually done in the init method\n\t\t\tif (!initializing && this.init)\n\t\t\t\tthis.init.apply(this, arguments);\n\t\t}\n\n\t\t// Populate our constructed prototype object\n\t\tClass.prototype = prototype;\n\n\t\t// Enforce the constructor to be what we expect\n\t\tClass.prototype.constructor = Class;\n\n\t\t// And make this class extendable\n\t\tClass.extend = arguments.callee;\n\n\t\treturn Class;\n\n\t};\n\n\treturn this.Class;\n});",
    "\ndefine('section',[\"class\"], function(Class) {\n\n\tvar Section = Class.extend({\n\t\tid: null,\n\t\telement: null,\n\n\t\tinit: function() {\n\t\t\tthis.element = document.getElementById(this.id);\n\t\t},\n\n\t\tshow: null,\n\t\thide: null,\n\n\t\tafterShow: function() {\n\t\t\tthis.element.style.display = \"block\";\n\t\t},\n\n\t\tafterHide: function() {\n\t\t\tthis.element.style.display = \"\";\n\t\t}\n\n\t});\n\n\treturn Section;\n});",
    "\ndefine('tapHandler',[], function() {\n  function TapHandler(element, options) {\n    this.init(element, options);\n  }\n\n  TapHandler.prototype = {\n    _element: null,\n    _options: null,\n\n    _distCutoff: 20,\n    _timeCutoff: 500,\n\n    _startTime: null,\n    _startX: null,\n    _startY: null,\n\n    _startScale: null,\n\n    _lastX: null,\n    _lastY: null,\n\n    _lastScale: null,\n\n    // Object with x and why of where the element is on the page\n    _offset: null,\n\n    _inTouch: false,\n    _inGesture: false,\n\n    init: function(element, options) {\n      this._element = element;\n      this._options = options;\n\n      // Replace with binded events\n      this._move = this._move.bind(this);\n      this._end = this._end.bind(this);\n      this._gestureChange = this._gestureChange.bind(this);\n      this._gestureEnd = this._gestureEnd.bind(this);\n\n      this._offset = {\n        x: element.offsetLeft,\n        y: element.offsetTop\n      };\n\n\n      this._element.addEventListener(\"mousedown\", this._start.bind(this));\n      this._element.addEventListener(\"touchstart\", this._start.bind(this));\n      this._element.addEventListener(\"gesturestart\", this._gestureStart.bind(this));\n    },\n\n    _start: function(e) {\n      // Ignore these if we are currently gesturing\n      if (this._inGesture) {\n        return;\n      }\n\n      this._inTouch = true;\n\n      this._processEvent(e);\n      this._startTime = e.timeStamp;\n\n      this._startX = this._lastX = e.x;\n      this._startY = this._lastY = e.y;\n\n      if (this._options.start) {\n        this._options.start(e);\n      }\n\n      document.addEventListener(\"touchmove\", this._move);\n      document.addEventListener(\"mousemove\", this._move);\n      \n      document.addEventListener(\"touchend\", this._end);\n      document.addEventListener(\"mouseup\", this._end);\n    },\n\n    _move: function(e) {\n      this._processEvent(e);\n\n      this._lastX = e.x;\n      this._lastY = e.y;\n\n      if (this._options.move) {\n        this._options.move(e);\n      }\n    },\n\n    _end: function(e) {\n\n      this._endTouchHandlers();\n      this._inTouch = false;\n\n      if (e) {\n        this._processEvent(e);\n\n        var dist = Math.sqrt(((e.x - this._startX) * (e.x - this._startX)) + ((e.y - this._startY) * (e.y - this._startY)));\n        if (dist < this._distCutoff && (e.timeStamp - this._startTime < this._timeCutoff)) {\n          if (this._options.tap) {\n            this._options.tap(e);\n            return;\n          }\n        }\n      }\n\n      // It wasn't a tap, just an up\n      if (this._options.end) {\n        this._options.end(e);\n      }\n    },\n\n    _gestureStart: function(e) {\n      this._inGesture = true;\n\n      // We need to end the touch\n      this._end();\n\n\n      this._processEvent(e);\n      this._processGesture(e);\n\n      this._startTime = e.timeStamp;\n\n      this._startX = this._lastX = e.x;\n      this._startY = this._lastY = e.y;\n\n      this._startScale = this._lastScale = e.scale;\n\n      document.addEventListener(\"gesturechange\", this._gestureChange);\n      document.addEventListener(\"gestureend\", this._gestureEnd);\n    },\n\n    _gestureChange: function(e) {\n      this._processEvent(e);\n      this._processGesture(e);\n\n      this._lastX = e.x;\n      this._lastY = e.y;\n      this._lastScale = e.scale;\n\n      //console.log(e.xFromLast, e.yFromLast);\n\n      this._lastScale = e.scale;\n      \n      if (this._options.gesture) {\n        this._options.gesture(e);\n      }\n    },\n\n    _gestureEnd: function(e) {\n      this._processEvent(e);\n      this._processGesture(e);\n\n      document.removeEventListener(\"gesturechange\", this._gestureChange);\n      document.removeEventListener(\"gestureend\", this._gestureEnd);\n\n      this._inGesture = false;\n    },  \n\n    // Unregister the regular touch handlers, used for when gestures start\n    _endTouchHandlers: function() {\n      document.removeEventListener(\"touchmove\", this._move);\n      document.removeEventListener(\"mousemove\", this._move);\n      document.removeEventListener(\"touchend\", this._end);\n      document.removeEventListener(\"mouseup\", this._end);\n    },\n\n    // Given an e, add things like x and y regardless of touch or mouse\n    _processEvent: function(e) {\n      // It's a touch\n      if (e.touches && e.touches.length > 0) {\n        e.x = e.touches[0].clientX;\n        e.y = e.touches[0].clientY;\n      } else if (e.clientX) {\n        // It's a click\n        e.x = e.clientX;\n        e.y = e.clientY;\n      } else if (e.pageX) {\n        // gesture events only get a layerx\n        e.x = e.pageX;\n        e.y = e.pageY;\n      } else {\n        // It's probably an end, there is no coords\n        e.x = this._lastX;\n        e.y = this._lastY;\n      }\n\n      e.distFromLeft = e.x - this._offset.x;\n      e.distFromTop = e.y - this._offset.y;\n\n      e.xFromLast = e.x - this._lastX;\n      e.yFromLast = e.y - this._lastY;\n    },\n\n    _processGesture: function(e) {\n      e.scaleFromLast = e.scale - this._lastScale;\n    }\n\n\n  };\n\n  return TapHandler;\n});",
    "\ndefine('sections/draw',[\"section\", \"tapHandler\"], function(Section, TapHandler) {\n\n  var Draw = Section.extend({\n    id: \"draw\",\n\n    _canvas: null,\n    _ctx: null,\n\n    // Offsets and scale\n    _transform: null,\n\n    // The lines we are drawing\n    _lines: null,\n\n    // Do we need to update on this frame?\n    _needsUpdate: true,\n\n    // Set this to false to stop the render loop\n    _shouldRender: false,\n\n    // The current tool, zoom or pan\n    _currentTool: \"pan\",\n\n    // When you move the mouse, what is the tool to use?\n    _currentPointTool: \"pencil\",\n\n    init: function() {\n      this._super();\n\n      this._canvas = document.getElementById('canvas');\n      this._ctx = canvas.getContext(\"2d\");\n      window.ctx = this._ctx;\n\n      this._transform = {\n        offsetX: 130,\n        offsetY: 260,\n        scale: 2\n      }\n\n      this._resize();\n\n      this._lines = [];\n      window.lines = this._lines;\n\n      this._resize = this._resize.bind(this);\n\n      new TapHandler(canvas, {\n        tap: this._tap.bind(this),\n        start: this._start.bind(this),\n        move: this._move.bind(this),\n        end: this._end.bind(this),\n        gesture: this._gesture.bind(this)\n      });\n\n      new TapHandler(document.getElementById(\"tools\"), {\n        tap: this._toolChanged.bind(this),\n        start: this._toolStart.bind(this),\n        end: this._toolEnd.bind(this)\n      });\n\n      canvas.addEventListener(\"mousewheel\", this._mouseWheel.bind(this));\n\n    },\n\n    show: function() {\n      this._shouldRender = true;\n      this._resize();\n      this._redraw();\n\n      window.addEventListener(\"resize\", this._resize);\n    },\n\n    hide: function() {\n      this._shouldRender = false;\n\n      window.removeEventListener(\"resize\", this._resize);\n    },\n\n    _resize: function() {\n      this._canvas.width = window.innerWidth;\n      this._canvas.height = window.innerHeight;\n\n      this._needsUpdate = true;\n    },\n\n    _zoom: function(x, y, scaleChange) {\n      // Can't zoom that far!\n      if (this._transform.scale + scaleChange < .001 || this._transform.scale + scaleChange > 20000) {\n        return;\n      }\n\n      var world = this._screenToWorld(x, y);\n      this._transform.scale += scaleChange;\n      var scr = this._worldToScreen(world.x, world.y);\n\n      var diffScr = {\n        x: x - scr.x,\n        y: y - scr.y\n      };\n\n      this._transform.offsetX += diffScr.x; // * this._transform.scale;\n      this._transform.offsetY += diffScr.y; // * this._transform.scale;\n\n      this._needsUpdate = true;\n    },\n\n    _pan: function(x, y) {\n      this._transform.offsetX += x;\n      this._transform.offsetY += y;\n\n      this._needsUpdate = true;\n    },\n\n    _mouseWheel: function(e) {\n\n      if (this._currentTool == \"pan\") {\n        //console.log(\"pan\", e);\n        this._pan(-e.deltaX, -e.deltaY);\n      } else if (this._currentTool == \"zoom\") {\n        if (e.deltaY != 0) {\n          //console.log(e);\n          this._zoom(e.offsetX, e.offsetY, e.deltaY / 100 * this._transform.scale);\n        }\n      }\n    },\n\n\n    _tap: function(e) {\n\n    },\n\n    _start: function(e) {\n      var world = this._screenToWorld(e.distFromLeft, e.distFromTop);\n      this._lines.push({\n        points: [world]\n      });\n    },\n\n    _move: function(e) {\n      var world = this._screenToWorld(e.distFromLeft, e.distFromTop);\n\n      //console.log(\"world\", e, world);\n      var currentLine = this._lines[this._lines.length - 1];\n\n      var points = currentLine.points;\n      var lastPoint = points[points.length - 1];\n\n\n      var dist = Math.sqrt(((lastPoint.x - world.x) * (lastPoint.x - world.x)) + ((lastPoint.y - world.y) * (lastPoint.y - world.y)));\n      //console.log(\"dist\", dist);\n\n      if (dist < 0.0003) {\n        return;\n      }\n\n      currentLine.points.push(world);\n      this._needsUpdate = true;\n    },\n\n    _end: function(e) {\n      var currentLine = this._lines[this._lines.length - 1];\n      var controlPoints = this._getCurveControlPoints(currentLine.points);\n\n      currentLine.controlPoints = controlPoints;\n    },\n\n    _gesture: function(e) {\n      this._pan(e.xFromLast, e.yFromLast);\n      this._zoom(e.x, e.y, e.scaleFromLast * this._transform.scale);\n    },\n\n    _redraw: function() {\n      // If we shouldn't render, exit the loop\n      if (!this._shouldRender) {\n        return;\n      }\n\n      if (this._needsUpdate) {\n        this._ctx.setTransform(this._transform.scale, 0, 0, this._transform.scale, this._transform.offsetX, this._transform.offsetY);\n\n        var topLeft = this._screenToWorld(0, 0);\n        var bottomRight = this._screenToWorld(canvas.width, canvas.height);\n\n        this._ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n\n        // Keep the line width the same no matter the zoom level\n        this._ctx.lineWidth = 1 / this._transform.scale;\n\n        for (var i = 0; i < this._lines.length; i++) {\n          var line = this._lines[i];\n\n          this._drawLine(this._ctx, line);\n        }\n\n        this._needsUpdate = false;\n      }\n\n      requestAnimationFrame(this._redraw.bind(this));\n    },\n\n    _drawLine: function(ctx, line) {\n      if (line.length < 2) {\n        return;\n      }\n\n      var controlPoints = [];\n      var points = line.points;\n      \n      if (!line.controlPoints) {\n        controlPoints = this._getCurveControlPoints(points);  \n      }\n      else {\n        controlPoints = line.controlPoints;\n      }\n\n      var point = points[0];\n\n      ctx.beginPath();\n      ctx.moveTo(point.x, point.y);\n\n      for (var i = 1; i < points.length; i++) {\n        point = points[i];\n        var cp1 = controlPoints.firstControlPoints[i - 1];\n        var cp2 = controlPoints.secondControlPoints[i - 1];\n        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, point.x, point.y);\n        //ctx.lineTo(point.x, point.y);\n      }\n\n      ctx.stroke();\n    },\n\n    _screenToWorld: function(x, y) {\n      return {\n        x: (x - this._transform.offsetX) / this._transform.scale,\n        y: (y - this._transform.offsetY) / this._transform.scale\n      };\n    },\n\n    _worldToScreen: function(x, y) {\n      return {\n        x: (x) * this._transform.scale + this._transform.offsetX,\n        y: (y) * this._transform.scale + this._transform.offsetY\n      };\n    },\n\n    _toolChanged: function(e) {\n      if (e.srcElement.tagName == \"LI\") {\n        this._currentTool = e.srcElement.dataset.tool;\n      }\n    },\n\n    _toolStart: function(e) {\n      if (e.srcElement.tagName == \"LI\") {\n        //this._currentPointTool = e.srcElement.dataset.tool;\n      }\n    },\n\n    _toolEnd: function(e) {\n      //this._currentPointTool = \"pencil\";\n    },\n\n\n\n    /*\n    // Create an image with all of the lines on it.\n    _save: function() {\n      // FIgure out the bounds of the lines\n      var top = lines[0].startY;\n      var left = lines[0].startX;\n      var bottom = lines[0].startY;\n      var right = lines[0].startX;\n\n      for (var i = 0; i < lines.length; i++) {\n        var top = Math.min(lines[i].startY, Math.min(lines[i].endY, top));\n        var left = Math.min(lines[i].startX, Math.min(lines[i].endX, top));\n        var bottom = Math.max(lines[i].startY, Math.max(lines[i].endY, top));\n        var right = Math.max(lines[i].startX, Math.max(lines[i].endX, top));\n      }\n\n      // Create a canvas large enough that it can contain the bounds\n      var width = right - left;\n      var height = bottom - top;\n\n      // Expand for some padding\n      var paddingX = width * .05;\n      var paddingY = height * .05;\n      width *= 1.1;\n      height *= 1.1;\n\n      var transformations = {\n        offsetX: paddingX,\n        offsetY: paddingY,\n        scale: 1\n      }\n\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = width;\n      canvas.height = height;\n\n      var ctx = canvas.getContext(\"2d\");\n    }\n*/\n    _getCurveControlPoints: function(knots) {\n      var n = knots.length - 1;\n\n      var firstControlPoints = [];\n      var secondControlPoints = [];\n\n      if (n < 1) {\n        console.error(\"Must have at least two knots\");\n        return;\n      }\n\n      if (n == 1) {\n        // Special case: should be a line\n        firstControlPoints.push({});\n        firstControlPoints[0].x = (2 * knots[0].x + knots[1].x) / 3;\n        firstControlPoints[0].y = (2 * knots[0].y + knots[1].y) / 3;\n\n        secondControlPoints.push({});\n        secondControlPoints[0].x = 2 * firstControlPoints[0].x - knots[0].x;\n        secondControlPoints[0].y = 2 * firstControlPoints[0].y - knots[0].y;\n\n        return {\n          firstControlPoints: firstControlPoints,\n          secondControlPoints: secondControlPoints\n        };\n      }\n\n      // Calculate first Bezier control points\n      // Right hand side vector\n      var rhs = new Array(n);\n\n\n      // Set right hand side X values\n      for (var i = 1; i < n - 1; ++i) {\n        rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n      }\n\n      rhs[0] = knots[0].x + 2 * knots[1].x;\n      rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2;\n\n      // Get first control points x-values\n      var x = this._getFirstControlPoints(rhs);\n\n      // Set right hand side Y values\n      for (var i = 1; i < n - 1; ++i) {\n        rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n      }\n\n      rhs[0] = knots[0].y + 2 * knots[1].y;\n      rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2;\n\n      // Get first control points Y-values\n      var y = this._getFirstControlPoints(rhs);\n\n      // Fill output arrays.\n      firstControlPoints = new Array(n);\n      secondControlPoints = new Array(n);\n\n      for (var i = 0; i < n; ++i) {\n        // First control point\n        firstControlPoints[i] = {\n          x: x[i],\n          y: y[i]\n        };\n\n        // Second control point\n        if (i < n - 1) {\n          secondControlPoints[i] = {\n            x: 2 * knots[i + 1].x - x[i + 1],\n            y: 2 * knots[i + 1].y - y[i + 1]\n          };\n        } else {\n          secondControlPoints[i] = {\n            x: (knots[n].x + x[n - 1]) / 2,\n            y: (knots[n].y + y[n - 1]) / 2\n          };\n        }\n\n      }\n\n\n      return {\n        firstControlPoints: firstControlPoints,\n        secondControlPoints: secondControlPoints\n      };\n    },\n\n    _getFirstControlPoints: function(rhs) {\n      var n = rhs.length;\n      var x = new Array(n); // Solution vector\n      var tmp = new Array(n); // Temp workspace\n\n      var b = 2.0;\n      x[0] = rhs[0] / b;\n\n      for (var i = 1; i < n; i++) { // Decomposition and forward substitution\n        tmp[i] = 1 / b;\n        b = (i < n - 1 ? 4 : 3.5) - tmp[i];\n        x[i] = (rhs[i] - x[i - 1]) / b;\n      }\n\n      for (var i = 1; i < n; i++) {\n        x[n - i - 1] -= tmp[n - i] * x[n - i]; // backsubstituion\n      }\n\n      return x;\n    },\n\n    _bezier: function() {\n      ctx.beginPath();\n      ctx.moveTo(20, 20);\n      ctx.bezierCurveTo(20, 100, 200, 100, 200, 20);\n      ctx.stroke();\n\n      // rect\n      ctx.lineWidth = 10;\n      ctx.strokeRect(20, 20, 80, 100);\n\n      ctx.beginPath();\n      ctx.moveTo(20, 20);\n      ctx.quadraticCurveTo(20, 100, 200, 20);\n      ctx.stroke();\n    }\n\n  });\n\n  return Draw;\n\n});",
    "\nrequire([\"event\", \"sections/draw\"], function(Event, Draw) {\n\n  function init() {\n    window.log = console.log.bind(console);\n\n    document.addEventListener(\"touchmove\", function(e) {\n      e.preventDefault();\n    });\n\n    document.addEventListener(\"mousewheel\", function(e) {\n      e.preventDefault();\n    });\n    \n    var draw = new Draw();\n    draw.show();\n  }\n\n  if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n    init();\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", init, false);\n  }\n});\ndefine(\"main\", function(){});\n"
  ]
}