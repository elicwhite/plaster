{
  "version": 3,
  "file": "/Users/eli/projects/draw/build/javascript/main.min.js",
  "sources": [
    "../../node_modules/grunt-requirejs/node_modules/almond/almond.js",
    "event.js",
    "globals.js",
    "class.js",
    "section.js",
    "tapHandler.js",
    "gauth.js",
    "sections/login.js",
    "helpers.js",
    "dataLayer/file.js",
    "vendor/db.js",
    "dataLayer/IndexedDBBacking.js",
    "dataLayer/DriveBacking.js",
    "dataLayer/data.js",
    "templates/fileList.js",
    "components/drawCanvas.js",
    "components/manipulateCanvas.js",
    "components/thumbnail.js",
    "sections/fileList.js",
    "sections/draw.js",
    "managers/files.js",
    "sections/main.js",
    "managers/login.js",
    "main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA,ADuEA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9QA,AD+QA;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA,ADoBA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5JA,AD6JA;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACraA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnoBA,ADooBA;ACnoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClaA,ADmaA;AClaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA,ADmBA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtMA,ADuMA;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjmBA,ADkmBA;ACjmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA,ADyFA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA,ADgEA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\n/**\n * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n",
    "\ndefine('event',[], function() {\n\n  function Event() {\n    this.init();\n  }\n\n  Event.prototype = {\n    listeners: null,\n\n    init: function() {\n      this.listeners = [];\n    },\n\n    addListener: function(event, callback) {\n      if (!this.listeners[event]) {\n        this.listeners[event] = [];\n      }\n\n      this.listeners[event].push(callback);\n    },\n\n    removeListener: function(event, callback) {\n      if (!this.listeners[event]) {\n        return false;\n      }\n\n      for(var i = 0; i < this.listeners[event].length; i++) {\n        if (this.listeners[event][i] == callback) {\n          this.listeners[event] = this.listeners[event].splice(i, 1);\n          return true;\n        }\n      }\n    },\n\n    trigger: function(event, data) {\n      if (!this.listeners[event]) {\n        return false;\n      }\n\n      console.log(\"Triggering\", event, data);\n\n      function callListener(listener) {\n        setTimeout(function() {\n          listener(data);\n        }, 0);\n      }\n\n      for(var i = 0; i < this.listeners[event].length; i++) {\n        callListener(this.listeners[event][i]);\n      }\n\n      return true;\n    }\n  }\n\n  return new Event(); \n\n});",
    "\ndefine('globals',[], function() {\n  return {\n    isiOS: function() {\n      return this.hasDeviceType(\"iOS\");\n    },\n\n    isPC: function() {\n      return this.hasDeviceType(\"PC\");\n    },\n\n    isMac: function() {\n      return this.hasDeviceType(\"Mac\");\n    },\n\n    isComputer: function() {\n      return this.hasDeviceType(\"computer\");\n    },\n\n    isPhone: function() {\n      return this.hasDeviceType(\"phone\");\n    },\n\n    hasDeviceType: function(type) {\n      return this.getDeviceType().indexOf(type) !== -1;\n    },\n\n    getDeviceType: function() {\n      if (localStorage.deviceType) {\n        //return JSON.parse(localStorage.deviceType);\n      }\n\n      var devices = [];\n      var userAgent = navigator.userAgent;\n\n      if (userAgent.match(/OS 7/g)) {\n        devices.push(\"iOS\");\n\n        if (userAgent.match(/iPad/g)) {\n          devices.push(\"iPad\");\n          devices.push(\"tablet\");\n        }\n        else if (userAgent.match(/iPhone/g)) {\n          devices.push(\"iPhone\");\n          devices.push(\"phone\");\n        }\n      }\n      else if (userAgent.match(/Mac/g)) {\n        devices.push(\"Mac\");\n        devices.push(\"computer\");\n      }\n      else\n      {\n        devices.push(\"PC\");\n        devices.push(\"computer\");\n      }\n\n\n\n      localStorage.deviceType = JSON.stringify(devices);\n\n      return devices;\n    },\n\n    setHTMLDevices: function() {\n      var devices = this.getDeviceType();\n\n      var body = document.body;\n      body.className = devices.join(\" \");\n    }\n  }\n});",
    "\ndefine('class',[], function() {\n\t/* Simple Javascript inheritance by John Resig */\n\n\tvar initializing = false,\n\t\tfnTest = /xyz/.test(function() {\n\t\t\txyz;\n\t\t}) ? /\\b_super\\b/ : /.*/;\n\n\t// The base CClass implementation (does nothing)\n\tthis.Class = function() {};\n\n\t// Create a new CLass that inherits from this class\n\tClass.extend = function(prop) {\n\t\tvar _super = this.prototype;\n\n\t\t// Instantiate a base class (but only create the instance, don't run the consutrcutor)\n\t\tinitializing = true;\n\t\tvar prototype = new this();\n\t\tinitializing = false;\n\n\t\t// Copy the properties over onto the new prototype\n\t\tfor (var name in prop) {\n\t\t\t// Check if we're overwriting an existing function\n\t\t\tprototype[name] = typeof prop[name] == \"function\" && typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n\t\t\t\t(function(name, fn) {\n\t\t\t\treturn function() {\t\t\t\t\n\t\t\t\t\tvar tmp = this._super;\n\n\t\t\t\t\t// Add a new ._super() method that is the same method\n\t\t\t\t\t// but on the super-class\n\t\t\t\t\tthis._super = _super[name];\n\n\t\t\t\t\t// The method only need to be bound temporarily, so we\n\t\t\t\t\t// remove it when we're done executing\n\n\t\t\t\t\tvar ret = fn.apply(this, arguments);\n\t\t\t\t\tthis._super = tmp;\n\n\t\t\t\t\treturn ret;\n\t\t\t\t};\n\t\t\t})(name, prop[name]) : prop[name];\n\t\t}\n\n\t\t// The dummy class constructor\n\n\t\tfunction Class() {\n\t\t\t// All construction is actually done in the init method\n\t\t\tif (!initializing && this.init)\n\t\t\t\tthis.init.apply(this, arguments);\n\t\t}\n\n\t\t// Populate our constructed prototype object\n\t\tClass.prototype = prototype;\n\n\t\t// Enforce the constructor to be what we expect\n\t\tClass.prototype.constructor = Class;\n\n\t\t// And make this class extendable\n\t\tClass.extend = arguments.callee;\n\n\t\treturn Class;\n\n\t};\n\n\treturn this.Class;\n});",
    "\ndefine('section',[\"class\"], function(Class) {\n\n\tvar Section = Class.extend({\n\t\tid: null,\n\t\telement: null,\n\n\t\tinit: function() {\n\t\t\tthis.element = document.getElementById(this.id);\n\t\t},\n\n\t\tshow: null,\n\t\thide: null,\n\n\t\tafterShow: function() {\n\t\t\tthis.element.style.display = \"block\";\n\t\t},\n\n\t\tafterHide: function() {\n\t\t\tthis.element.style.display = \"\";\n\t\t}\n\n\t});\n\n\treturn Section;\n});",
    "\ndefine('tapHandler',[], function() {\n  function TapHandler(element, options) {\n    this.init(element, options);\n  }\n\n  TapHandler.prototype = {\n    _element: null,\n    _options: null,\n\n    _distCutoff: 20,\n    _timeCutoff: 500,\n\n    // touch or mouse\n    _startType: null,\n    _startTouchId: null,\n    _startTime: null,\n    _startX: null,\n    _startY: null,\n\n    _startScale: null,\n\n    _lastX: null,\n    _lastY: null,\n\n    _lastScale: null,\n\n    // Object with x and why of where the element is on the page\n    _offset: null,\n\n    _inTouch: false,\n    _inGesture: false,\n\n    _ignoreGestures: false,\n\n    init: function(element, options) {\n      this._element = element;\n      this._options = options;\n\n      // Replace with binded events\n      this._move = this._move.bind(this);\n      this._end = this._end.bind(this);\n      this._gestureChange = this._gestureChange.bind(this);\n      this._gestureEnd = this._gestureEnd.bind(this);\n\n      this._offset = {\n        x: element.offsetLeft,\n        y: element.offsetTop\n      };\n\n      this._element.addEventListener(\"mousedown\", this._start.bind(this));\n      this._element.addEventListener(\"touchstart\", this._start.bind(this));\n      this._element.addEventListener(\"gesturestart\", this._gestureStart.bind(this));\n    },\n\n    ignoreGestures: function(value) {\n      this._ignoreGestures = value;\n    },\n\n\n    _start: function(e) {\n      if (e.touches) {\n        // start touch is the last touch\n        this._startTouchId = e.touches[e.touches.length - 1].identifier;\n      }\n\n      this._processEvent(e);\n\n      // Ignore these if we are currently gesturing\n      if (this._inGesture) {\n        return;\n      }\n\n      this._startType = \"mouse\";\n      if (e.touches) {\n        this._startType = \"touch\";\n      }\n\n      this._inTouch = true;\n\n\n      this._startTime = e.timeStamp;\n\n      this._startX = this._lastX = e.x;\n      this._startY = this._lastY = e.y;\n\n      if (this._options.start) {\n        this._options.start(e);\n      }\n\n      if (this._startType == \"touch\") {\n        document.addEventListener(\"touchmove\", this._move);\n        document.addEventListener(\"touchend\", this._end);\n      } else if (this._startType == \"mouse\") {\n        document.addEventListener(\"mousemove\", this._move);\n        document.addEventListener(\"mouseup\", this._end);\n      }\n    },\n\n    _move: function(e) {\n      this._processEvent(e);\n\n      this._lastX = e.x;\n      this._lastY = e.y;\n\n      if (this._options.move) {\n        this._options.move(e);\n      }\n    },\n\n    _end: function(e) {\n      /*\n        if e isn't set, end the handlers, call tap if it is within limits, call end\n      */\n\n      if (!e) {\n        this._endTouchHandlers();\n        if (this._options.end) {\n          this._options.end();\n        }\n\n        return;\n      }\n\n      e.wasTap = false;\n\n      // The event still has our start touch, it hasn't ended\n      if (e.touches && this._indexOfTouch(e, this._startTouchId) !== -1) {\n        return;\n      }\n\n      this._endTouchHandlers();\n      this._processEvent(e);\n\n      var dist = Math.sqrt(((e.x - this._startX) * (e.x - this._startX)) + ((e.y - this._startY) * (e.y - this._startY)));\n\n      if (dist < this._distCutoff && (e.timeStamp - this._startTime < this._timeCutoff)) {\n        e.wasTap = true;\n        if (this._options.tap) {\n          this._options.tap(e);\n        }\n      }\n\n      // It wasn't a tap, just an up\n      if (this._options.end) {\n        this._options.end(e);\n      }\n\n      this._inTouch = false;\n\n      // Keep mouse events from being called\n      if (e) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n    },\n\n    _gestureStart: function(e) {\n      if (this._ignoreGestures) {\n        return;\n      }\n\n      this._inGesture = true;\n\n      // We need to end the touch\n      this._end();\n\n\n      this._processEvent(e);\n      this._processGesture(e);\n\n      this._startTime = e.timeStamp;\n\n      this._startX = this._lastX = e.x;\n      this._startY = this._lastY = e.y;\n\n      this._startScale = this._lastScale = e.scale;\n\n      document.addEventListener(\"gesturechange\", this._gestureChange);\n      document.addEventListener(\"gestureend\", this._gestureEnd);\n    },\n\n    _gestureChange: function(e) {\n      this._processEvent(e);\n      this._processGesture(e);\n\n      this._lastX = e.x;\n      this._lastY = e.y;\n      this._lastScale = e.scale;\n\n      this._lastScale = e.scale;\n\n      if (this._options.gesture) {\n        this._options.gesture(e);\n      }\n    },\n\n    _gestureEnd: function(e) {\n      this._processEvent(e);\n      this._processGesture(e);\n\n      document.removeEventListener(\"gesturechange\", this._gestureChange);\n      document.removeEventListener(\"gestureend\", this._gestureEnd);\n\n      this._inGesture = false;\n    },\n\n    // Unregister the regular touch handlers, used for when gestures start\n    _endTouchHandlers: function() {\n      if (this._startType == \"touch\") {\n        document.removeEventListener(\"touchmove\", this._move);\n        document.removeEventListener(\"touchend\", this._end);\n      } else if (this._startType == \"mouse\") {\n        document.removeEventListener(\"mousemove\", this._move);\n        document.removeEventListener(\"mouseup\", this._end);\n      }\n    },\n\n    // Given an e, add things like x and y regardless of touch or mouse\n    _processEvent: function(e) {\n      e.isTouch = e.touches ? true : false;\n\n      var index = -1;\n      // It's a touch\n      if (e.touches && e.touches.length > 0 && (index = this._indexOfTouch(e, this._startTouchId)) !== -1) {\n        // Use the last touch\n        e.x = e.touches[index].clientX;\n        e.y = e.touches[index].clientY;\n      } else if (e.clientX) {\n        // It's a click\n        e.x = e.clientX;\n        e.y = e.clientY;\n      } else if (e.pageX) {\n        // gesture events only get a layerx\n        e.x = e.pageX;\n        e.y = e.pageY;\n      } else {\n        // It's probably an end, there is no coords\n        e.x = this._lastX;\n        e.y = this._lastY;\n      }\n\n      e.distFromLeft = e.x - this._offset.x;\n      e.distFromTop = e.y - this._offset.y;\n\n      e.xFromLast = e.x - this._lastX;\n      e.yFromLast = e.y - this._lastY;\n    },\n\n    _processGesture: function(e) {\n      e.scaleFromLast = e.scale - this._lastScale;\n    },\n\n    _indexOfTouch: function(e, identifier) {\n      var index = -1;\n      if (e.touches && identifier) {\n        for (var i = 0; i < e.touches.length; i++) {\n          if (e.touches[i].identifier == identifier) {\n            index = i;\n            break;\n          }\n        }\n      }\n\n      return index;\n    }\n\n\n  };\n\n  return TapHandler;\n});",
    "\ndefine('gauth',[\"class\", \"event\"], function(Class, Event) {\n  var GAuth = Class.extend({\n    _clientId: '450627732299-2d7jlo96ious5jmdmsd9t7hpclstf7ub.apps.googleusercontent.com',\n    _user: null,\n\n    _startCallback: null,\n\n    INSTALL_SCOPE: 'https://www.googleapis.com/auth/drive.install',\n    FILE_SCOPE: 'https://www.googleapis.com/auth/drive.file',\n    OPENID_SCOPE: 'openid',\n\n    init: function() {\n    },\n\n    start: function(callback) {\n      if (window.gapi) {\n        this._startCallback = callback;\n\n        gapi.load('auth:client,drive-realtime,drive-share', (function() {\n          this._authorize();\n        }).bind(this));\n      } else {\n        console.log(\"Offline mode\");\n      }\n    },\n\n    _authorize: function() {\n      // Try with no popups first.\n      gapi.auth.authorize({\n        client_id: this._clientId,\n        scope: [\n          this.INSTALL_SCOPE,\n          this.FILE_SCOPE,\n          this.OPENID_SCOPE\n        ],\n        immediate: true\n      }, this._handleAuthResult.bind(this));\n    },\n\n    _handleAuthResult: function(authResult) {\n      if (authResult && !authResult.error) {\n        // logged in\n        Event.trigger(\"login\", authResult);\n        this._fetchUser();\n\n        if (this._startCallback) {\n          this._startCallback();\n        }\n\n      } else {\n        Event.trigger(\"logout\", authResult);\n      }\n    },\n\n    authorizeWithPopup: function() {\n      gapi.auth.authorize({\n        client_id: this._clientId,\n        scope: [\n          this.INSTALL_SCOPE,\n          this.FILE_SCOPE,\n          this.OPENID_SCOPE\n        ],\n        immediate: false\n      }, this._handleAuthResult.bind(this));\n    },\n\n    _fetchUser: function() {\n      gapi.client.load('oauth2', 'v2', (function() {\n        gapi.client.oauth2.userinfo.get().execute((function(resp) {\n          if (resp.id) {\n            this._user = resp;\n          }\n        }).bind(this));\n      }).bind(this));\n    }\n  });\n\n  return new GAuth();\n});",
    "\ndefine('sections/login',[\"event\", \"section\", \"tapHandler\", \"gauth\"], function(Event, Section, TapHandler, GAuth) {\n\n  var Login = Section.extend({\n    id: \"login\",\n\n    init: function() {\n      this._super();\n      \n      var button = document.getElementById(\"loginbutton\");\n      new TapHandler(button, {tap: this._loginClicked.bind(this) });\n    },\n\n    _loginClicked: function() {\n      GAuth.authorizeWithPopup();\n    },\n  });\n\n  return Login;\n\n});",
    "\ndefine('helpers',[], function() {\n  return {\n    parentEleWithClassname: function(ele, className) {\n      if (ele == null || !ele.classList) {\n        return false;\n      }\n\n      if (ele.classList.contains(className)) {\n        return ele;\n      }\n\n      return this.parentEleWithClassname(ele.parentNode, className);\n    },\n\n\n    screenToWorld: function(settings, x, y) {\n      return {\n        x: (x - settings.offsetX) / settings.scale,\n        y: (y - settings.offsetY) / settings.scale\n      };\n    },\n\n    worldToScreen: function(settings, x, y) {\n      return {\n        x: (x) * settings.scale + settings.offsetX,\n        y: (y) * settings.scale + settings.offsetY\n      };\n    },\n\n    getGuid: function() {\n      return \"T^\" + Date.now() + \"\" + Math.round(Math.random() * 1000000);\n    },\n\n    isLocalGuid: function(id) {\n      return id.indexOf(\"T^\") === 0;\n    },\n\n    clone: function(obj) {\n      var newObj = {};\n      for (var prop in obj) {\n        newObj[prop] = obj[prop];\n      }\n\n      return newObj;\n    },\n\n    getCurveControlPoints: function(knots) {\n\n      function getFirstControlPoints(rhs) {\n        var n = rhs.length;\n        var x = new Array(n); // Solution vector\n        var tmp = new Array(n); // Temp workspace\n\n        var b = 2.0;\n        x[0] = rhs[0] / b;\n\n        for (var i = 1; i < n; i++) { // Decomposition and forward substitution\n          tmp[i] = 1 / b;\n          b = (i < n - 1 ? 4 : 3.5) - tmp[i];\n          x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (var i = 1; i < n; i++) {\n          x[n - i - 1] -= tmp[n - i] * x[n - i]; // backsubstituion\n        }\n\n        return x;\n      };\n\n\n      var n = knots.length - 1;\n\n      var firstControlPoints = [];\n      var secondControlPoints = [];\n\n      if (n < 1) {\n        console.error(\"Must have at least two knots\");\n        return;\n      }\n\n      if (n == 1) {\n        // Special case: should be a line\n        firstControlPoints.push([]);\n        firstControlPoints[0] = [(2 * knots[0][0] + knots[1][0]) / 3, (2 * knots[0][1] + knots[1][1]) / 3];\n\n        secondControlPoints.push([]);\n        secondControlPoints[0] = [2 * firstControlPoints[0][0] - knots[0][0], 2 * firstControlPoints[0][1] - knots[0][1]];\n\n        return [[\n          firstControlPoints[0],\n          secondControlPoints[0]\n        ]];\n      }\n\n      // Calculate first Bezier control points\n      // Right hand side vector\n      var rhs = new Array(n);\n\n\n      // Set right hand side X values\n      for (var i = 1; i < n - 1; ++i) {\n        rhs[i] = 4 * knots[i][0] + 2 * knots[i + 1][0];\n      }\n\n      rhs[0] = knots[0][0] + 2 * knots[1][0];\n      rhs[n - 1] = (8 * knots[n - 1][0] + knots[n][0]) / 2;\n\n      // Get first control points x-values\n      var x = getFirstControlPoints(rhs);\n\n      // Set right hand side Y values\n      for (var i = 1; i < n - 1; ++i) {\n        rhs[i] = 4 * knots[i][1] + 2 * knots[i + 1][1];\n      }\n\n      rhs[0] = knots[0][1] + 2 * knots[1][1];\n      rhs[n - 1] = (8 * knots[n - 1][1] + knots[n][1]) / 2;\n\n      // Get first control points Y-values\n      var y = getFirstControlPoints(rhs);\n\n      // Fill output arrays.\n      firstControlPoints = new Array(n);\n      secondControlPoints = new Array(n);\n\n      for (var i = 0; i < n; ++i) {\n        // First control point\n        firstControlPoints[i] = [\n          x[i],\n          y[i]\n        ];\n\n        // Second control point\n        if (i < n - 1) {\n          secondControlPoints[i] = [\n            2 * knots[i + 1][0] - x[i + 1],\n            2 * knots[i + 1][1] - y[i + 1]\n          ];\n        } else {\n          secondControlPoints[i] = [\n            (knots[n][0] + x[n - 1]) / 2, (knots[n][1] + y[n - 1]) / 2\n          ];\n        }\n      }\n\n      var controlPoints = new Array(n);\n      for (var i = 0; i < n; ++i) {\n        controlPoints[i] = [\n          firstControlPoints[i],\n          secondControlPoints[i]\n        ];\n      }\n\n      return controlPoints;\n    },\n  };\n});",
    "\ndefine('dataLayer/file',[\"class\", \"event\", \"helpers\"], function(Class, Event, Helpers) {\n  var File = Class.extend({\n    fileInfo: null,\n\n    _cachedActions: null,\n\n    _backing: null,\n    _driveBacking: null,\n\n    _addedCallback: null,\n    _removedCallback: null,\n\n    _loadCallbacks: null,\n\n    init: function(backing) {\n      // Create our backing instance\n      this._backing = backing;\n\n      this._loadCallbacks = [];\n    },\n\n    remoteActionsMatch: function(fileId, driveBacking, callback) {\n      this._backing.load(fileId, (function(localInfo) {\n\n        this.fileInfo = localInfo;\n\n        driveBacking.load(fileId, (function() {\n          this._backing.getActions((function(localActions) {\n            driveBacking.getActions((function(remoteActions) {\n\n              // If the lengths don't match, they aren't equal\n              if (localActions.remote.length != remoteActions) {\n                callback(false);\n                return;\n              }\n\n              for (var i = 0; i < localActions.remote.length; i++) {\n                if (localActions.remote[i].id != remoteActions[i]) {\n                  callback(false);\n                  return;\n                }\n              }\n\n              callback(true);\n              return;\n            }).bind(this));\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    load: function(fileId, callback) {\n      this._backing.load(fileId, (function(fileInfo) {\n        var actionsObj = {\n          remoteActions: [],\n          localActions: [],\n          redoStack: []\n        };\n\n        this._backing.getActions((function(actions) {\n          actionsObj.remoteActions = actions.remote;\n          actionsObj.localActions = actions.local;\n\n          this.fileInfo = fileInfo;\n          this._cachedActions = actionsObj;\n\n          callback();\n\n          // now that we have loaded, make sure we call all the things that\n          // want to know when we are loaded\n          for (var i = 0; i < this._loadCallbacks.length; i++) {\n            var loadCallback = this._loadCallbacks[i];\n            loadCallback.func.apply(this, loadCallback.args);\n          }\n        }).bind(this));\n      }).bind(this));\n    },\n\n    create: function(file, callback) {\n      this._backing.create(file, (function() {\n        this.load(file.id, function() {\n          callback();\n        });\n      }).bind(this));\n    },\n\n    afterLoad: function(callback) {\n      // If we have already loaded, call the callback immediately\n      if (this.fileInfo) {\n        callback();\n        return;\n      }\n\n      this._doAfterLoad(callback, []);\n    },\n\n    _doAfterLoad: function(func, args) {\n      this._loadCallbacks.push({\n        func: func,\n        args: args\n      })\n    },\n\n    rename: function(newName) {\n      this.fileInfo.name = newName;\n      this._backing.rename(newName);\n\n      if (this._driveBacking) {\n        this._driveBacking.rename(newName);\n      }\n\n      Event.trigger(\"fileRenamed\", this.fileInfo);\n      Event.trigger(\"fileModified\", this.fileInfo);\n    },\n\n    startDrive: function(driveBacking) {\n      if (!this.fileInfo) {\n        this._doAfterLoad(this.startDrive, [driveBacking]);\n        return;\n      }\n\n      // process things on drive for updates\n      driveBacking.listen(this._remoteActionsAdded.bind(this), this._remoteActionsRemoved.bind(this));\n\n      this.sync(driveBacking);\n\n    },\n\n    sync: function(driveBacking) {\n      driveBacking = this._driveBacking || driveBacking;\n\n      // if this fileId exists on drive, great, it's a match\n      // if it doesn't, then it either has never been uploaded, or was deleted on the server\n      // regardless, it's open, so we should upload it to drive\n\n      driveBacking._parent.getFiles((function(driveFiles) {\n\n        var found = false;\n        for (var i in driveFiles) {\n          if (driveFiles[i].id == this.fileInfo.id) {\n            found = i;\n            break;\n          }\n        }\n\n        if (found !== false) {\n          console.log(\"Found file\", this.fileInfo.id, \"on drive\");\n          // the file was found on drive\n          // load it and sync actions\n          // sync actions\n\n          this._driveBacking = driveBacking;\n\n          if (driveFiles[i].title != this.fileInfo.name) {\n            // File names don't match, remote wins\n            this.rename(driveFiles[i].title);\n          }\n\n          this._syncRemoteActionsFromDrive();\n        } else {\n          console.log(\"File not found on drive\", this.fileInfo.id);\n          // this file was not found\n          // so we will create a new file on drive, \n          // and then copy everything over to it\n\n          var oldId = this.fileInfo.id;\n\n          driveBacking.create(this.fileInfo, (function(newFile) {\n            this._driveBacking = driveBacking;\n\n            // Google saved a file, redo the id of the file locally to match drive\n            this._backing.replaceFileId(newFile.id, (function() {\n              this.load(newFile.id, (function() {\n                this._moveSettings(oldId);\n\n                Event.trigger(\"fileIdChanged\", {\n                  oldId: oldId,\n                  newId: this.fileInfo.id\n                });\n              }).bind(this));\n            }).bind(this));\n          }).bind(this));\n        }\n      }).bind(this));\n    },\n\n    listen: function(addedCallback, removedCallback) {\n      this._addedCallback = addedCallback;\n      this._removedCallback = removedCallback;\n    },\n\n    stopListening: function() {\n      this._addedCallback = null;\n      this._removedCallback = null;\n    },\n\n    getActions: function() {\n      return this._cachedActions.remoteActions.concat(this._cachedActions.localActions);\n    },\n\n    localSettings: function(settings) {\n      if (settings) {\n        localStorage[this.fileInfo.id] = JSON.stringify(settings);\n      }\n\n      if (!localStorage[this.fileInfo.id]) {\n        localStorage[this.fileInfo.id] = JSON.stringify({\n          offsetX: 0,\n          offsetY: 0,\n          scale: 1,\n          color: \"#000\",\n          tools: {\n            point: \"pencil\",\n            gesture: null,\n            scroll: \"pan\"\n          }\n        });\n      }\n\n      return JSON.parse(localStorage[this.fileInfo.id]);\n    },\n\n    _moveSettings: function(oldId) {\n      if (localStorage[oldId]) {\n        localStorage[this.fileInfo.id] = localStorage[oldId];\n        delete localStorage[oldId];\n      }\n    },\n\n    undo: function() {\n      if (this._driveBacking) {\n        this._driveBacking.undo();\n        return;\n      }\n\n      if (this._cachedActions.localActions.length == 0) {\n        return false; // no actions to undo\n      } else {\n        var lastAction = this._cachedActions.localActions.pop();\n        this._cachedActions.redoStack.push(lastAction);\n\n        this._backing.removeLocalAction(lastAction.id);\n\n        Event.trigger(\"actionRemoved\");\n        Event.trigger(\"fileModified\", this.fileInfo);\n      }\n    },\n\n    redo: function() {\n      if (this._driveBacking) {\n        this._driveBacking.redo();\n        return;\n      }\n\n      if (this._cachedActions.redoStack.length == 0) {\n        return false; // no actions to undo\n      } else {\n        var action = this._cachedActions.redoStack.pop();\n        this.addAction(action);\n\n        this._backing.addLocalAction(action);\n      }\n    },\n\n    addAction: function(action) {\n      this._cachedActions.localActions.push(action);\n\n      Event.trigger(\"actionAdded\", {\n        isLocal: true,\n        items: [action]\n      });\n\n      this._backing.addLocalAction(action);\n\n      if (this._driveBacking) {\n        this._driveBacking.addAction(action);\n      }\n\n      Event.trigger(\"fileModified\", this.fileInfo);\n    },\n\n    delete: function() {\n      this.close();\n      this._backing.delete();\n    },\n\n    close: function() {\n      console.log(\"Closing file\", this.fileInfo.id);\n      this._backing.close();\n\n      if (this._driveBacking) {\n        this._driveBacking.close();\n      }\n    },\n\n    _syncRemoteActionsFromDrive: function() {\n      this._driveBacking.load(this.fileInfo.id, (function() {\n        this._driveBacking.getActions((function(remoteActions) {\n          this._backing.getActions((function(localActions) {\n\n            // if local is shorter, then something was added to remote\n            // if remote is shorter, then something was removed from remote\n\n            this._cachedActions.remoteActions = remoteActions;\n\n            var shorter = remoteActions.length < localActions.remote.length ? remoteActions : localActions.remote;\n            var diverges = -1;\n\n            for (var j = 0; j < shorter.length; j++) {\n              if (remoteActions[j].id != localActions.remote[j].id) {\n                diverges = j;\n                break;\n              }\n            }\n\n            // Only modify things if we need to\n            if (diverges !== -1 || remoteActions.length != localActions.remote.length) {\n              console.log(\"Differences between remote and local actions\", this.fileInfo.id);\n\n              if (diverges != -1) {\n                // get the remote actions after the diverge\n                var remoteActionsAfterDiverge = remoteActions.slice(diverges);\n\n                // remove the actions in local after the diverge\n                this._backing.removeRemoteActions(diverges, localActions.remote.length - diverges);\n\n                // we need to add indexes to these items\n                var items = this._indexify(remoteActionsAfterDiverge, diverges);\n                this._backing.addRemoteActions(diverges, items);\n                // insert the remote actions after diverge into local actions\n              } else if (shorter == remoteActions) {\n                // remove the actions after diverge from local\n                this._backing.removeRemoteActions(remoteActions.length, localActions.remote.length - remoteActions.length);\n              } else {\n                // shorter must be the local one\n                // add the remote actions after the local ones\n                var remoteActionsAfterLocal = remoteActions.slice(localActions.remote.length);\n\n                var items = this._indexify(remoteActionsAfterLocal, localActions.remote.length);\n                this._backing.addRemoteActions(localActions.remote.length, items);\n              }\n\n              Event.trigger(\"actionAdded\", {\n                isLocal: false,\n                items: []\n              });\n            }\n\n            // send all of the local actions\n            for (var j = 0; j < localActions.local.length; j++) {\n              this._driveBacking.addAction(localActions.local[j]);\n            }\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n\n      // and the remote has all the local actions\n    },\n\n    _remoteActionsAdded: function(data) {\n      if (data.isLocal) {\n        // go through each item to insert\n        for (var i = 0; i < data.values.length; i++) {\n          // delete them from local\n          for (var j = 0; j < this._cachedActions.localActions.length; j++) {\n            if (this._cachedActions.localActions[j].id == data.values[i].id) {\n              this._cachedActions.localActions.splice(j, 1);\n              break;\n            }\n          }\n\n          this._backing.removeLocalAction(data.values[i].id);\n        }\n      }\n\n      // put the items into the remoteActions\n      Array.prototype.splice.apply(this._cachedActions.remoteActions, [data.index, 0].concat(data.values));\n\n      var items = this._indexify(data.values, data.index);\n\n      // insert them into storage\n      this._backing.addRemoteActions(data.index, items);\n\n      if (this._addedCallback) {\n        this._addedCallback({\n          isLocal: data.isLocal,\n          items: items\n        });\n      }\n\n      Event.trigger(\"fileModified\", this.fileInfo);\n    },\n\n    _remoteActionsRemoved: function(data) {\n      // remove it from the remoteActions\n      this._cachedActions.remoteActions.splice(data.index, data.values.length);\n\n      this._backing.removeRemoteActions(data.index, data.values.length);\n\n      if (this._removedCallback) {\n        this._removedCallback();\n      }\n\n      Event.trigger(\"fileModified\", this.fileInfo);\n    },\n\n    _indexify: function(actions, startIndex) {\n      var items = [];\n      // put indexes on the items\n      for (var i = 0; i < actions.length; i++) {\n        var item = Helpers.clone(actions[i]);\n        item.index = i + startIndex;\n        items.push(item);\n      }\n\n      return items;\n    },\n  });\n\n  return File;\n});",
    "\ndefine('db',[], function() {\n    'use strict';\n    var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB,\n        IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange,\n        transactionModes = {\n            readonly: 'readonly',\n            readwrite: 'readwrite'\n        };\n        \n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    if ( !indexedDB ) {\n        console.warn('IndexedDB required');\n        return;\n    }\n\n    var defaultMapper = function (value) {\n        return value;\n    };\n\n    var CallbackList = function () {\n        var state,\n            list = [];\n\n        var exec = function ( context , args ) {\n            if ( list ) {\n                args = args || [];\n                state = state || [ context , args ];\n\n                for ( var i = 0 , il = list.length ; i < il ; i++ ) {\n                    list[ i ].apply( state[ 0 ] , state[ 1 ] );\n                }\n\n                list = [];\n            }\n        };\n\n        this.add = function () {\n            for ( var i = 0 , il = arguments.length ; i < il ; i ++ ) {\n                list.push( arguments[ i ] );\n            }\n\n            if ( state ) {\n                exec();\n            }\n\n            return this;\n        };\n\n        this.execute = function () {\n            exec( this , arguments );\n            return this;\n        };\n    };\n\n    var Deferred = function ( func ) {\n        var state = 'progress',\n            actions = [\n                [ 'resolve' , 'done' , new CallbackList() , 'resolved' ],\n                [ 'reject' , 'fail' , new CallbackList() , 'rejected' ],\n                [ 'notify' , 'progress' , new CallbackList() ],\n            ],\n            deferred = {},\n            promise = {\n                state: function () {\n                    return state;\n                },\n                then: function ( /* doneHandler , failedHandler , progressHandler */ ) {\n                    var handlers = arguments;\n\n                    return Deferred(function ( newDefer ) {\n                        actions.forEach(function ( action , i ) {\n                            var handler = handlers[ i ];\n\n                            deferred[ action[ 1 ] ]( typeof handler === 'function' ?\n                                function () {\n                                    var returned = handler.apply( this , arguments );\n\n                                    if ( returned && typeof returned.promise === 'function' ) {\n                                        returned.promise()\n                                            .done( newDefer.resolve )\n                                            .fail( newDefer.reject )\n                                            .progress( newDefer.notify );\n                                    }\n                                } : newDefer[ action[ 0 ] ]\n                            );\n                        });\n                    }).promise();\n                },\n                promise: function ( obj ) {\n                    if ( obj ) {\n                        Object.keys( promise )\n                            .forEach(function ( key ) {\n                                obj[ key ] = promise[ key ];\n                            });\n\n                        return obj;\n                    }\n                    return promise;\n                }\n            };\n\n        actions.forEach(function ( action , i ) {\n            var list = action[ 2 ],\n                actionState = action[ 3 ];\n\n            promise[ action[ 1 ] ] = list.add;\n\n            if ( actionState ) {\n                list.add(function () {\n                    state = actionState;\n                });\n            }\n\n            deferred[ action[ 0 ] ] = list.execute;\n        });\n\n        promise.promise( deferred );\n\n        if ( func ) {\n            func.call( deferred , deferred );\n        }\n\n        return deferred;\n    };\n\n    var Server = function ( db , name ) {\n        var that = this,\n            closed = false;\n\n        this.add = function( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n\n            var records = [];\n            for (var i = 0; i < arguments.length - 1; i++) {\n                records[i] = arguments[i + 1];\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n            \n            records.forEach( function ( record ) {\n                var req;\n                if ( record.item && record.key ) {\n                    var key = record.key;\n                    record = record.item;\n                    req = store.add( record , key );\n                } else {\n                    req = store.add( record );\n                }\n\n                req.onsuccess = function ( e ) {\n                    var target = e.target;\n                    var keyPath = target.source.keyPath;\n                    if ( keyPath === null ) {\n                        keyPath = '__id__';\n                    }\n                    Object.defineProperty( record , keyPath , {\n                        value: target.result,\n                        enumerable: true\n                    });\n                    deferred.notify();\n                };\n            } );\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( records , e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( records , e );\n            };\n            return deferred.promise();\n        };\n\n        this.update = function( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n\n            var records = [];\n            for ( var i = 0 ; i < arguments.length - 1 ; i++ ) {\n                records[ i ] = arguments[ i + 1 ];\n            }\n\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                keyPath = store.keyPath,\n                deferred = Deferred();\n\n            records.forEach( function ( record ) {\n                var req;\n                if ( record.item && record.key ) {\n                    var key = record.key;\n                    record = record.item;\n                    req = store.put( record , key );\n                } else {\n                    req = store.put( record );\n                }\n\n                req.onsuccess = function ( e ) {\n                    deferred.notify();\n                };\n            } );\n            \n            transaction.oncomplete = function () {\n                deferred.resolve( records , that );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( records , e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( records , e );\n            };\n            return deferred.promise();\n        };\n        \n        this.remove = function ( table , key ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n            \n            var req = store.delete( key );\n            transaction.oncomplete = function ( ) {\n                deferred.resolve( key );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.clear = function ( table ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table , transactionModes.readwrite ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var req = store.clear();\n            transaction.oncomplete = function ( ) {\n                deferred.resolve( );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n        \n        this.close = function ( ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            db.close();\n            closed = true;\n            delete dbCache[ name ];\n        };\n\n        this.get = function ( table , id ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            var transaction = db.transaction( table ),\n                store = transaction.objectStore( table ),\n                deferred = Deferred();\n\n            var req = store.get( id );\n            req.onsuccess = function ( e ) {\n                deferred.resolve( e.target.result );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        this.query = function ( table , index ) {\n            if ( closed ) {\n                throw 'Database has been closed';\n            }\n            return new IndexQuery( table , db , index );\n        };\n\n        for ( var i = 0 , il = db.objectStoreNames.length ; i < il ; i++ ) {\n            (function ( storeName ) {\n                that[ storeName ] = { };\n                for ( var i in that ) {\n                    if ( !hasOwn.call( that , i ) || i === 'close' ) {\n                        continue;\n                    }\n                    that[ storeName ][ i ] = (function ( i ) {\n                        return function () {\n                            var args = [ storeName ].concat( [].slice.call( arguments , 0 ) );\n                            return that[ i ].apply( that , args );\n                        };\n                    })( i );\n                }\n            })( db.objectStoreNames[ i ] );\n        }\n    };\n\n    var IndexQuery = function ( table , db , indexName ) {\n        var that = this;\n        var modifyObj = false;\n        var removeObj = false;\n\n        var runQuery = function ( type, args , cursorType , direction, limitRange, filters , mapper ) {\n            var transaction = db.transaction( table, modifyObj || removeObj ? transactionModes.readwrite : transactionModes.readonly ),\n                store = transaction.objectStore( table ),\n                index = indexName ? store.index( indexName ) : store,\n                keyRange = type ? IDBKeyRange[ type ].apply( null, args ) : null,\n                results = [],\n                deferred = Deferred(),\n                indexArgs = [ keyRange ],\n                limitRange = limitRange ? limitRange : null,\n                filters = filters ? filters : [],\n                counter = 0;\n\n            if ( cursorType !== 'count' ) {\n                indexArgs.push( direction || 'next' );\n            };\n\n            // create a function that will set in the modifyObj properties into\n            // the passed record.\n            var modifyKeys = modifyObj ? Object.keys(modifyObj) : false;\n            var modifyRecord = function(record) {\n                for(var i = 0; i < modifyKeys.length; i++) {\n                    var key = modifyKeys[i];\n                    var val = modifyObj[key];\n                    if(val instanceof Function) val = val(record);\n                    record[key] = val;\n                }\n                return record;\n            };\n\n            var removeFn = (removeObj instanceof Function) ? removeObj : false;\n            var removeRecord = function(record) {\n                return removeFn ? removeFn(record) : false;\n            };\n\n            index[cursorType].apply( index , indexArgs ).onsuccess = function ( e ) {\n                var cursor = e.target.result;\n                if ( typeof cursor === typeof 0 ) {\n                    results = cursor;\n                } else if ( cursor ) {\n                  if ( limitRange !== null && limitRange[0] > counter) {\n                      counter = limitRange[0];\n                      cursor.advance(limitRange[0]);\n                    } else if ( limitRange !== null && counter >= (limitRange[0] + limitRange[1]) ) {\n                        //out of limit range... skip\n                    } else {\n                        var matchFilter = true;\n                        var result = 'value' in cursor ? cursor.value : cursor.key;\n\n                        filters.forEach( function ( filter ) {\n                            if ( !filter || !filter.length ) {\n                                //Invalid filter do nothing\n                            } else if ( filter.length === 2 ) {\n                                matchFilter = (result[filter[0]] === filter[1])\n                            } else {\n                                matchFilter = filter[0].apply(undefined,[result]);\n                            }\n                        });\n\n                        if (matchFilter) {\n                            counter++;\n                            results.push( mapper(result) );\n                            // if we're doing a modify, run it now\n                            if(modifyObj) {\n                                result = modifyRecord(result);\n                                cursor.update(result);\n                            }\n\n                            if (removeObj) {\n                                if (removeFn(result)) {\n                                    cursor.delete(result);\n                                }\n                            }\n                        }\n                        cursor.continue();\n                    }\n                }\n            };\n\n            transaction.oncomplete = function () {\n                deferred.resolve( results );\n            };\n            transaction.onerror = function ( e ) {\n                deferred.reject( e );\n            };\n            transaction.onabort = function ( e ) {\n                deferred.reject( e );\n            };\n            return deferred.promise();\n        };\n\n        var Query = function ( type , args ) {\n            var direction = 'next',\n                cursorType = 'openCursor',\n                filters = [],\n                limitRange = null,\n                mapper = defaultMapper,\n                unique = false;\n\n            var execute = function () {\n                return runQuery( type , args , cursorType , unique ? direction + 'unique' : direction, limitRange, filters , mapper );\n            };\n\n            var limit = function () {\n                limitRange = Array.prototype.slice.call( arguments , 0 , 2 )\n                if (limitRange.length == 1) {\n                    limitRange.unshift(0)\n                }\n\n                return {\n                    execute: execute,\n                    modify: modify,\n                    remove: remove\n                };\n            };\n            var count = function () {\n                direction = null;\n                cursorType = 'count';\n\n                return {\n                    execute: execute\n                };\n            };\n            var keys = function () {\n                cursorType = 'openKeyCursor';\n\n                return {\n                    desc: desc,\n                    execute: execute,\n                    filter: filter,\n                    distinct: distinct,\n                    map: map\n                };\n            };\n            var filter = function ( ) {\n                filters.push( Array.prototype.slice.call( arguments , 0 , 2 ) );\n\n                return {\n                    keys: keys,\n                    execute: execute,\n                    filter: filter,\n                    desc: desc,\n                    distinct: distinct,\n                    modify: modify,\n                    remove: remove,\n                    limit: limit,\n                    map: map\n                };\n            };\n            var desc = function () {\n                direction = 'prev';\n\n                return {\n                    keys: keys,\n                    execute: execute,\n                    filter: filter,\n                    distinct: distinct,\n                    modify: modify,\n                    remove: remove,\n                    map: map\n                };\n            };\n            var distinct = function () {\n                unique = true;\n                return {\n                    keys: keys,\n                    count: count,\n                    execute: execute,\n                    filter: filter,\n                    desc: desc,\n                    modify: modify,\n                    remove: remove,\n                    map: map\n                };\n            };\n            var modify = function(update) {\n                modifyObj = update;\n                return {\n                    execute: execute\n                };\n            };\n            var remove = function(update) {\n                if (typeof(update) == \"undefined\") {\n                    removeObj = function(item) { return true; }\n                } else {\n                    removeObj = update;\n                }\n\n                return {\n                    execute: execute\n                };\n            };\n            var map = function (fn) {\n                mapper = fn;\n\n                return {\n                    execute: execute,\n                    count: count,\n                    keys: keys,\n                    filter: filter,\n                    desc: desc,\n                    distinct: distinct,\n                    modify: modify,\n                    remove: remove,\n                    limit: limit,\n                    map: map\n                };\n            };\n\n            return {\n                execute: execute,\n                count: count,\n                keys: keys,\n                filter: filter,\n                desc: desc,\n                distinct: distinct,\n                modify: modify,\n                remove: remove,\n                limit: limit,\n                map: map\n            };\n        };\n        \n        'only bound upperBound lowerBound'.split(' ').forEach(function (name) {\n            that[name] = function () {\n                return new Query( name , arguments );\n            };\n        });\n\n        this.filter = function () {\n            var query = new Query( null , null );\n            return query.filter.apply( query , arguments );\n        };\n\n        this.all = function () {\n            return this.filter();\n        };\n    };\n    \n    var createSchema = function ( e , schema , db ) {\n        if ( typeof schema === 'function' ) {\n            schema = schema();\n        }\n        \n        for ( var tableName in schema ) {\n            var table = schema[ tableName ];\n            var store;\n            if (!hasOwn.call(schema, tableName) || db.objectStoreNames.contains(tableName)) {\n                store = e.currentTarget.transaction.objectStore(tableName);\n            } else {\n                store = db.createObjectStore(tableName, table.key);\n            }\n\n            for ( var indexKey in table.indexes ) {\n                var index = table.indexes[ indexKey ];\n                store.createIndex( indexKey , index.key || indexKey , Object.keys(index).length ? index : { unique: false } );\n            }\n        }\n    };\n    \n    var open = function ( e , server , version , schema ) {\n        var db = e.target.result;\n        var s = new Server( db , server );\n        var upgrade;\n\n        var deferred = Deferred();\n        deferred.resolve( s );\n        dbCache[ server ] = db;\n\n        return deferred.promise();\n    };\n\n    var dbCache = {};\n\n    var db = {\n        version: '0.9.0',\n        open: function ( options ) {\n            var request;\n\n            var deferred = Deferred();\n\n            // Check if we already have it in cache\n            var serverCache = dbCache[options.server];\n\n            if (serverCache) {\n                // If it is already in cache, make sure that we also \n                // have all of the tables we are opening already\n\n                for (var table in options.schema) {\n                    if (!serverCache.objectStoreNames.contains(table)) {\n                        serverCache.close();\n                        delete dbCache[options.server];\n                    }\n                }\n            }\n             \n\n            if ( dbCache[ options.server ]) {\n                open( {\n                    target: {\n                        result: dbCache[ options.server ]\n                    }\n                } , options.server , options.version , options.schema )\n                .done(deferred.resolve)\n                .fail(deferred.reject)\n                .progress(deferred.notify);\n            } else {\n                request = indexedDB.open( options.server , options.version );\n                            \n                request.onsuccess = function ( e ) {\n                    open( e , options.server , options.version , options.schema )\n                        .done(deferred.resolve)\n                        .fail(deferred.reject)\n                        .progress(deferred.notify);\n                };\n            \n                request.onupgradeneeded = function ( e ) {\n                    createSchema( e , options.schema , e.target.result );\n                };\n                request.onerror = function ( e ) {\n                    deferred.reject( e );\n                };\n            }\n\n            return deferred.promise();\n        }\n    };\n\n    return db;\n});",
    "\ndefine('dataLayer/IndexedDBBacking',[\"class\", \"helpers\", \"db\", \"event\"], function(Class, Helpers, db, Event) {\n  var instance = Class.extend({\n    _parent: null,\n\n    _fileInfo: null,\n\n    _fileServer: null,\n\n    init: function(parent) {\n      this._parent = parent;\n    },\n\n    load: function(fileId, callback) {\n      if (!fileId) {\n        debugger;\n      }\n\n      db.open({\n        server: fileId,\n        version: 1,\n        schema: {\n          localActions: {\n            key: {\n              keyPath: 'id'\n            }\n          },\n          remoteActions: {\n            key: {\n              keyPath: 'id'\n            },\n            indexes: {\n              id: {\n                unique: true\n              },\n              index: {\n                unique: true\n              }\n            }\n          }\n        }\n      }).done((function(s) {\n\n        this._fileServer = s;\n\n        this._parent._getFileInfo(fileId, (function(fileInfo) {\n          if (typeof(fileInfo) == \"undefined\") {\n            debugger;\n          }\n          \n          this._fileInfo = fileInfo;\n          callback(fileInfo);\n        }).bind(this));\n      }).bind(this))\n        .fail(function(e) {\n          console.error(\"Failed to create file database\", e);\n        });\n    },\n\n    create: function(file, callback) {\n      this._parent._addFile(file, (function() {\n        this.load(file.id, function(fileInfo) {\n          callback(fileInfo);\n        });\n      }).bind(this));\n    },\n\n    getActions: function(callback) {\n      var actionsObj = {\n        local: null,\n        remote: null,\n      };\n\n      this._fileServer.localActions.query()\n        .all()\n        .execute()\n        .done((function(actions) {\n          actionsObj.local = actions;\n          if (actionsObj.local && actionsObj.remote) {\n            callback(actionsObj);\n          }\n        }).bind(this));\n\n      this._fileServer.remoteActions.query('index')\n        .all()\n        .execute()\n        .done((function(actions) {\n          actionsObj.remote = actions;\n          if (actionsObj.local && actionsObj.remote) {\n            callback(actionsObj);\n          }\n        }).bind(this));\n    },\n\n    rename: function(newName) {\n      this._parent._renameFile(this._fileInfo.id, newName);\n    },\n\n    addLocalAction: function(action) {\n      this._fileServer.localActions\n        .add(action)\n        .done((function(item) {\n          // item stored\n          this._parent._updateFileModified(this._fileInfo.id);\n        }).bind(this))\n        .done(function(item) {\n        });\n    },\n\n    removeLocalAction: function(actionId) {\n      this._fileServer.localActions\n        .remove(actionId)\n        .done((function(key) {\n          // item removed\n          this._parent._updateFileModified(this._fileInfo.id);\n        }).bind(this));\n    },\n\n    addRemoteActions: function(index, actions) {\n      // Shift all the actions up\n      this._fileServer.remoteActions\n        .query('index')\n        .lowerBound(index)\n        .modify({\n          index: function(action) {\n            return action.index + actions.length;\n          }\n        })\n        .execute()\n        .done((function(item) {\n          // item stored\n          this._fileServer.remoteActions\n            .add.apply(this._fileServer, actions)\n            .done(\n              (function(items) {\n                this._parent._updateFileModified(this._fileInfo.id);\n              }).bind(this))\n            .fail((function(e) {\n              console.error(\"Failed to add remote actions\", this._fileInfo.id, e);\n            }).bind(this));\n        }).bind(this))\n        .fail(function(e) {\n          console.error(\"fail to write\", e);\n        });\n    },\n\n    removeRemoteActions: function(index, length) {\n      this._fileServer.remoteActions.query('index')\n        .lowerBound(index)\n        .limit(length)\n        .remove()\n        .execute()\n        .done((function(key) {\n          // item removed\n\n          this._fileServer.remoteActions\n            .query('index')\n            .lowerBound(index)\n            .modify({\n              index: function(action) {\n                return action.index - length;\n              }\n            })\n            .execute()\n            .done((function(item) {\n              this._parent._updateFileModified(this._fileInfo.id);\n            }).bind(this));\n        }).bind(this));\n    },\n\n    replaceFileId: function(newId, callback) {\n      this.getActions((function(oldActions) {\n\n        var oldId = this._fileInfo.id;\n        this._fileInfo.id = newId;\n        var newFile = this._fileInfo;\n\n        this._parent._addFile(newFile, (function() {\n          this.load(newId, (function() {\n            this._copyAllActions(oldActions, (function() {\n              // Done copying\n              console.log(\"ID Changed\");\n              this._parent.deleteFile(oldId);\n              callback();\n            }).bind(this));\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    close: function() {\n      // What happens if this is called before load callbacks happen\n      this._fileServer.close();\n    },\n\n    _copyAllActions: function(oldActions, callback) {\n      var copied = 0;\n\n      this._copyActions(oldActions.local, this._fileServer.localActions, copyDone);\n      this._copyActions(oldActions.remote, this._fileServer.remoteActions, copyDone);\n\n      function copyDone() {\n        copied++;\n\n        // If we have copied everything\n        if (copied == 2) {\n          callback();\n          return;\n        }\n      }\n    },\n\n    _copyActions: function(actions, toServer, callback) {\n      var actionsCopied = 0;\n\n      if (actions.length == 0) {\n        callback();\n      } else {\n        for (var i = 0; i < actions.length; i++) {\n          toServer\n            .add(actions[i])\n            .done(function(newItem) {\n              if (actionsCopied == actions.length - 1) {\n                callback();\n                return;\n              }\n\n              actionsCopied++;\n            });\n        }\n      }\n    },\n  });\n\n  var IndexedDBBacking = Class.extend({\n    _server: null,\n    _initCallbacks: null,\n\n    init: function() {\n      this._initCallbacks = [];\n\n      db.open({\n        server: 'draw',\n        version: 1,\n        schema: {\n          files: {\n            key: {\n              keyPath: 'id',\n            },\n            indexes: {\n              id: {\n                unique: true\n              },\n              modifiedTime: {\n                //keyPath: 'modifiedTime'\n              },\n            }\n          }\n        }\n      })\n        .done((function(server) {\n          this._server = server;\n\n          // Go through all our delayed callbacks\n          for (var i = 0; i < this._initCallbacks.length; i++) {\n            var callback = this._initCallbacks[i];\n            callback.func.apply(this, callback.args);\n          }\n\n        }).bind(this))\n        .fail(function(e) {\n          console.error(\"Failed setting up database\", e);\n        });\n    },\n\n    getFiles: function(callback) {\n      if (!this._server) {\n        this._doLater(this.getFiles, [callback]);\n        return;\n      }\n\n      this._server.files.query('modifiedTime')\n        .all()\n        .filter(function(file) {\n          return !file.deleted;\n        })\n        .desc()\n        .execute()\n        .done((function(results) {\n          callback(results);\n        }).bind(this));\n    },\n\n    _addFile: function(file, callback) {\n      if (!this._server) {\n        this._doLater(this._addFile, [file, callback]);\n        return;\n      }\n\n      this._server.files.add(file)\n        .done((function(items) {\n\n          callback();\n\n        }).bind(this))\n        .fail(function(e) {\n          console.error(\"fail to add file to file list\", e);\n        });\n    },\n\n    _renameFile: function(fileId, newName) {\n      this._server.files.query('id')\n        .only(fileId)\n        .modify({\n          name: newName\n        })\n        .execute()\n        .done((function(results) {\n          this._updateFileModified(fileId);\n        }).bind(this))\n        .fail(function(e) {\n          console.error(\"Couldn't find file\", e);\n        });\n    },\n\n    getDeletedFiles: function(callback) {\n      this._server.files.query()\n        .filter(function(file) {\n          return file.deleted;\n        })\n        .execute()\n        .done(function(results) {\n          callback(results);\n        })\n        .fail(function(e) {\n        });\n    },\n\n    markFileAsDeleted: function(fileId) {\n      this._server.files.query('id')\n        .only(fileId)\n        .modify({\n          deleted: true\n        })\n        .execute()\n        .done((function(results) {\n          // Delete settings from local storage\n          \n        }).bind(this))\n        .fail(function(e) {\n          console.error(\"Couldn't find file\", e);\n        })\n    },\n\n    unmarkFileAsDeleted: function(fileId) {\n      this._server.files.query('id')\n        .only(fileId)\n        .modify({\n          deleted: false\n        })\n        .execute()\n        .done((function(results) {\n\n          Event.trigger(\"fileAdded\", results[0]);\n          \n        }).bind(this))\n        .fail(function(e) {\n          console.error(\"Couldn't find file\", e);\n        })\n    },\n\n    deleteFile: function(fileId) {\n      this._server.files.query('id')\n        .only(fileId)\n        .remove()\n        .execute()\n        .done(function(key) {\n          console.log(\"Deleted marked file\");\n          var f = indexedDB.deleteDatabase(fileId);\n          delete localStorage[fileId];\n        })\n        .fail(function(e) {\n          console.error(\"Failed to delete file from file table\", fileId);\n        });\n    },\n\n    _getFileInfo: function(fileId, callback) {\n      this._server.files.query('id')\n        .only(fileId)\n        .execute()\n        .done(function(results) {\n          callback(results[0]);\n        });\n    },\n\n    _updateFileModified: function(fileId) {\n      this._server.files.query('id')\n        .only(fileId)\n        .modify({\n          modifiedTime: Date.now()\n        })\n        .execute()\n        .done(function(results) {})\n        .fail(function(e) {\n          console.error(\"Couldn't find file\", e);\n        });\n    },\n\n    _doLater: function(func, args) {\n      this._initCallbacks.push({\n        func: func,\n        args: args\n      })\n    },\n\n    instance: instance,\n  });\n\n  return IndexedDBBacking;\n});",
    "\ndefine('dataLayer/DriveBacking',[\"class\", \"helpers\"], function(Class, Helpers) {\n  var instance = Class.extend({\n    _parent: null,\n\n    _doc: null,\n\n    _addedCallback: null,\n    _removedCallback: null,\n\n    _loadCallbacks: null,\n\n    init: function(parent) {\n      this._parent = parent;\n\n      this._loadCallbacks = [];\n\n      this._actionsAdded = this._actionsAdded.bind(this);\n      this._actionsRemoved = this._actionsRemoved.bind(this);\n    },\n\n    listen: function(addedCallback, removedCallback) {\n      this._addedCallback = addedCallback;\n      this._removedCallback = removedCallback;\n    },\n\n    load: function(fileId, callback) {\n      this._parent._open(fileId, (function(fileInfo) {\n        this._openForRealtime(fileId, function() {\n          callback(fileInfo);\n        });\n      }).bind(this));\n    },\n\n    create: function(file, callback) {\n      this._parent._add(file, (function(fileInfo) {\n        this._openForRealtime(fileInfo.id, function() {\n          callback(fileInfo);\n        });\n      }).bind(this));\n    },\n\n    _openForRealtime: function(fileId, callback) {\n      gapi.drive.realtime.load(fileId, (function(doc) {\n          // file was loaded\n          this._doc = doc;\n\n          var actions = doc.getModel().getRoot().get('actions');\n          actions.addEventListener(gapi.drive.realtime.EventType.VALUES_ADDED, this._actionsAdded);\n          actions.addEventListener(gapi.drive.realtime.EventType.VALUES_REMOVED, this._actionsRemoved);\n\n          callback();\n\n          for (var i = 0; i < this._loadCallbacks.length; i++) {\n            var loadCallback = this._loadCallbacks[i];\n            loadCallback.func.apply(this, loadCallback.args);\n          }\n        }).bind(this),\n        function(model) {\n          // file was created\n          var actions = model.createList();\n          var root = model.getRoot();\n          root.set('title', 'Untitled File');\n          root.set('actions', actions);\n          root.set('id', fileId);\n        }\n      );\n    },\n\n    _actionsAdded: function(e) {\n      this._addedCallback(e);\n    },\n\n    _actionsRemoved: function(e) {\n      this._removedCallback(e);\n    },\n\n    getActions: function(callback) {\n      callback(this._doc.getModel().getRoot().get('actions').asArray());\n    },\n\n    rename: function(newName) {\n      if (!this._doc) {\n        this._doAfterLoad(this.rename, [newName]);\n        return;\n      }\n\n      this._parent._renameFile(this._doc.getModel().getRoot().get('id'), newName)\n      this._doc.getModel().getRoot().set(\"title\", newName);\n    },\n\n    addAction: function(action) {\n      var actions = this._doc.getModel().getRoot().get('actions');\n      actions.insert(actions.length, action);\n    },\n\n    removeAction: function(actionIndex) {\n      var actions = this._doc.getModel().getRoot().get('actions');\n      actions.remove(actionIndex);\n    },\n\n    undo: function() {\n      this._doc.getModel().undo();\n    },\n\n    redo: function() {\n      this._doc.getModel().redo();\n    },\n\n    close: function() {\n      this._doc.close();\n    },\n\n    _doAfterLoad: function(func, args) {\n      this._loadCallbacks.push({\n        func: func,\n        args: args\n      })\n    },\n  });\n\n  var DriveBacking = Class.extend({\n    _driveFileName: \"Untitled File\",\n    _appId: 450627732299,\n    REALTIME_MIMETYPE: 'application/vnd.google-apps.drive-sdk',\n\n    init: function() {\n\n    },\n\n    getFiles: function(callback) {\n      gapi.client.load('drive', 'v2', (function() {\n        gapi.client.drive.files.list({\n          'q': \"trashed=false and mimeType='\" + this.REALTIME_MIMETYPE + '.' + this._appId + \"'\"\n        }).execute((function(results) {\n          var items = [];\n\n          if (results.items) {\n            items = results.items;\n          }\n\n          callback(items);\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _open: function(fileId, callback) {\n      gapi.client.load('drive', 'v2', (function() {\n        var request = gapi.client.drive.files.get({\n          'fileId': fileId\n        }).execute(function(result) {\n          callback({\n            id: result.id,\n            name: result.title,\n            modifiedTime: new Date(result.modifiedDate).getTime(),\n          });\n        });\n\n      }).bind(this));\n    },\n\n    _add: function(file, callback) {\n      gapi.client.load('drive', 'v2', (function() {\n        gapi.client.drive.files.insert({\n          'resource': {\n            mimeType: this.REALTIME_MIMETYPE,\n            title: file.name\n          }\n        }).execute((function(result) {\n          callback({\n            id: result.id,\n            name: result.title,\n            modifiedTime: new Date(result.modifiedDate).getTime(),\n          });\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _renameFile: function(fileId, newName) {\n      var body = {\n        'title': newName\n      };\n\n      gapi.client.load('drive', 'v2', (function() {\n        var request = gapi.client.drive.files.patch({\n          'fileId': fileId,\n          'resource': body\n        });\n        request.execute(function(resp) {});\n      }).bind(this));\n    },\n\n    deleteFile: function(fileId, callback) {\n      gapi.client.load('drive', 'v2', (function() {\n        var request = gapi.client.drive.files.delete({\n          'fileId': fileId\n        }).execute(function(result) {\n          callback();\n        });\n\n      }).bind(this));\n    },\n\n    instance: instance,\n  });\n\n  return DriveBacking;\n});",
    "\ndefine('dataLayer/data',[\"class\", \"helpers\", \"event\", \"dataLayer/file\", \"dataLayer/IndexedDBBacking\", \"dataLayer/DriveBacking\"], function(Class, Helpers, Event, File, IndexedDBBacking, DriveBacking) {\n  var Data = Class.extend({\n    _backing: null,\n    _cachedFiles: null,\n\n    _driveBacking: null,\n\n    init: function() {\n      this._cachedFiles = {};\n\n      console.log(\"Using IndexedDB as data store\");\n      this._backing = new IndexedDBBacking();\n\n      Event.addListener(\"fileIdChanged\", this._fileIdChanged.bind(this));\n    },\n\n    // FILE METHODS\n    getFiles: function(callback) {\n      this._backing.getFiles((function(files) {\n        callback(files);\n      }).bind(this));\n    },\n\n    createFile: function() {\n\n      var newFile = {\n        id: Helpers.getGuid(),\n        name: \"Untitled File\",\n        modifiedTime: Date.now(),\n      };\n\n      this._createFile(newFile);\n    },\n\n    _createFile: function(fileInfo) {\n      var file = new File(new this._backing.instance(this._backing));\n\n      // Create a new file for this\n      file.create(fileInfo, (function() {\n        this._cachedFiles[file.fileInfo.id] = file;\n        Event.trigger(\"fileAdded\", file.fileInfo);\n\n        if (this._driveBacking) {\n          file.startDrive(this._newDriveInstance());\n        }\n      }).bind(this));\n    },\n\n    loadFile: function(fileId, callback) {\n      if (this._cachedFiles[fileId]) {\n        var file = this._cachedFiles[fileId];\n        file.afterLoad((function() {\n\n          //if (file._driveBacking) {\n          //  file.sync();\n          //}\n\n          callback(file);\n        }).bind(this));\n        return;\n      }\n\n      // file was not found\n      var file = new File(new this._backing.instance(this._backing));\n      this._cachedFiles[fileId] = file;\n\n      file.load(fileId, (function() {\n        if (this._driveBacking) {\n          file.startDrive(this._newDriveInstance());\n        }\n\n        callback(file);\n      }).bind(this));\n    },\n\n    deleteFile: function(fileId, updateDrive) {\n      // If it is in the cached files, close the file and remove it\n      if (this._cachedFiles[fileId]) {\n        var file = this._cachedFiles[fileId];\n        file.afterLoad((function() {\n          file.close();\n          delete this._cachedFiles[fileId];\n        }).bind(this));\n      }\n\n      this._backing.markFileAsDeleted(fileId);\n\n      if (updateDrive !== false) { // could be true or undefined9\n        if (this._driveBacking) {\n          this._driveBacking.deleteFile(fileId, (function() {\n            this._backing.deleteFile(fileId);\n          }).bind(this));\n        }\n      }\n\n      Event.trigger(\"fileRemoved\", fileId);\n    },\n\n    close: function(file) {\n      file.close();\n      delete this._cachedFiles[file.fileInfo.id];\n    },\n\n    startDrive: function() {\n      console.log(\"Drive connected\");\n      this._driveBacking = new DriveBacking();\n\n      // add drive to our open files\n      for (var i in this._cachedFiles) {\n        this._cachedFiles[i].startDrive(this._newDriveInstance());\n      }\n\n      // Check for updates from drive every 30 seconds\n\n      this._checkForUpdates(false);\n    },\n\n    _fileIdChanged: function(e) {\n      if (this._cachedFiles[e.oldId]) {\n        this._cachedFiles[e.newId] = this._cachedFiles[e.oldId];\n        delete this._cachedFiles[e.oldId];\n      }\n    },\n\n    _newDriveInstance: function() {\n      return new this._driveBacking.instance(this._driveBacking);\n    },\n\n    _checkForUpdates: function(updateOnlyFileChanges) {\n      console.log(\"Checking for file updates on drive\");\n      this._driveBacking.getFiles((function(remoteFiles) {\n        this._backing.getFiles((function(localFiles) {\n          this._backing.getDeletedFiles((function(filesDeletedLocally) {\n            var fileIdsDeletedLocally = filesDeletedLocally.map(function(item) {\n              return item.id\n            });\n\n            // Check for files that are on drive and not saved locally\n            for (var i = 0; i < remoteFiles.length; i++) {\n              var found = false;\n\n              for (var j = 0; j < localFiles.length; j++) {\n                if (remoteFiles[i].id == localFiles[j].id) {\n                  found = true;\n                  break;\n                }\n              }\n\n              var file = remoteFiles[i];\n\n              if (!found) {\n                this._fileNotFoundOnDrive(fileIdsDeletedLocally, file);\n              } else {\n                // we have this file on both local and server\n\n                if (updateOnlyFileChanges) {\n                  // File names don't match\n                  if (file.title != localFiles[j].name) {\n\n                    // Wrap this so we keep the context of file\n                    this.loadFile(file.id, (function(remoteFile, fileObj) {\n                      fileObj.rename(remoteFile.title);\n                    }).bind(this, file));\n\n                  }\n                  // We only want to update file name changes\n                } else {\n\n                  // make sure we have all the remote actions\n                  this.loadFile(file.id, (function(fileObj) {\n                  }).bind(this));\n                }\n              }\n            }\n\n\n            // look for local files that are not on remote\n            for (var i = 0; i < localFiles.length; i++) {\n              var found = false;\n\n              for (var j = 0; j < remoteFiles.length; j++) {\n                if (localFiles[i].id == remoteFiles[j].id) {\n                  found = true;\n                  break;\n                }\n              }\n\n              if (!found) {\n\n                // we don't have it on remote, and we also marked it as deleted locally\n                var deletedLocally = fileIdsDeletedLocally.indexOf(localFiles[i].id) !== -1;\n                if (deletedLocally) {\n                  this.deleteFile(localFiles[i].id, false);\n                  continue;\n                }\n\n                // TODO: check if we deleted it remotely\n                var deletedRemotely = !Helpers.isLocalGuid(localFiles[i].id);\n\n                if (deletedRemotely) {\n                  this.deleteFile(localFiles[i].id, false);\n                  continue;\n                }\n\n                // load it and let it sync\n                this.loadFile(localFiles[i].id, (function() {}).bind(this));\n                continue;\n              }\n            }\n\n            // This is going to run potentially before everything else finishes, where else could it go?\n            this._scheduleUpdate();\n          }).bind(this));\n        }).bind(this));\n      }).bind(this));\n    },\n\n    _fileNotFoundOnDrive: function(fileIdsDeletedLocally, file) {\n      var deletedLocally = fileIdsDeletedLocally.indexOf(file.id) !== -1;\n\n      if (deletedLocally) {\n        console.log(file.id, \"was deleted\");\n        // we need to see if the file remote actions match to \n        // know whether we should actually delete it remotely.\n        var tempFile = new File(new this._backing.instance(this._backing));\n        tempFile.remoteActionsMatch(file.id, this._newDriveInstance(), (function(actionsMatch) {\n          console.log(\"inside for\", tempFile.fileInfo.id);\n          if (actionsMatch) {\n            // delete it on the remote\n            this.deleteFile(file.id);\n          } else {\n            // unmark as deleted and load it so it will sync\n            this._backing.unmarkFileAsDeleted(file.id);\n\n            this.loadFile(file.id, (function() {\n\n            }).bind(this));\n          }\n        }).bind(this));\n      } else {\n        // File wasn't found locally, make a file with the same\n        // id and then it will sync\n        var newFile = {\n          id: file.id,\n          name: file.title,\n          modifiedTime: new Date(file.modifiedDate).getTime(),\n        };\n\n        this._createFile(newFile);\n      }\n    },\n\n\n\n    _checkForFileChanges: function() {\n\n    },\n\n    _scheduleUpdate: function() {\n      setTimeout((function() {\n        this._checkForUpdates(true);\n      }).bind(this), 30 * 1000);\n    }\n  });\n\n  var data = new Data();\n  window.dataLayer = data\n\n  return data;\n});",
    "\ndefine('templates/fileList',[], function() {\n\n  function FileList() {\n    var template = '<li class=\"file-info\">'+\n                      '<div class=\"thumbnail-wrapper\">'+\n                        '<canvas class=\"thumbnail\"></canvas>'+\n                        '<div class=\"overlay\">'+\n                          '<span class=\"file-name\"></span>'+\n                          '<span class=\"delete icon-close\" data-action=\"delete\"></span>'+\n                        '</div>'+\n                      '</div>'+\n                    '</li';\n    var element = document.createElement(\"div\");\n    element.innerHTML = template;\n    return element.firstChild;\n  }\n\n  return FileList;\n});",
    "\ndefine('components/drawCanvas',[\"class\", \"helpers\"], function(Class, Helpers) {\n  var DrawCanvas = Class.extend({\n    _canvas: null,\n    _ctx: null,\n    _settings: null,\n\n    // Holds at most one action\n    _tempCanvas: null,\n    _tempCtx: null,\n\n    init: function(canvas, settings) {\n      this._canvas = canvas;\n      this._ctx = canvas.getContext(\"2d\");\n      this._settings = settings;\n\n      this._backCanvas = document.createElement(\"canvas\");\n      this._backCtx = this._backCanvas.getContext(\"2d\");\n      //this._backCtx.lineJoin = \"round\";\n      //this._backCtx.lineCap = \"round\";\n\n      this._tempCanvas = document.createElement(\"canvas\");\n      this._tempCtx = this._tempCanvas.getContext(\"2d\");\n      //this._tempCtx.lineJoin = \"round\";\n      //this._tempCtx.lineCap = \"round\";\n    },\n\n    // Creates a back canvas and draws all the actions to it and renders it on the main canvas\n    doAll: function(actions) {\n      this._backCanvas.width = this._canvas.width;\n      this._backCanvas.height = this._canvas.height;\n\n      this._clearCanvas(this._backCanvas, this._backCtx);\n\n      // Also clear the temp canvas\n      this._clearCanvas(this._tempCanvas, this._tempCtx);\n\n      for (var i = 0; i < actions.length; i++) {\n        var action = actions[i];\n\n        this._doAction(this._backCtx, action);\n      }\n    },\n\n    // The action is done to a temporary canvas\n    doTemporaryAction: function(action) {\n      this._tempCanvas.width = this._canvas.width;\n      this._tempCanvas.height = this._canvas.height;\n\n      this._clearCanvas(this._tempCanvas, this._tempCtx);\n\n      this._doAction(this._tempCtx, action);\n    },\n\n    addAction: function(action) {\n      this._doAction(this._backCtx, action);\n\n      // Clears the temp canvas when you add something to the back\n      this._clearCanvas(this._tempCanvas, this._tempCtx);\n    },\n\n    // Clears the main screen\n    clear: function() {\n      this._clearCanvas(this._canvas, this._ctx);\n    },\n\n    _clearCanvas: function(canvas, ctx) {\n      ctx.setTransform(this._settings.scale, 0, 0, this._settings.scale, this._settings.offsetX, this._settings.offsetY);\n\n      var topLeft = Helpers.screenToWorld(this._settings, 0, 0);\n      var bottomRight = Helpers.screenToWorld(this._settings, canvas.width, canvas.height);\n\n      ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n    },\n\n    render: function() {\n      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n      this._ctx.drawImage(this._backCanvas, 0, 0, this._backCanvas.width, this._backCanvas.height);\n      this._ctx.drawImage(this._tempCanvas, 0, 0, this._tempCanvas.width, this._tempCanvas.height);\n    },\n\n\n    _doAction: function(ctx, action) {\n      if (action.type == \"stroke\") {\n        this._drawStroke(ctx, action.value);\n      }\n    },\n\n    updateSettings: function(settings) {\n      this._settings = settings;\n    },\n\n    _drawStroke: function(ctx, stroke) {\n      if (stroke.points.length < 2) {\n        return;\n      }\n\n      var controlPoints = [];\n      var points = stroke.points;\n\n      if (!stroke.controlPoints) {\n        controlPoints = Helpers.getCurveControlPoints(points);\n      } else {\n        controlPoints = stroke.controlPoints;\n      }\n\n      var point = points[0];\n\n      var lineWidth = stroke.width;\n      if (stroke.lockWidth) { // the width stays the same regardless of zoom\n        lineWidth /= this._settings.scale;\n      }\n\n      ctx.lineWidth = lineWidth;\n      ctx.setStrokeColor(stroke.color);\n\n      ctx.beginPath();\n      ctx.moveTo(point.x, point.y);\n\n      for (var i = 1; i < points.length; i++) {\n        point = points[i];\n        var cp1 = controlPoints[i - 1][0];\n        var cp2 = controlPoints[i - 1][1];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], point[0], point[1]);\n      }\n\n\n      //ctx.lineJoin = \"round\";\n      ctx.lineCap = \"round\";\n      ctx.stroke();\n    },\n  });\n\n  return DrawCanvas;\n\n  /*\n  drawAll(actions) // Draw all actions to a back canvas\n  drawTemporary(action) // draw action on front canvas\n  addAction(action) // add action to back canvas\n  */\n\n});",
    "\ndefine('components/manipulateCanvas',[\"components/drawCanvas\", \"helpers\"], function(DrawCanvas, Helpers) {\n\n  var ManipulateCanvas = DrawCanvas.extend({\n    zoom: function(x, y, dScale) {\n      // Can't zoom that far!\n      if (this._settings.scale + dScale < .001 || this._settings.scale + dScale > 20000) {\n        return false;\n      }\n\n      var world = Helpers.screenToWorld(this._settings, x, y);\n      this._settings.scale += dScale;\n      var scr = Helpers.worldToScreen(this._settings, world.x, world.y);\n\n      var diffScr = {\n        x: x - scr.x,\n        y: y - scr.y\n      };\n\n      this._settings.offsetX += diffScr.x; // * this._settings.scale;\n      this._settings.offsetY += diffScr.y; // * this._settings.scale;\n\n      return true;\n    },\n\n    pan: function(dx, dy) {\n      this._settings.offsetX += dx;\n      this._settings.offsetY += dy;\n\n      return true;\n    },\n\n    panTo: function(x, y) {\n      this._settings.offsetX = x;\n      this._settings.offsetY = y;\n    }\n  });\n\n  return ManipulateCanvas;\n});",
    "\ndefine('components/thumbnail',[\"class\", \"helpers\", \"dataLayer/data\", \"components/manipulateCanvas\"], function(Class, Helpers, Data, ManipulateCanvas) {\n\n  var Thumbnail = Class.extend({\n    _canvas: null,\n\n    init: function(canvas) {\n      this._canvas = canvas;\n    },\n\n    render: function(fileInfo) {\n      Data.loadFile(fileInfo.id, (function(file) {\n        var actions = file.getActions();\n        var settings = file.localSettings();\n\n        var manipulateCanvas = new ManipulateCanvas(this._canvas, settings);\n\n        // Find out what world point is in the middle\n        var centerScreen = {\n          x: window.innerWidth / 2,\n          y: window.innerHeight / 2\n        };\n        var centerWorld = Helpers.screenToWorld(settings, centerScreen.x, centerScreen.y);\n\n        var scale = Math.min(this._canvas.width / window.innerWidth, this._canvas.height / window.innerHeight);\n        var zoomDiff = (settings.scale * scale) - settings.scale;\n        manipulateCanvas.zoom(0, 0, zoomDiff);\n\n        // Now that we have zoomed, find the middle of the canvas\n        var centerScreenAfter = {\n          x: this._canvas.width / 2,\n          y: this._canvas.height / 2\n        };\n\n        // And where the middle point was from before\n        var centerScreenPointAfter = Helpers.worldToScreen(settings, centerWorld.x, centerWorld.y);\n\n        // pan the difference\n        var diffScreen = {\n          x: centerScreenAfter.x - centerScreenPointAfter.x,\n          y: centerScreenAfter.y - centerScreenPointAfter.y\n        };\n        manipulateCanvas.pan(diffScreen.x, diffScreen.y);\n\n        manipulateCanvas.doAll(actions);\n        manipulateCanvas.render();\n      }).bind(this));\n    }\n  });\n\n  return Thumbnail;\n});",
    "\ndefine('sections/fileList',[\"section\", \"tapHandler\", \"event\", \"globals\", \"helpers\", \"dataLayer/data\", \"templates/fileList\", \"components/thumbnail\"], function(Section, TapHandler, Event, g, Helpers, Data, FileListTemplate, Thumbnail) {\n\n  var FileList = Section.extend({\n    id: \"files-list-container\",\n\n    // The parent pane for this page\n    _filesPane: null,\n\n    // The element\n    _fileListElement: null,\n\n    _files: null,\n\n    _resizeTimeout: null,\n\n    init: function(filesPane) {\n      this._super();\n\n      this._filesPane = filesPane;\n\n      this._files = [];\n\n      this._fileListElement = document.getElementById(\"files-list\");\n\n      this._resizeAndRender = this._resizeAndRender.bind(this);\n      this._actuallyResizeAndRender = this._actuallyResizeAndRender.bind(this);\n\n      // Don't have the big create button on phone\n      if (g.isPhone()) {\n        this._fileListElement.innerHTML = \"\";\n      }\n\n      Data.getFiles((function(files) {\n        for (var i = 0; i < files.length; i++) {\n          var fileInfo = files[i];\n          var fileTemplate = this._newFileWrapper(fileInfo);\n          this._fileListElement.appendChild(fileTemplate);\n        }\n\n        this._actuallyResizeAndRender();\n      }).bind(this));\n\n      this.element.addEventListener(\"mousewheel\", function(e) {\n        e.stopPropagation();\n      });\n\n      new TapHandler(document.getElementById(\"file-create\"), {\n        tap: this._newDoc.bind(this)\n      });\n\n      new TapHandler(this._fileListElement, {\n        tap: this._docSelected.bind(this)\n      });\n\n      Event.addListener(\"fileAdded\", this._fileAdded.bind(this));\n      Event.addListener(\"fileRemoved\", this._fileRemoved.bind(this));\n      //Event.addListener(\"fileModified\", this._fileModified.bind(this));\n      Event.addListener(\"fileRenamed\", this._fileRenamed.bind(this));\n    },\n\n    show: function(fileInfo) {\n\n      window.addEventListener(\"resize\", this._resizeAndRender);\n      if (fileInfo) {\n        // We came from draw, it is the info of the file we were just looking at\n\n        for (var i in this._files) {\n          if (this._files[i].element.fileInfo.id == fileInfo.id) {\n            this._files[i].thumbnail.render(this._files[i].element.fileInfo);\n            return;\n          }\n        }\n\n        console.error(\"We somehow came from a file that doesn't exist\");\n      }\n    },\n\n    hide: function(fileInfo) {\n      window.removeEventListener(\"resize\", this._resizeAndRender);\n    },\n\n    _newFileWrapper: function(fileInfo) {\n      var newEle = new FileListTemplate();\n      newEle.fileInfo = fileInfo;\n\n      var canvas = newEle.getElementsByClassName(\"thumbnail\")[0];\n      var fileName = newEle.getElementsByClassName(\"file-name\")[0];\n\n      var thumbnail = new Thumbnail(canvas);\n      fileName.innerText = fileInfo.name;\n\n      this._files.push({\n        element: newEle,\n        canvas: canvas,\n        thumbnail: thumbnail\n      });\n\n      return newEle;\n    },\n\n    // Resize every thumbnail canvas and re-render them\n    _resizeAndRender: function() {\n      if (this._resizeTimeout) {\n        clearTimeout(this._resizeTimeout);\n      } else {\n        // we should clear canvases here\n      }\n\n      this._resizeTimeout = setTimeout(this._actuallyResizeAndRender.bind(this), 500);\n    },\n\n    _actuallyResizeAndRender: function() {\n      for (var i in this._files) {\n        var file = this._files[i];\n\n        this._resizeAndRenderFile(file);\n      }\n    },\n\n    _resizeAndRenderFile: function(file) {\n      var canvasParent = file.canvas.parentElement;\n      file.canvas.width = canvasParent.offsetWidth;\n      file.canvas.height = canvasParent.offsetHeight;\n      file.thumbnail.render(file.element.fileInfo);\n    },\n\n    _docSelected: function(e) {\n      var element = e.srcElement;\n      var parent = Helpers.parentEleWithClassname(e.srcElement, \"file-info\");\n\n      if (parent) {\n        if (parent.classList.contains(\"create\")) {\n          // Create was called\n          this._newDoc();\n          return;\n        } else {\n          if (element.dataset.action && element.dataset.action == \"delete\") {\n            // Delete was clicked\n            Data.deleteFile(parent.fileInfo.id);\n            return;\n          }\n\n          // Regular file was clicked\n          this._filesPane.setPane(\"draw\", parent.fileInfo);\n        }\n      }\n    },\n\n    _newDoc: function() {\n      Data.createFile();\n    },\n\n    // EVENTS\n    _fileAdded: function(file) {\n      var fileTemplate = this._newFileWrapper(file);\n\n      this._fileListElement.insertBefore(fileTemplate, this._fileListElement.children[1]);\n      this._actuallyResizeAndRender();\n    },\n\n    _fileRemoved: function(fileId) {\n      for (var i in this._files) {\n        var element = this._files[i].element;\n        if (element.fileInfo.id == fileId) {\n          this._fileListElement.removeChild(element);\n          delete this._files[i]\n          return;\n        }\n      }\n    },\n\n    _fileModified: function(file) {\n      for (var i in this._files) {\n        var element = this._files[i].element;\n\n        if (element.fileInfo.id == file.id) {\n          this._fileListElement.removeChild(element);\n          this._fileListElement.insertBefore(element, this._fileListElement.children[1]);\n          return;\n        }\n      }\n    },\n\n    _fileRenamed: function(file) {\n      for (var i in this._files) {\n        var element = this._files[i].element;\n        if (element.fileInfo.id == file.id) {\n\n          var fileNameElement = element.getElementsByClassName(\"file-name\")[0];\n          fileNameElement.innerText = file.name;\n          return;\n        }\n      }\n    },\n  });\n\n  return FileList;\n\n});",
    "\ndefine('sections/draw',[\"section\", \"globals\", \"event\", \"helpers\", \"tapHandler\", \"db\", \"dataLayer/data\", \"components/manipulateCanvas\"], function(Section, g, Event, Helpers, TapHandler, db, Data, ManipulateCanvas) {\n\n  var Draw = Section.extend({\n    id: \"draw\",\n\n    // The parent pane for this page\n    _filesPane: null,\n\n    // Instance of draw canvas that is handling all the drawing\n    _manipulateCanvas: null,\n\n    // The actual canvas element\n    _canvas: null,\n\n    // The file we are currently rendering\n    _file: null,\n\n    // Local settings such as offset and zoom\n    _settings: null,\n\n    // If we are currently doing something like drawing, it will be here\n    _currentAction: null,\n\n    // If we need to redraw but shouldn't re-render anything\n    _update: false,\n\n    // Do we need to update on this frame?\n    _updateAll: true,\n\n    // Does the current action need to be redrawn?\n    _updateCurrentAction: false,\n\n    // Set this to false to stop the render loop\n    _shouldRender: false,\n\n    // Timeout for \n    _saveSettingsTimeout: null,\n\n    // The tap handler for the draw pane. Needed to turn on and off gestures\n    _canvasTapHandler: null,\n\n    _toolTapHandler: null,\n\n    _fileNameElement: null,\n\n    // The overlay of modals\n    _overlay: null,\n\n    init: function(filesPane) {\n      this._super();\n\n      this._filesPane = filesPane;\n\n      this._canvas = document.getElementById('canvas');\n\n      this._actionsAdded = this._actionsAdded.bind(this);\n      this._actionsRemoved = this._actionsRemoved.bind(this);\n      this._resize = this._resize.bind(this);\n      this._fileRenamed = this._fileRenamed.bind(this);\n\n      // Keep the trackpad from trigger chrome's back event\n      this.element.addEventListener(\"touchmove\", function(e) {\n        e.preventDefault();\n      });\n\n      this._canvasTapHandler = new TapHandler(this.element, {\n        start: this._start.bind(this),\n        move: this._move.bind(this),\n        end: this._end.bind(this),\n        gesture: this._gesture.bind(this)\n      });\n\n\n      this._toolTapHandler = new TapHandler(document.getElementById(\"tools\"), {\n        tap: this._toolChanged.bind(this),\n        start: this._toolStart.bind(this),\n        end: this._toolEnd.bind(this)\n      });\n\n      new TapHandler(document.getElementById(\"menu\"), {\n        start: function(e) {\n          e.stopPropagation();\n        },\n        tap: this._menuTapped.bind(this),\n      });\n\n      new TapHandler(document.getElementById(\"fileName\"), {\n        start: function(e) {\n          e.stopPropagation();\n        }\n      });\n\n      new TapHandler(document.getElementById(\"options\"), {\n        start: function(e) {\n          e.stopPropagation();\n        },\n        tap: this._menuTapped.bind(this),\n      });\n\n      new TapHandler(document.getElementById(\"colorPicker\"), {\n        start: function(e) {\n          e.stopPropagation();\n        },\n        tap: this._colorPicked.bind(this)\n      });\n\n      this._overlay = document.getElementById(\"draw-overlay\");\n      this._overlay.addEventListener(\"mousedown\", this._hideModal.bind(this));\n      this._overlay.addEventListener(\"touchstart\", this._hideModal.bind(this));\n\n      this.element.addEventListener(\"mousewheel\", this._mouseWheel.bind(this));\n      this.element.addEventListener(\"keydown\", this._keyDown.bind(this));\n\n      this._fileNameElement = document.getElementById(\"fileName\");\n      this._fileNameElement.addEventListener(\"keydown\", this._fileNameKeyDown.bind(this));\n      this._fileNameElement.addEventListener(\"blur\", this._fileNameBlur.bind(this));\n\n    },\n\n    show: function(fileInfo) {\n      Data.loadFile(fileInfo.id, (function(file) {\n\n        this._file = file;\n\n        file.listen(this._actionsAdded, this._actionsRemoved);\n\n        this._fileNameElement.value = file.fileInfo.name;\n        this._settings = file.localSettings();\n\n        this._manipulateCanvas = new ManipulateCanvas(this._canvas, this._settings);\n        document.getElementById(\"chosenColorSwatch\").style.backgroundColor = this._settings.color;\n\n        this._setActiveTool();\n\n        this._updateAll = true;\n        this._shouldRender = true;\n\n        this._redraw();\n\n        Event.addListener(\"fileRenamed\", this._fileRenamed);\n      }).bind(this));\n\n      // We don't need data to resize\n      this._resize();\n\n      // Focus on the canvas after we navigate to it\n      setTimeout(function() {\n        canvas.focus();\n      }.bind(this), 400);\n\n      window.addEventListener(\"resize\", this._resize);\n    },\n\n    hide: function() {\n      this._shouldRender = false;\n\n      Event.removeListener(\"fileRenamed\", this._fileRenamed);\n      window.removeEventListener(\"resize\", this._resize);\n\n      this._file.stopListening();\n    },\n\n    _actionsAdded: function(e) {\n      if (e.isLocal) {\n        this._update = true;\n        this._manipulateCanvas.addAction(e.items[0]);\n      } else {\n        this._updateAll = true;\n      }\n    },\n\n    _actionsRemoved: function(e) {\n      this._updateAll = true;\n    },\n\n    _resize: function() {\n      this._canvas.width = window.innerWidth;\n      this._canvas.height = window.innerHeight;\n\n      this._updateAll = true;\n    },\n\n    _zoom: function(x, y, dScale) {\n      if (this._manipulateCanvas.zoom(x, y, dScale)) {\n        this._saveSettings();\n        this._updateAll = true;\n      }\n    },\n\n    _pan: function(dx, dy) {\n      if (this._manipulateCanvas.pan(dx, dy)) {\n        this._saveSettings();\n        this._updateAll = true;\n      }\n    },\n\n    _mouseWheel: function(e) {\n      // deltaX is chrome, wheelDelta is safari\n      var dx = -e.deltaX || (e.wheelDeltaX / 5);\n      var dy = -e.deltaY || (e.wheelDeltaY / 5);\n\n      if (this._settings.tools.scroll == \"pan\") {\n        this._pan(dx, dy);\n      } else if (this._settings.tools.scroll == \"zoom\") {\n        if (dy != 0) {\n          this._zoom(e.offsetX, e.offsetY, dy / 100 * this._settings.scale);\n        }\n      }\n    },\n\n    _start: function(e) {\n      var tool = this._settings.tools.gesture || this._settings.tools.point;\n      if (e.button == 1) { // middle mouse\n        tool = \"pan\";\n      }\n\n      if (tool == \"pan\") {\n        return;\n      }\n\n      var world = Helpers.screenToWorld(this._settings, e.distFromLeft, e.distFromTop);\n\n      if (this._currentAction) {\n        console.error(\"Current action isn't null!\");\n      }\n\n      this._currentAction = {\n        type: \"stroke\",\n        value: {\n          points: [\n            [world.x, world.y]\n          ],\n          width: 2,\n          lockWidth: true, // should the width stay the same regardless of zoom\n          color: this._settings.color\n        }\n      }\n\n      if (tool == \"eraser\") {\n        this._currentAction.value.width = 30 / this._settings.scale;\n        this._currentAction.value.color = \"#ffffff\";\n        this._currentAction.value.lockWidth = false;\n      } else if (this._settings.tools.point == \"pencil\") {\n\n      }\n    },\n\n    _move: function(e) {\n      var tool = this._settings.tools.gesture || this._settings.tools.point;\n\n      if (e.button == 1) { // middle mouse\n        tool = \"pan\";\n      }\n\n      if (tool == \"pan\") {\n        this._pan(e.xFromLast, e.yFromLast);\n      } else if (tool == \"pencil\" || tool == \"eraser\") {\n\n        if (!this._currentAction) {\n          // no current action. This can happen if we were dragging a tool and let up the\n          // tool button and kept dragging\n          return;\n        }\n\n        var world = Helpers.screenToWorld(this._settings, e.distFromLeft, e.distFromTop);\n\n        var currentStroke = this._currentAction.value;\n\n        var points = currentStroke.points;\n        var lastPoint = points[points.length - 1];\n\n\n        var dist = Math.sqrt(\n          ((lastPoint[0] - world[0]) * (lastPoint[0] - world[0])) +\n          ((lastPoint[1] - world[1]) * (lastPoint[1] - world[1]))\n        );\n\n        if (dist < 0.001) {\n          return;\n        }\n\n        currentStroke.points.push([world.x, world.y]);\n        this._updateCurrentAction = true;\n      }\n    },\n\n    _end: function(e) {\n      var tool = this._settings.tools.gesture || this._settings.tools.point;\n\n      if (tool == \"pencil\" || tool == \"eraser\") {\n        if (!this._currentAction) {\n          // no current action. This can happen if we were dragging a tool and let up the\n          // tool button and kept dragging\n          return;\n        }\n\n        var currentAction = this._currentAction;\n        this._currentAction = null;\n\n        var currentStroke = currentAction.value;\n\n        if (currentStroke.points.length < 2) {\n          // two options, don't count the stroke\n          return;\n\n          // or render a point\n        }\n\n        var controlPoints = Helpers.getCurveControlPoints(currentStroke.points);\n        currentStroke.controlPoints = controlPoints;\n\n        this._updateCurrentAction = true;\n\n        // the actions is done, we should redraw everything.\n        this._updateAll = true;\n\n        this._saveAction(currentAction);\n      }\n    },\n\n    _saveAction: function(action) {\n      action.id = Helpers.getGuid();\n      this._file.addAction(action);\n    },\n\n    _gesture: function(e) {\n      //if (this._settings.tools.point == \"pencil\") {\n      this._pan(e.xFromLast, e.yFromLast);\n      this._zoom(e.x, e.y, e.scaleFromLast * this._settings.scale);\n      //}\n    },\n\n    _redraw: function() {\n      // If we shouldn't render, exit the loop\n      if (!this._shouldRender) {\n        return;\n      }\n\n      if (this._updateAll) {\n        var actions = this._file.getActions();\n\n        this._manipulateCanvas.doAll(actions);\n      }\n\n      if (this._updateCurrentAction && this._currentAction) {\n        this._manipulateCanvas.doTemporaryAction(this._currentAction)\n\n      }\n\n      if (this._updateAll || this._updateCurrentAction || this._update) {\n        this._manipulateCanvas.render();\n\n        this._update = false;\n        this._updateAll = false;\n        this._updateCurrentAction = false;\n      }\n\n      requestAnimationFrame(this._redraw.bind(this));\n    },\n\n    _menuTapped: function(e) {\n      if (e.srcElement.tagName == \"LI\") {\n        var action = e.srcElement.dataset.action;\n\n        if (action == \"back\") {\n          this._filesPane.setPane(\"list\", this._file.fileInfo);\n        } else if (action == \"rename\") {\n          e.srcElement.focus();\n        } else if (action == \"export\") {\n          var dataURL = this._canvas.toDataURL();\n          window.open(dataURL);\n        }\n      }\n    },\n\n    _showModal: function(modalId) {\n      var modal = document.getElementById(modalId);\n      if (!modal) {\n        console.error(\"No modal with that id\");\n        return;\n      }\n\n      this._overlay.currentModal = modalId;\n      this._overlay.style.display = \"block\";\n\n      setTimeout(function() {\n        modal.classList.add(\"visible\");\n      }, 0);\n    },\n\n    _hideModal: function(e) {\n      if (e && e.srcElement != this._overlay) {\n        // overlay was explicitly tapped\n        return;\n      }\n\n      if (this._overlay.currentModal) {\n        // A modal is showing\n        var modal = document.getElementById(this._overlay.currentModal);\n        modal.classList.remove(\"visible\");\n        this._overlay.currentModal = \"\";\n      }\n\n      this._overlay.style.display = \"\";\n\n      if (e) {\n        //e.stopPropagation();\n      }\n    },\n\n    _colorPicked: function(e) {\n      parent = Helpers.parentEleWithClassname(e.srcElement, \"swatch\");\n      if (parent) {\n        var color = parent.style.backgroundColor;\n        this._settings.color = color;\n        this._saveSettings();\n\n        document.getElementById(\"chosenColorSwatch\").style.backgroundColor = color;\n        this._hideModal();\n      }\n\n      e.stopPropagation();\n    },\n\n    _toolStart: function(e) {\n\n      var tool = e.srcElement.dataset.tool;\n      var action = e.srcElement.dataset.action;\n\n      if (e.srcElement.tagName == \"LI\" && tool) {\n        if (tool == \"pan\" || tool == \"eraser\" || tool == \"pencil\") {\n          this._settings.tools.gesture = tool;\n\n          this._setActiveTool();\n\n          this._canvasTapHandler.ignoreGestures(true);\n          this._toolTapHandler.ignoreGestures(true);\n        }\n      }\n\n      e.stopPropagation();\n      e.preventDefault();\n    },\n\n    _toolEnd: function(e) {\n      if (e) {\n        var tool = e.srcElement.dataset.tool;\n\n        if (e.srcElement.tagName == \"LI\" && tool) {\n          if (tool == \"pan\" || tool == \"eraser\" || tool == \"pencil\") {\n            this._settings.tools.gesture = null;\n\n            this._setActiveTool();\n\n            this._canvasTapHandler.ignoreGestures(false);\n            this._toolTapHandler.ignoreGestures(false);\n          }\n        }\n      }\n    },\n\n    _toolChanged: function(e) {\n      var parent = Helpers.parentEleWithClassname(e.srcElement, \"toolitem\");\n\n      if (parent && parent.tagName == \"LI\") {\n        var action = parent.dataset.action;\n        var tool = parent.dataset.tool;\n\n        if (tool) {\n          if (tool == \"pencil\") {\n            this._settings.tools.point = \"pencil\";\n          } else if (tool == \"eraser\") {\n            this._settings.tools.point = \"eraser\";\n          } else if (tool == \"pan\") {\n            // TODO: this should probably check if the event was a touch\n            // or mouse event\n            if (g.isComputer()) {\n              this._settings.tools.scroll = \"pan\";\n            } else {\n              this._settings.tools.point = \"pan\";\n            }\n          } else if (tool == \"zoom\") {\n            this._settings.tools.scroll = \"zoom\";\n          }\n\n          this._setActiveTool();\n          this._saveSettings();\n        } else if (action) {\n          if (action == \"undo\") {\n            this._undo();\n          } else if (action == \"redo\") {\n            this._redo();\n          }\n          if (action == \"color\") {\n            this._showModal(\"colorPicker\");\n\n            e.preventDefault();\n            e.stopImmediatePropagation();\n          }\n        }\n      }\n    },\n\n    _setActiveTool: function() {\n      var toolsElement = document.getElementById(\"tools\");\n\n      function addRemove(type) {\n        var prevTool = toolsElement.dataset[\"active\" + type];\n        if (prevTool) {\n          var toolItem = document.getElementById(prevTool);\n          toolItem.classList.remove(\"active-\" + type);\n        }\n\n        var currentTool = this._settings.tools[type];\n\n        if (currentTool) {\n\n          var currentToolId = currentTool + \"-tool\";\n          var newToolItem = document.getElementById(currentToolId);\n          newToolItem.classList.add(\"active-\" + type);\n\n          toolsElement.dataset[\"active\" + type] = currentToolId;\n        } else {\n          delete toolsElement.dataset[\"active\" + type];\n        }\n\n      }\n\n      addRemove = addRemove.bind(this);\n\n      addRemove(\"point\");\n\n      if (g.isComputer()) {\n        addRemove(\"scroll\");\n      }\n    },\n\n    _keyDown: function(e) {\n      var key = String.fromCharCode(e.keyCode);\n\n      if (\n        ((g.isMac() && e.metaKey && e.shiftKey) && key == \"Z\") ||\n        ((g.isPC() && e.ctrlKey) && key == \"Y\")) {\n        // Redo\n\n        this._redo();\n      } else if ((\n          (g.isMac() && e.metaKey) ||\n          (g.isPC() && e.ctrlKey)\n        ) &&\n        key == \"Z\") {\n        // Undo\n\n        e.preventDefault();\n        this._undo();\n      } else if (key == \"Z\") {\n        this._settings.tools.scroll = \"zoom\";\n        this._setActiveTool();\n      } else if (key == \"P\") {\n        this._settings.tools.scroll = \"pan\";\n        this._setActiveTool();\n      }\n\n    },\n\n    _undo: function() {\n      this._file.undo();\n    },\n\n    _redo: function() {\n      this._file.redo();\n    },\n\n    _fileNameKeyDown: function(e) {\n      if (e.keyCode == 13) { // Enter\n        this._fileNameElement.blur();\n      }\n    },\n\n    _fileNameBlur: function(e) {\n      var name = e.srcElement.value;\n      this._file.rename(name);\n    },\n\n\n    _saveSettings: function() {\n      // If the timeout is set already\n      if (this._saveSettingsTimeout) {\n\n        // Clear it and set a new one\n        clearTimeout(this._saveSettingsTimeout);\n      }\n\n      this._saveSettingsTimeout = setTimeout((function() {\n        this._file.localSettings(this._settings);\n        this._saveSettingsTimeout = null;\n      }).bind(this), 100);\n\n    },\n\n    _fileRenamed: function(file) {\n      if (this._file.fileInfo.id == file.id) {\n        this._fileNameElement.value = file.name;\n      }\n    },\n  });\n\n  return Draw;\n\n});",
    "\ndefine('managers/files',[\"section\", \"event\", \"sections/fileList\", \"sections/draw\"], function(Section, Event, FileList, Draw) {\n\n  var Files = Section.extend({\n    id: \"files\",\n\n    _paneWrapper: null,\n\n    _screenWidth: 0,\n\n    panes: null,\n\n    currentPaneName: null,\n\n    _currentState: null,\n\n    init: function() {\n      this._super();\n\n      this._screenWidth = window.innerWidth;\n\n      this._paneWrapper = document.getElementById(\"files-pane-wrapper\");\n\n      this._windowResized = this._windowResized.bind(this);\n      this._finishedSliding = this._finishedSliding.bind(this);\n\n      this._paneWrapper.addEventListener(\"webkitTransitionEnd\", this._finishedSliding);\n\n      this.panes = {};\n\n      this.panes.list = {\n        offsetX: 0,\n        pane: new FileList(this)\n      };\n\n      this.panes.draw = {\n        offsetX: this._screenWidth,\n        pane: new Draw(this)\n      };\n\n      this.panes.draw.pane.element.style.webkitTransform = 'translate(' + this._screenWidth + \"px, 0px)\";\n\n      this._currentState = {\n        pane: \"list\",\n        details: null\n      };\n\n      if (localStorage.filesPane) {\n        this._currentState = JSON.parse(localStorage.filesPane);\n      }\n\n      this.setPane(this._currentState.pane, this._currentState.details);\n      this._redoOffsets();\n\n      Event.addListener(\"fileIdChanged\", this._fileIdChanged.bind(this));\n    },\n\n    show: function() {\n      window.addEventListener(\"resize\", this._windowResized);\n    },\n\n    hide: function() {\n      window.removeEventListener(\"resize\", this._windowResized);\n    },\n\n    setPane: function(pane, details) {\n      if (this.currentPaneName == pane)\n        return;\n\n      var paneobj = null;\n\n      if (this.currentPaneName) {\n\n        var paneobj = this.panes[this.currentPaneName].pane;\n\n        if (paneobj.hide) {\n          paneobj.hide();\n        }\n\n        paneobj.afterHide();\n      }\n\n\n      paneobj = this.panes[pane].pane;\n\n      if (paneobj.show) {\n        paneobj.show(details);\n      }\n\n      paneobj.afterShow();\n\n      this.currentPaneName = pane;\n\n\n      // Finish up\n      var totalPane = this.panes[pane];\n\n      var translate = \"translate(\" + (-1 * totalPane.offsetX) + \"px, 0px)\";\n      if (this._paneWrapper.style.webkitTransform != translate) {\n        this._paneWrapper.classList.add(\"ani4\");\n        this._paneWrapper.style.webkitTransform = translate;\n      }\n\n\n      this._currentState = {\n        pane: \"list\",\n        details: null\n      };\n\n      if (pane != \"list\") {\n        this._currentState.pane = pane;\n        this._currentState.details = details;\n      }\n\n      localStorage.filesPane = JSON.stringify(this._currentState);\n    },\n\n    _finishedSliding: function(e) {\n      if (e.srcElement != this._paneWrapper) {\n        return;\n      }\n\n      // Remove the animation\n      this._paneWrapper.classList.remove(\"ani4\");\n\n      this._redoOffsets();\n    },\n\n    _windowResized: function() {\n      this._redoOffsets();\n    },\n\n    _redoOffsets: function() {\n      this._screenWidth = window.innerWidth;\n\n      // Set the offsets on all the panes so that the current pane is 0,0\n      var currentIndex = 0;\n      for (var pane in this.panes) {\n        if (this.currentPaneName == pane) {\n          break;\n        }\n\n        currentIndex++;\n\n      }\n\n      var startX = -1 * currentIndex * this._screenWidth;\n      for (var pane in this.panes) {\n        this.panes[pane].offsetX = startX;\n        this.panes[pane].pane.element.style.webkitTransform = 'translate(' + startX + \"px, 0px)\";\n        startX += this._screenWidth;\n      }\n\n      this._paneWrapper.style.webkitTransform = \"\";\n    },\n\n    _fileIdChanged: function(e) {      \n      // the current state details is a reference, so the id will change out from under us\n      // if it is the new id, then save it\n      if (this._currentState.details && this._currentState.details.id == e.newId) {\n        localStorage.filesPane = JSON.stringify(this._currentState);\n      }\n    },\n  });\n\n  return Files;\n\n});",
    "\ndefine('sections/main',[\"section\", \"event\", \"managers/files\"], function(Section, Event, Files) {\n\n  var Main = Section.extend({\n    id: \"main-container\",\n\n    mainContent: null,\n\n    // The panes we slide between in the main-content\n    panes: null,\n    currentPane: \"\",\n\n\n    init: function() {\n      this._super();\n\n      this.mainContent = document.getElementById(\"main-content\");\n      this.panes = {};\n\n      this.panes.files = new Files();\n      \n      Event.addListener(\"logout\", this._logout.bind(this));\n\n      this._setMode();\n    },\n\n    show: function() {\n      if (localStorage.currentPane) {\n        this.setPane(localStorage.currentPane);\n      } else {\n        this.setPane(\"files\");\n      }\n\n      //this.showDrawer();\n    },\n\n\n    setPane: function(pane) {\n      if (this.currentPane == pane)\n        return;\n\n      var paneobj = null;\n\n      if (this.currentPane) {\n\n        var paneobj = this.panes[this.currentPane];\n\n        if (paneobj.hide) {\n          paneobj.hide();\n        }\n\n        paneobj.afterHide();\n      }\n\n      paneobj = this.panes[pane];\n\n      if (paneobj.show) {\n        paneobj.show();\n      }\n\n      paneobj.afterShow();\n\n      this.currentPane = pane;\n\n      localStorage.currentPane = pane;\n      Event.trigger(\"paneChanged\", {\n        pane: paneobj\n      });\n    },\n\n    _logout: function() {\n      delete localStorage.currentPane;\n    },\n\n    _setMode: function() {\n      var element = document.getElementById(\"mode\");\n\n      if (window.gapi) {\n        mode.classList.remove(\"offline\");\n      }\n      else\n      {\n        mode.classList.add(\"offline\");\n      }\n    }\n  });\n\n  return Main;\n\n});",
    "\ndefine('managers/login',[\"event\", \"sections/login\", \"sections/main\"], function(Event, LoginSection, MainSection) {\n  function LoginManager() {\n    this.init();\n  }\n\n  LoginManager.prototype = {\n    pages: null,\n    currentPage: \"\",\n\n    init: function() {\n      this.pages = {};\n\n      Event.addListener(\"login\", this._login.bind(this));\n      Event.addListener(\"logout\", this._logout.bind(this));\n\n      this.pages.login = new LoginSection();\n      this.pages.main = new MainSection();\n\n      if (localStorage.loggedIn == \"true\") {\n        this.setPage(\"main\");\n      }\n      else\n      {\n        this.setPage(\"login\");\n      }\n    },\n\n    setPage: function(page) {\n      var pageobj = null;\n\n      if (this.currentPage) {\n\n        var pageobj = this.pages[this.currentPage];\n\n        if (pageobj.hide) {\n          pageobj.hide();\n        }\n        pageobj.afterHide();\n      }\n\n      pageobj = this.pages[page];\n      \n      if (pageobj.show) {\n        pageobj.show();\n      }\n      pageobj.afterShow();\n\n      this.currentPage = page;\n    },\n\n    _login: function() {\n      localStorage.loggedIn = true;\n      this.setPage(\"main\");\n    },\n\n    _logout: function() {\n      // https://accounts.google.com/Logout\n      localStorage.loggedIn = false;\n      this.setPage(\"login\");\n    }\n  };\n\n  return LoginManager;\n});",
    "\nrequire([\"event\", \"globals\", \"managers/login\", \"gauth\"], function(Event, g, LoginManager, GAuth) {\n\n  function init() {\n    if (Date.now() - localStorage.lastActive < 10) {\n      console.error(\"You can't open multiple copies in the same browser\");\n      return;\n    }\n\n    window.log = console.log.bind(console);\n\n    window.addEventListener(\"mousewheel\", function(e) {\n      e.preventDefault();\n    });\n\n    g.setHTMLDevices();\n\n    var loginManager = new LoginManager();\n\n    window.addEventListener(\"resize\", function() {\n      // make sure we are scrolled to 0. Without this there are problems \n      // when changing device orientation\n      window.scroll(0, 0);\n      setHeight();\n    });\n\n    function setHeight() {\n      document.body.style.height = window.innerHeight + \"px\";\n    }\n\n    setHeight();\n\n    GAuth.start(function() {\n      console.log(\"GAuth Loaded\");\n      require([\"dataLayer/data\"], function(Data) {\n        Data.startDrive();\n      });\n    });\n\n    setInterval(function() {\n      localStorage.lastActive = Date.now();\n    }, 5000);\n\n    //var realtime = new RealtimeData();\n    //realtime.startRealtime();\n  }\n\n  if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n    init();\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", init, false);\n  }\n});\ndefine(\"main\", function(){});\n"
  ]
}